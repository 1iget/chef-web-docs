---
title: 'Web operations with Chef'
description: 'Chef allows you to define what a system should look like, the responsibilities of that system, and then safely and reliable roll out changes to that system.'
order: 3
category: 'web-operations-essentials'
layout: skills-topic
icon: devops-diverse-skills.png
---

## Learning Objectives

After completing this unit, youâ€™ll be able to:

* Describe why infrastracture as code is powerful
* Describe how Chef manages the state of the sytem
* Describe the core systems within a Chef workflow

## Story

Chef provides a language that allows you to express the desired state of the system in a language which can lend itself to being readable and executable.

When defining the desired state of the system we start with an idea that we may convert to a document of bullet points. The applications that need to be installed, the services that are running, the credentials or files that are required to be installed, and the systems that it needs to be reached.

This document at first may eventually take the form of a script. This script may bring the system into the desired state. However, it may assume the state to begin with and does not query the initial state of the system and the calculate the work that has to be done. This may or may not work based on how the commands and automated steps handle an unknown state.

Chef allows you to express the desired state of every resource on your system. Chef defines a resource as a package, service, paths or files as a resource and provides a language that allows you to express the state of the resource.

A resource is an exercisable script but strives to be human-readble for English speakers. Resources have a type and a name. Additional details about the resource are captured in properties that help configure the resource. Importantly the resource has an action that it takes. Resources have quite a few defaults values set and a default action. These defaults aim not surprise the developer ultimately making it easier to define the desired state as fast as possible.

Each resource in Chef can or will take action first to check the current state of the system before taking action. This is often referred to test-and-repair.

IMAGE OF RESOURCE TESTING AND REPAIRING

The 'Test' part is where the resource will query the system to figure out the current state. If we are talking about packages being installed this means that the resource is going to query the system to see if the package is already installed. For a service, it would check to see if it is already running. A test that demonstrates that the system is in the correct taste will not take action because it has determined the the sytem is already in the desired state.

The 'Repair' part is where the resource will take action and bring the system into the desired state based. This means it would install the package, start the service, or modify the file contents to meet what is stated by the resource.

Resources can be configured to take action only when other resources take action. Imaginging if you were to install something from source you would only want this to happen when the initial resource to retrieve the remote file had found the file. Some resources do not have any test and simply take action. Those resources and all resource can have additional tests associated with them to ensure they take action or not take action.

A resource does not describe how it accomplishes this goal. Each resource is tied to a different provider and these providers may even choose a more specialized version for platform, platform, or even a specific scenario. This separation of the language from the implementation ensures that the resources describe the desired state in a natural language from from the implementation which is the concern for the provider.

A single resource is not enough to configure a single package or applciation. Several resources can be used together to ensure the system is in the desired state. These resources are collected together in a recipe file. This recipe file describes the resources ordered from top-to-bottom necessary to bring the system into the desired state. An application may contain several recipes. A recipe to install an application for clients of the system, another for the server, maybe one recipes contains additional features that are not always required to be installed, some may even be for a specific platform.

All of the recipes related to a particular scenario, like installing and configuring an application, are often grouped together into a cookbook. A cookbook also provides a way for the recipes as a whole to be versioned, define additional global, default values. Some resource may need a file or template to be present. All of these things live within a cookbook.

When we think about managing our infrastructure we may want to run these recipes, found in the cookbooks, on multiple systems. To do that would require us to make these available on every system. To do that you can upload them to the Chef Server, a central repository for cookbooks and node information. Each node then can define what recipes it needs to run to be configured in the exact way required to accomplish its role in the web application. Then each node will query the chef server and it will respond back with all the recipes, in their coobkooks, that are required. The node will execute the recipes and then report back to the Chef server if it succeeded.

As you update your recipes nodes can automatically check in again with the Chef Server and grab the latest or you can place each node within an environment that only applies very specific versions of the recipes that have been verified.

The ability to express the desired state in a more natural language way makes it easier to understand the state of your system. Resources are powerful because they provide ways to express the desired state of a single element of the system. These resource can be combined together into recipes and then into cookbooks to help create re-usable ways to create your infrastructure.
