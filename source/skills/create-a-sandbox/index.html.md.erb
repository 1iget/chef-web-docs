---
title: 'Using Test Kitchen to create sandboxes'
description: 'Create a sandbox where you can safely experiment with new ideas.'
order: 3
category: 'planning-and-practices'
layout: skills-topic
icon: devops-foundations.png
---
Written by: Jennifer Davis ([@sigje](https://twitter.com/sigje))

Sometime in 2015, when someone was describing their application stack, I heard about [Meteor](https://www.meteor.com/), a JavaScript app platform. When I saw there was an [introductory course](https://www.coursera.org/learn/meteor-development/) on Coursera, I decided to take the class and build on my JavaScript, HTML, and CSS experience.

I’m loathe to install development software directly onto my laptop when I’m first learning about it. One, I don’t know what I don’t know, and being able to quickly destroy the environment helps me to clean up if there are any security issues. Two, if there are conflicts with software that I depend on in my day to day, the consequences could be a nightmare of creating extra yaks to shave just to get back to a working state.

I solved the problem by creating a sandbox. I used [Test Kitchen](http://kitchen.ci/) with [Chef](https://www.chef.io/) and [Vagrant](https://www.vagrantup.com/) (or [AWS](https://aws.amazon.com/)) to quickly spin up a system that I could use to complete the coursework and to experiment without impacting my "normal" system (other than system resources like disk space, memory, CPU when using Vagrant).

This article walks you through the steps I followed to implement my solution. It was very much an iterative and incremental process that left me with something I could use to complete (and repeat) exercises in the course. In combination with [git](https://git-scm.com/), I could even quickly revert to a specific module within the class.

You can use the same process to create your own virtual environments where you can try out new ideas, do coursework, or just experiment without worrying about compromising your primary system.

[START_BOX]

##Prerequisite
Install the [Chef Development Kit](https://downloads.chef.io/chef-dk/), which includes Test Kitchen.

[END_BOX]

[START_BOX]

##Set up the base cookbook

For the Meteor class, the base cookbook was essentially my project class cookbook. I called it `meteor-app`, which was probably not the best name to use but it worked. If I were commiting my code back to GitHub to share, I’d probably be a bunch more specific in the naming.

I ran ``chef generate`` to create the cookbook:

```bash
$ chef generate cookbook meteor-app
```

Next, I opened the newly created <code class="file-path">.kitchen.yml</code> file and edited the platforms section.

In my case, I didn't need to test the application across multiple platforms so I deleted the Ubuntu entry and kept the CentOS entry. Then, I ran ``kitchen list`` to display the platforms included in the file to make sure the file was correct.

[END_BOX]

[START_BOX]

##Create the base image
I used the ``kitchen create`` comand to create the base image. If the base OS image isn’t available on the system, it is automatically downloaded from the Internet.

Because I’ve done this many times, the image was already available and the setup was very quick. I used <https://opscode-vm-bento.s3.amazonaws.com/vagrant/virtualbox/opscode_centos-7.1_chef-provisionerless.box> for the image. I could, of course, have modified the location to specify a different image.

Running ``kitchen create`` also set up an instance of CentOS 7 on my local laptop that was based on this image. If I had wanted to host my instance on AWS  instead of Vagrant, I would have changed the `driver name:` entry in the <code class="file-path">.kitchen.yml</code> file from `vagrant` to `ec2`.

[END_BOX]

[START_BOX]

##Install Chef
Next, I ran ``kitchen converge``.

Converging my node with the ``kitchen converge`` command installed Chef and ran the default recipe, <code class="file-path">meteor-app/recipes/default.rb</code>, which was currently empty.

[END_BOX]

[START_BOX]

##Log in
I then logged into the system with the ``kitchen login`` command.

If you have more than one instance, you need to include the specific instance you want to use . For example, to specify my instance, I would have typed:

 ```bash
 $ kitchen login default-centos-71
 ```

By default, you are logged in as the user **vagrant**.

Within the course, the first thing they wanted me to do was to set up a working directory. Although this step wasn't as critical because of my separate development instance, I created a directory with the ``mkdir dev`` command. I also updated the <code class="file-path">default.rb</code> recipe with a resource directory.

If I were to copy my `meteor-app` cookbook to a new system and run ``kitchen converge``, the system that booted up would already have the dev directory created for me.

[END_BOX]

[START_BOX]

##Use a repo
For each of the class exercises, I would first try it out, then set up my recipe to reflect what needed to be done. I committed the changes as I went through each module, along with documentation, to a local git repository or to GitHub. Using a repository meant that I could easily revert to any specific instance state, as it existed at a particular point in time.

If I wanted to test something that was different from what the instructor asked, I could do so without worrying about completely breaking my environment. This was especially important when I was working with something new and I didn’t have enough context yet to understand how my changes would impact the system.

[END_BOX]

[START_BOX]

##Install Meteor
The next step was to install the Meteor JavaScript app, using the curl bash syntax ``curl https://install.meteor.com/ | sh``.

To translate the install instructions into Chef for my recipe, I could have used the community cookbook named [meteor](https://supermarket.chef.io/cookbooks/meteor), which is on [Supermarket](https://supermarket.chef.io/). However, I decided to do a minimum installation so I simply used the shell script that is available at <https://install.meteor.com>. If I wanted, I could even store the specific version within the cookbook. If you're interested, you can read the script to learn exactly what it does.

Next, for the course, I created an app from the command line on the virtual machine with ``meteor create my_first_app``.

![](./images/01_create_app.png)


This command set up 3 files called <code class="file-path">my\_first\_app.css</code>, <code class="file-path">my\_first\_app.html</code> and <code class="file-path">my\_first\_app.js</code>.


Next, within the <code class="file-path">my\_first\_app directory</code>, I started up my system with the ``meteor`` command.

After I had installed <code class="file-path">meteor.js</code>, set up the app, and started up `meteor`, I realized that it was running on port 3000 by default. Since I’m running on a virtual machine, I can’t just go directly to port 3000 from my web browser. I fixed this by updating the driver section for vagrant, in the <code class="file-path">.kitchen.yml</code> file. I added a `network` section that forwarded the local port on my system to the port on the virtual machine.

```yaml
# .kitchen.yml
driver:
   name: vagrant
   network:
   - ["forwarded_port", {guest: 3000, host: 3000}]
```

With this configuration, I could now browse to **localhost:3000**.

![](./images/02_web_page.png)

[END_BOX]

[START_BOX]

##Summary
The process I've described gave me a working environment that allowed me to edit my local cookbook, converge my node, and see the output of my changes from my browser without breaking anything on my base system. I could easily iterate and change as much as I wanted. As long as my cookbook reflected the changes that I needed to replicate my environment, I could quickly get back to a working state whenever I needed to.

[END_BOX]
