---
title: 'Configure a resource'
order: 1
---
# Configure a resource

<i class="icon-cogs icon-2x" style="float:left; margin-right:10px;"></i> Let's start by configuring a file on disk. You initially want the file to be created and have specific contents if it doesn't exist. You later want to modify the contents of the file and also ensure that an outside process doesn't modify the file.

## Setup

Open a terminal window and create a directory to work in. We recommend ~/chef-tutorials/.

```bash
$ mkdir ~/chef-tutorials
$ cd ~/chef-tutorials
```

## Use Chef to create a file

Here's Chef's version of 'Hello, world!'

Let's have Chef ensure that the file /tmp/hello exists and that its contents are 'hello world'.

Save the following to ~/chef-tutorials/hello.rb.

```ruby
# hello.rb
file '/tmp/hello' do
  content 'hello world'
end
```

From your terminal window, run <codeinline>chef-apply</codeinline> to apply what you've written.

```bash
$ chef-apply hello.rb
```

<comment>crushtime-4: ^ Perhaps all commands should center around 'chef'. For example, 'chef apply' instead of 'chef-apply'. Exceptions to this are chef-client and knife.</comment>

The output tells us that a new file was created at /tmp/hello. 

```bash
Recipe: (chef-apply cookbook)::(chef-apply recipe)
  * file[/tmp/hello] action create
    - create new file /tmp/hello
    - update content in file /tmp/hello from none to de031d
        --- /tmp/hello  2014-05-13 14:52:54.025253948 -0700
        +++ /tmp/.hello20140513-3474-5263n1 2014-05-13 14:52:54.025253948 -0700
        @@ -1 +1,2 @@
        +hello world
```

Now run <codeinline>cat</codeinline> to verify that the file was written.

```bash
$ cat /tmp/hello
```
```bash
hello world
```

## Run chef-apply again

Let's see now what happens when you run the same command again.

```bash
$ chef-apply hello.rb
```

This time you get a different response.

```bash
Recipe: (chef-apply cookbook)::(chef-apply recipe)
  * file[/tmp/hello] action create (up to date)
```

This is because Chef does work only when it needs to. Chef looks at the current configuration state and applies action only if it doesn't match the desired state. Here, Chef doesn't create or modify /tmp/hello because it already exists and its contents didn't change.

## Update the file's contents

Now modify hello.rb like this ('hello world' becomes 'hello chef'.)

```ruby
# hello.rb
file '/tmp/hello' do
  content 'hello chef'
end
```

And run <codeinline>chef-apply</codeinline>.

```bash
$ chef-apply hello.rb
```

This time Chef does work because the file no longer matches our desired state.

```bash
Recipe: (chef-apply cookbook)::(chef-apply recipe)
  * file[/tmp/hello] action create
    - update content in file /tmp/hello from de031d to b1522f
        --- /tmp/hello  2014-05-13 14:52:54.025253948 -0700
        +++ /tmp/.hello20140513-4015-13xpiup  2014-05-13 15:00:07.284522132 -0700
        @@ -1,2 +1,2 @@
        -hello world
        +hello chef
```

To see it a different way, manually change the contents of the file that we're managing, /tmp/hello, by replacing 'hello chef' with 'hello robots'.

```
# /tmp/hello
hello robots
```

And run <codeinline>chef-apply</codeinline> again.

```bash
$ chef-apply hello.rb
```

Chef applies the change because the contents of the file no longer matches.

```bash
Recipe: (chef-apply cookbook)::(chef-apply recipe)
  * file[/tmp/hello] action create
    - update content in file /tmp/hello from 9b0c18 to b1522f
        --- /tmp/hello  2014-05-13 15:03:47.638770524 -0700
        +++ /tmp/.hello20140513-4170-130uqxh  2014-05-13 15:04:43.874771326 -0700
        @@ -1,2 +1,2 @@
        -hello robots
        +hello chef
```

Chef enables you to both apply a new configuration state as well as ensure that the current state stays how you want it.

## Resources & recipes

In Chef, we call the <codeinline>file</codeinline> part of the program a *file resource*. A resource describes one part of the system and its desired state. A file resource therefore describes the desired state of a file.

Chef calls hello.rb a _recipe_, which is an ordered series of configuration states. A recipe typically contains related states, such as everything needed to configure a web or database server or a load balancer.

## Accessing prior versions

We saw how Chef restores a resource's state if an external process changes it. Imagine a co-worker manually changes a configuration file on a server you manage with Chef. Chef restores its configuration the next time it runs, so your co-worker's hard work is lost, right?

Luckily, Chef saves a backup of the previous resource version, so all is not lost. You can recover the changes and incorporate them into your recipe so that it gets applied when Chef runs. Backups are saved to /var/chef/backup, and Chef maintains the previous 5 versions by default.

You typically don't need to work with backups, it's good to know that they're there when you need them. 

<comment>crushtime-1: ^ saving backups to /var/chef/backup requires root access, when the recipe otherwise might not need it. Consider moving backups to home directory, perhaps only when running in --local-mode. That way, you don't need to run with sudo by default.</comment> 

<comment>crushtime-1: ^ tangental comment, but if a recipe fails, the error log gets written to a location that requires sudo access to read. This might cause chef-[command] to require sudo when it normally wouldn't.</comment>

## Delete the file

OK, let's clean up. Save the following recipe to goodbye.rb.

```ruby
# goodbye.rb
file '/tmp/hello' do
  action :delete
end
```

Here you see the <codeinline>delete</codeinline> action. Think of an _action_ as the process that achieves the desired configuration state. Every resource in Chef has a default action, and it's the most common affirmative one - for example, _create_ a file, _install_ a package, and _start_ a service. Earlier we didn't specify the <codeinline>create</codeinline> action when we created the file because <codeinline>create</codeinline> is the default. But of course you can specify it if you want.

Now apply goodbye.rb to delete the file.

```bash
$ chef-apply goodbye.rb
```

```bash
Recipe: (chef-apply cookbook)::(chef-apply recipe)
  * file[/tmp/hello] action delete
    - delete file /tmp/hello
```

The output shows that /tmp/hello is now gone, but let's prove it.

```bash
$ ls /tmp/hello
```
```bash
ls: cannot access /tmp/hello: No such file or directory
```

## Wrap up

Congratulations. You ran a few basic Chef commands and got a flavor of what Chef can do. Specifically, you saw that:

<ul class="icons">
  <li><i class="icon-star"></i>a <i>resource</i> describes one part of the system and its desired state. A file is an example of a resource.</li>
  <li><i class="icon-star"></i>a <i>recipe</i> is an ordered series of configuration states. You might have one recipe to configure your web server and another for your database server.</li>
  <li><i class="icon-star"></i>an <i>action</i> is the part of a resource that achieves the desired configuration state. The default action is the most common affirmative one, such as creating a file.</li>
  <li><i class="icon-star"></i>Chef applies configuration state only when it needs to.</li>
</ul>

If you'd like, check out the reference on some of the concepts we just covered.

  * [About Recipes](http://docs.opscode.com/essentials_cookbook_recipes.html)
  * [file](http://docs.opscode.com/resource_file.html)
  * [chef-apply](http://docs.opscode.com/ctl_chef_apply.html)

## Next

Of course, Chef is about more than just setting up files. Next you'll apply what you've learned to install and configure a package and service.

<%= link_to 'Configure a package and service &rarr;', '/rhel/configure-a-package-and-service/', class: 'button radius' %>