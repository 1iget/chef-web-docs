---
title: "Get started with Chef Development Kit"
nav_title: "Get started with Chef DK"
order: -1
layout: tutorial
description: TODO
keywords: TODO
---

<font color="red">
Don't get hung up on the format. Maybe the TOC will look like (with names that focus on problems, not technologies):
<PRE>
Get started with Chef DK
+- Configure your local workstation
+- Configure a remote computer
+- Test your configuration
+- ...Environments
+- ...Roles
+- ...Data bags
+- ...more
</PRE>
</font>


<font color="red">For v1, make it work on a few different Linux distros (Ubuntu + Debian, RedHat family, everything that the Chef DK download page says works), then be clear here that this is for Linux and MacOS and Windows versions are coming soon.</font>

# Get started with Chef DK

The easiest way to learn Chef is to use Chef. Here you'll learn how Chef puts together resources that describe how to configure a system. In about _N_ minutes, you'll use Chef to manage a file and then configure Apache web server to serve up a basic home page.

Later you'll learn how to manage remote computers, but all you need right now is a workstation to install Chef DK on. Working in local mode is a great way to learn Chef's capabilities. Because the commands you'll use here *will* configure some things on your system, make sure you're working from a computer that you're comfortable making changes to. Consider spinning up a VM if you can.

Now on to the fun!

## Install Chef DK

OK, first thing's first. Install Chef DK on your workstation to get the tools.

<%= link_to 'Install Chef DK &rarr;', 'http://www.getchef.com/downloads/chef-dk/', :target => "_blank", class: 'button radius' %>

### Verify the installation

<font color="red">Or maybe chef --verify?</font>

Open up a terminal window and **cd** to a temporary directory to work in (**/tmp** works just fine.) Then check the **chef** version.

```bash
$ chef --version
```

## Manage a file

Let's start by managing a file. In Chef, we call this a *file resource*. A resource describes one part of the system and its desired state. 

Save the following Ruby code to a file named **hello.rb**.

<font color="red">I could link to stuff, like the file resource, etc. But should I not add them to keep things focused?</font>

```ruby
# hello.rb
file '/tmp/hello' do
  content 'Hello, world!'
end
```

In plain English, this program reads as: ensure that a file named **hello**, whose contents is **Hello, world!**, exists in the **/tmp** directory.

Now run **chef-apply** to apply the resource to your system.

```bash
$ sudo chef-apply hello.rb
```

You'll see something like this.

```bash
Recipe: (chef-apply cookbook)::(chef-apply recipe)
  * file[/tmp/hello] action create
    - create new file /tmp/hello
    - update content in file /tmp/hello from none to 12ba72
        --- /tmp/hello  2014-05-09 12:08:02.648680591 -0700
        +++ /tmp/.hello20140509-18184-nzdmow  2014-05-09 12:08:02.652680591 -0700
        @@ -1 +1,2 @@
        +Hello, robots!
```

This output says that a new file was created at **/tmp/hello**, its contents were added, and that there was 1 change (from nothing to one line of text.)

Now verify that the file was written.

```bash
$ cat /tmp/hello
```

The trusty line **Hello, world!** is printed to the terminal.

Cool, you just wrote a recipe to configure your system! Chef calls hello.rb a *recipe*, which is a collection of configuration states. A recipe typically contains several related states, such as everything needed to configure a web server or a SQL database.

Chef does work only when it needs to. To see what that means, run **chef-apply** a second time.

```bash
$ sudo chef-apply hello.rb
```

You'll see something like this:

```bash
Recipe: (chef-apply cookbook)::(chef-apply recipe)
  * file[/tmp/hello] action create (up to date)
```

Chef left /tmp/hello alone because it already exists and its contents didn't change.

Now change the **content** attribute in hello.rb from the string **"Hello, world!"** to **"Hello, robots!"** (use your text editor if you prefer.)

```bash
sed -i 's/world/robots/g' hello.rb
``` 

Now run **chef-apply again**.

<font color="red">Undelight: I sometimes have to run chef-apply with sudo, sometimes not. I guess it depends on what actions I specify and if Chef has to do work. Is it reasonable to have to always run with sudo? Would the typical Linux user expect this?</font>

```bash
$ sudo chef-apply hello.rb
```

You'll see something like this:

```bash
Recipe: (chef-apply cookbook)::(chef-apply recipe)
  * file[/tmp/hello] action create
    - update content in file /tmp/hello from 315f5b to 12ba72
        --- /tmp/hello  2014-05-09 13:11:42.440675442 -0700
        +++ /tmp/.hello20140509-20462-1fobq94 2014-05-09 13:11:55.464675425 -0700
        @@ -1,2 +1,2 @@
        -Hello, world!
        +Hello, robots!
```

Chef updated /tmp/hello because its contents no longer match the policy, which is for the file to contain the text **Hello, robots!**.

Chef also saved a backup of the previous version. Backups are saved to /var/chef/backup, and Chef maintains the previous 5 versions by default.

In the previous example, you changed the contents of the source file and Chef updated the destination. Chef works the same way if the destination file changes but the source doesn't. To see this in action, try changing the contents of /tmp/hello manually and then run the **chef-apply** command. Chef applies the change because the current state doesn't match the desired state. So you can use Chef not only to roll out new policies, but also to manage problems like configuration drift.

Now run **chef-apply** one final time, just to see that action is taken only when needed.

```bash
$ sudo chef-apply hello.rb
```

OK, let's clean up after ourselves. Save the following recipe to **goodbye.rb**.

```ruby
# goodbye.rb
file '/tmp/hello' do
  action :delete
end
```

Here you see the use of the **delete** action. We didn't specify the **create** action when we first created the file because **create** is the default.

Now run it.

```bash
$ chef-apply goodbye.rb
```

The file **/tmp/hello** should now be gone, but let's prove it.

```
$ [ -f /tmp/hello ] && echo "/tmp/hello still exists" || echo "/tmp/hello was deleted"
```

Great! Now lets apply these ideas to something a bit more exciting.

## Configure a web server

You've just configured a file resource. Packages and services are also kinds of resources. Let's use Chef to install package **apache2** and start the service.

Let's first confirm that Apache isn't installed.

```bash
$ dpkg --get-selections | grep apache2
```

You might see a few entries, but you shouldn't see **apache2** or **apache2-utils**. If you do, you can run this command to remove them.

```bash
$ sudo apt-get remove --purge apache2 apache2-utils
```

Now let's install the package. Add this recipe to a file named **webserver-up.rb**.

```ruby
# webserver-up.rb
package 'apache2'
```

Now run it.

```bash
$ sudo chef-apply webserver-up.rb
```

Now run **dpkg** again to confirm that Apache is installed.

```bash
$ dpkg --get-selections | grep apache2
```

You'll see something like this.

```bash
apache2                                           install
apache2-mpm-worker                                install
apache2-utils                                     install
apache2.2-bin                                     install
apache2.2-common                                  install
```

If you run the recipe a second time, you'll see that Chef does no work because we're in the desired state.

<font color="red">Remove this step?</font>

When you install Apache, the service starts automatically. But for fun let's ensure that it's up and running. Append this **service** resource to **webserver-up.rb**.

```ruby
# webserver-up.rb
service 'apache2' do
  action [ :enable, :start ]
end
```

Now run it.

```bash
$ sudo chef-apply webserver-up.rb
```

You'll see that everything's up to date.

```bash
Recipe: (chef-apply cookbook)::(chef-apply recipe)
  * package[apache2] action install (up to date)
  * service[apache2] action enable (up to date)
  * service[apache2] action start (up to date)
```

**apache2** should also appear in the process list.

```bash
$ ps ax | grep apache2 | grep -v grep
```

```bash
24003 ?        Ss     0:00 /usr/sbin/apache2 -k start
24004 ?        S      0:00 /usr/sbin/apache2 -k start
24006 ?        Sl     0:00 /usr/sbin/apache2 -k start
24007 ?        Sl     0:00 /usr/sbin/apache2 -k start
```

Now let's serve up a basic web page. You already know how to configure a **file** resource; now add this one between the **package** and **service** resources in webserver-up.rb.

```ruby
# webserver-up.rb
file '/var/www/index.html' do
  content '<html>
  <body>
    <h1>Hello from 192.168.145.132!</h1>
  </body>
</html>'
end
```

Run it.

```bash
$ sudo chef-apply webserver-up.rb
```

You'll see file resource applied.

Now confirm your page is being served (run this command or use your web browser on your workstation or even another computer if you prefer.)

```
$ wget -O- http://localhost
```

You'll see your home page printed to the terminal.

### Tear down your web server

<font color="red">Remove this? it _does_ teach something, and I'm  trying to help folks clean up their machine state.</font>

So now let's say you'd like to tear down your web server. Add this recipe to **webserver-down.rb** and save it.

```
# webserver-down.rb
service 'apache2' do
  action [ :stop, :disable ] # note the order!
end

package 'apache2' do
  action :remove
end
```

Notice that the **service** and **package** resources in the webserver-down recipe are applied in reverse order from the webserver-up recipe. Also, the actions in the **service** resource are reversed. In a Chef recipe, order matters. Resources are applied and actions are taken in the order they're declared. So for our web server, we need to apply everything in the reverse order to property tear everything down.

Now run the recipe.

```bash
$ sudo chef-apply webserver-down.rb
```

You'll see the service stopped and the package removed.

```bash
Recipe: (chef-apply cookbook)::(chef-apply recipe)
  * service[apache2] action stop
    - stop service service[apache2]

  * service[apache2] action disable
    - disable service service[apache2]

  * package[apache2] action remove
    - remove  package apache2
```

## What's next?

<font color="red">What other colorful things can we say to help the reader feel like a Chefer?</font>

Congratulations! You now have a recipe that configures Apache and serves up a basic page. And if your machine's state changes, the recipe will get things back in line with the current policy. But you may notice a few problems with the **file** resource in our Apache recipe.

1. This approach mixes code with data. As you add more content to your website, things will get unwieldy really fast.
1. The IP address is hard-coded. You need to run a command like **ifconfig** to the IP address and add it in manually. This is not good for automation.

We'll solve these problems one by one in the next tutorial.
