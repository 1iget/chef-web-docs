---
title: 'Configure the database'
order: 6
keywords: TODO
layout: lesson
sections: []
next: {heading: Next, partial: next}
time_to_complete: 20 minutes
---
Now that we've written code to configure SQL Server, let's create a database, a table, and add sample rows to the table so we can test that the web application works.

To do so, we'll add SQL commands to a script file in our cookbook and copy that script file to a working directory and run it when the cookbook runs. Each step will implement Chef's test and repair mechanism to ensure that it is applied only when needed.

[START_BOX]

## 1. Create the create-database.sql SQL script file

Let's start by creating a script file named <code class="file-path">create-database.sql</code>.

Run the following command to create an empty file in your cookbook.

```bash
# ~/learn-chef
$ chef generate file cookbooks/awesome_customers_windows create-database.sql
Installing Cookbook Gems:
Compiling Cookbooks...
Recipe: code_generator::cookbook_file
  * directory[cookbooks/awesome_customers_windows/files/default] action create
    - create new directory cookbooks/awesome_customers_windows/files/default
  * template[cookbooks/awesome_customers_windows/files/default/create-database.sql] action create
    - create new file cookbooks/awesome_customers_windows/files/default/create-database.sql
    - update content in file cookbooks/awesome_customers_windows/files/default/create-database.sql from none to e3b0c4
    (diff output suppressed by config)
```

This command added the <code class="file-path">create-database.sql</code> file to the<br><% fp '~/learn-chef/cookbooks/awesome_customers_windows/files/default' %> directory.

[END_BOX]

[START_BOX]

## 2. Add commands to the SQL script file

Now let's add commands to the script file that perform the following tasks:

1. Create a database named `learnchef`.
1. Create a table named `customers` in the `learnchef` database.
1. Add sample data to the `customers` table.

Add the following to your <code class="file-path">create-database.sql</code> file.

```sql
-- ~/learn-chef/cookbooks/awesome_customers_windows/files/default/create-database.sql

USE master;
GO
-- Create the learnchef database.
CREATE DATABASE learnchef;
GO
USE learnchef;
GO
-- Create the customers table.
CREATE TABLE customers(
  id uniqueidentifier NOT NULL DEFAULT newid(),
  PRIMARY KEY(id),
  first_name VARCHAR(64),
  last_name VARCHAR(64),
  email VARCHAR(64)
);
GO
-- Add sample data to the table.
INSERT INTO customers(id, first_name, last_name, email) VALUES(newid(), 'Jane', 'Smith', 'jane.smith@example.com');
INSERT INTO customers(id, first_name, last_name, email) VALUES(newid(), 'Dave', 'Richards', 'dave.richards@example.com');
GO
```

[END_BOX]

[START_BOX]

## 3. Run the SQL script file

So far our `database` recipe installs SQL Server. <code class="file-path">database.rb</code> looks like this.

```ruby
# ~/learn-chef/cookbooks/awesome_customers_windows/recipes/database.rb
# Install SQL Server.
include_recipe 'sql_server::server'
```

Now let's add code to our `database` recipe that copies <code class="file-path">create-database.sql</code> from the cookbook to a working directory and applies it. We'll use the Chef cache as our working directory. This is the same directory that you used earlier to hold the configuration file for the Local Configuration Manager.

In this part, you'll:

* [Create a variable that defines the path to the Chef cache](#createavariablethatdefinesthepathtothechefcache)
* [Copy the SQL script from the cookbook to the Chef cache](#copythesqlscriptfromthecookbooktothechefcache)
* [Add code that runs the SQL script](#addcodethatrunsthesqlscript)

### Create a variable that defines the path to the Chef cache

The first step is to copy <code class="file-path">create-database.sql</code> to the Chef cache. We'll refer to the full path to <code class="file-path">create-database.sql</code> multiple times in our recipe, so let's create a variable that defines the location one time, but we can reference multiple times.

Append this to <code class="file-path">database.rb</code>.

```ruby
# ~/learn-chef/cookbooks/awesome_customers_windows/recipes/database.rb
# Create a path to the SQL file in the Chef cache.
create_database_script_path = win_friendly_path(File.join(Chef::Config[:file_cache_path], 'create-database.sql'))
```

This code uses `Chef::Config[:file_cache_path]` to read the location of the Chef cache from the [chef-client configuration file](https://docs.chef.io/config_rb_client.html). Although the location of the Chef cache can vary, it's typically located at <code class="file-path">C:\chef\cache</code> on Windows.

The [File.join](http://ruby-doc.org/core-2.2.0/File.html#method-c-join) part combines the Chef cache directory with the SQL script filename to create a full path.

The `win_friendly_path` part ensures that the Windows path separator `\` (and not the Linux path separator `/`) is used in the full path. When writing Chef recipes for Windows, it's common to use this to ensure that the Windows path separator is used consistently. Ensuring that the Windows path separator is used can be important when:

* a Ruby method, Chef utility, or another cookbook returns a path and you want to ensure that it's formatted properly for Windows.
* you pass a path name to a Windows command-line utility or to a Windows programming interface such as PowerShell which requires the `\` path separator.

The [windows](https://supermarket.chef.io/cookbooks/windows) cookbook provides `win_friendly_path` as a helper, or utility, method. We can use it here because the `sql_server` cookbook depends on the `windows` cookbook and loads it for us.

### Copy the SQL script from the cookbook to the Chef cache

Append the following `cookbook_file` resource to your `database` recipe to copy the SQL script file from your cookbook to the path you just defined.

```ruby
# ~/learn-chef/cookbooks/awesome_customers_windows/recipes/database.rb
# Copy the SQL file from the cookbook to the Chef cache.
cookbook_file create_database_script_path do
  source 'create-database.sql'
end
```

The `create_database_script_path` is the full path to the SQL script file, for example, <code class="file-path">C:\chef\cache\create-database.sql</code> and is the destination of the copy operation. The `source` attribute defines the source of the copy operation, <code class="file-path">files/default/create-database.sql</code> in your `awesome_customers_windows` cookbook.

### Add code that runs the SQL script

Now we'll add code that runs the SQL script. We'll use the `powershell_script` resource to run the PowerShell [Invoke-Sqlcmd](https://msdn.microsoft.com/en-us/library/cc281720\(v=sql.110\).aspx) cmdlet to execute the script.

When we run the `Invoke-Sqlcmd` cmdlet, we need to ensure that the `SQLPS` module is loaded. Let's create a variable that contains the full path to the module so we can define it one time but use it multiple times.

Append this code to your `database` recipe.

```ruby
# ~/learn-chef/cookbooks/awesome_customers_windows/recipes/database.rb
# Get the full path to the SQLPS module.
sqlps_module_path = ::File.join(ENV['programfiles(x86)'], 'Microsoft SQL Server\110\Tools\PowerShell\Modules\SQLPS')
```

We can use the system's environment variables to get the correct path to the <code class="file-path">Program Files (x86)</code> directory (typically <code class="file-path">C:\Program Files (x86)</code>).

The Ruby [ENV](http://ruby-doc.org/core-2.2.0/ENV.html) class reads environment variables. This code joins the full path to the <code class="file-path">Program Files (x86)</code> directory to the fixed  path to the `SQLPS` module.

Now append this code to run the SQL script.

```ruby
# ~/learn-chef/cookbooks/awesome_customers_windows/recipes/database.rb
# Run the SQL file only if the 'learnchef' database has not yet been created.
powershell_script 'Initialize database' do
  code <<-EOH
    Import-Module "#{sqlps_module_path}"
    Invoke-Sqlcmd -InputFile #{create_database_script_path}
  EOH
  guard_interpreter :powershell_script
  only_if <<-EOH
    Import-Module "#{sqlps_module_path}"
    (Invoke-Sqlcmd -Query "SELECT COUNT(*) AS Count FROM sys.databases WHERE name = 'learnchef'").Count -eq 0
  EOH
end
```

This code uses the heredoc mechanism that you used when you set up IIS and ASP.NET so that you can express the PowerShell code more naturally. The `#{}` syntax is what's called _string interpolation_. String interpolation enables you to replace placeholders within a string with the values they represent. Although heredocs enable you to define multiple lines of pre-formatted text, you can still use string interpolation in a heredoc to substitute placeholders with other values. Here, we reference the `create_database_script_path` variable so that we can pass the full path to the SQL script file to the `Invoke-Sqlcmd` cmdlet.

The `only_if` part enables the SQL script to run only when needed. In this case, we run the script only when the `learnchef` database does not exist.

[START_MODAL sql-script Should the SQL script be more granular?]

Recall that the SQL script file looks like this:

```sql
-- ~/learn-chef/cookbooks/awesome_customers_windows/files/default/create-database.sql

USE master;
GO
-- Create the learnchef database.
CREATE DATABASE learnchef;
GO
USE learnchef;
GO
-- Create the customers table.
CREATE TABLE customers(
  id uniqueidentifier NOT NULL DEFAULT newid(),
  PRIMARY KEY(id),
  first_name VARCHAR(64),
  last_name VARCHAR(64),
  email VARCHAR(64)
);
GO
-- Add sample data to the table.
INSERT INTO customers(id, first_name, last_name, email) VALUES(newid(), 'Jane', 'Smith', 'jane.smith@example.com');
INSERT INTO customers(id, first_name, last_name, email) VALUES(newid(), 'Dave', 'Richards', 'dave.richards@example.com');
GO
```

Our `only_if` guard tests only for when the `learnchef` database doesn't exist; it doesn't cover the case where the `customers` table or the sample data doesn't exist. This is fine for learning purposes. In practice, you would need to decide how granular your scripts and your tests need to be. For example, you might break this script into three separate scripts &ndash; one to create the database, one to create the table, and one to create the sample data &ndash; if there is a chance that one component might be changed or removed by some other process.

[END_MODAL]

Your entire `database` recipe looks like this.

```ruby
# ~/learn-chef/cookbooks/awesome_customers_windows/recipes/database.rb
# Install SQL Server.
include_recipe 'sql_server::server'

# Create a path to the SQL file in the Chef cache.
create_database_script_path = win_friendly_path(File.join(Chef::Config[:file_cache_path], 'create-database.sql'))

# Copy the SQL file from the cookbook to the Chef cache.
cookbook_file create_database_script_path do
  source 'create-database.sql'
end

# Get the full path to the SQLPS module.
sqlps_module_path = ::File.join(ENV['programfiles(x86)'], 'Microsoft SQL Server\110\Tools\PowerShell\Modules\SQLPS')

# Run the SQL file only if the 'learnchef' database has not yet been created.
powershell_script 'Initialize database' do
  code <<-EOH
    Import-Module "#{sqlps_module_path}"
    Invoke-Sqlcmd -InputFile #{create_database_script_path}
  EOH
  guard_interpreter :powershell_script
  only_if <<-EOH
    Import-Module "#{sqlps_module_path}"
    (Invoke-Sqlcmd -Query "SELECT COUNT(*) AS Count FROM sys.databases WHERE name = 'learnchef'").Count -eq 0
  EOH
end
```

[END_BOX]

[START_BOX]

## 4. Apply and verify the configuration

As before, let's apply and then verify the configuration. Run `kitchen converge` to apply the `awesome_customers_windows` cookbook.

```bash
# ~/learn-chef/cookbooks/awesome_customers_windows
$ kitchen converge
-----> Starting Kitchen (v1.8.0)
-----> Converging <default-windows-2012r2>...
       Preparing files for transfer
       Preparing dna.json
       Resolving cookbook dependencies with Berkshelf 4.3.2...
       Removing non-cookbook files before transfer
       Preparing validation.pem
       Preparing client.rb
[...]
           - update content in file C:\Users\vagrant\AppData\Local\Temp\kitchen\cache\create-database.sql from none to 25997f
           --- C:\Users\vagrant\AppData\Local\Temp\kitchen\cache\create-database.sql	2016-04-27 02:56:05.000000000 +0000
           +++ C:\Users\vagrant\AppData\Local\Temp\kitchen\cache/chef-create-database.sql20160427-1960-kigbnk	2016-04-27 02:56:05.000000000 +0000
           @@ -1 +1,21 @@
           +USE master;
           +GO
           +-- Create the learnchef database.
           +CREATE DATABASE learnchef;
           +GO
           +USE learnchef;
           +GO
           +-- Create the customers table.
           +CREATE TABLE customers(
           +  id uniqueidentifier NOT NULL DEFAULT newid(),
           +  PRIMARY KEY(id),
           +  first_name VARCHAR(64),
           +  last_name VARCHAR(64),
           +  email VARCHAR(64)
           +);
           +GO
           +-- Add sample data to the table.
           +INSERT INTO customers(id, first_name, last_name, email) VALUES(newid(), 'Jane', 'Smith', 'jane.smith@example.com');
           +INSERT INTO customers(id, first_name, last_name, email) VALUES(newid(), 'Dave', 'Richards', 'dave.richards@example.com');
           +GO
         * powershell_script[Initialize database] action run
           - execute "C:\Windows\system32\WindowsPowerShell\v1.0\powershell.exe" -NoLogo -NonInteractive -NoProfile -ExecutionPolicy Bypass -InputFormat None -File "C:/Users/vagrant/AppData/Local/Temp/chef-script20160427-4088-z769t4.ps1"

       Running handlers:
       Running handlers complete
       Chef Client finished, 2/12 resources updated in 49 seconds

       Finished converging <default-windows-2012r2> (1m13.42s).
-----> Kitchen is finished. (1m16.10s)
```

You'll see from the output that the SQL script is copied to the Chef cache and then the script is executed.

Now let's connect to your node and run a few commands to help verify the database configuration. This time, we'll verify that:

* the `learnchef` database exists.
* the `customers` database table exists and contains the sample data.

From a PowerShell session on your Test Kitchen instance, run these commands to set up PowerShell to manage SQL Server.

```ps
$ Set-ExecutionPolicy RemoteSigned
$ Import-Module SQLPS
```

Now run the `Invoke-Sqlcmd` cmdlet to list all databases on the system.

```ps
$ Invoke-Sqlcmd -Query "SELECT name FROM sys.databases"

name
----
master
tempdb
model
msdb
learnchef
```

`learnchef` is listed as a database name.

Now verify that the customers database table exists and contains the sample data. Run the `Invoke-Sqlcmd` cmdlet to query a few fields from all rows in the `customers` table.

```ps
$ Invoke-Sqlcmd -Database learnchef -Query "SELECT id,first_name FROM customers"

id                                                          first_name
--                                                          ----------
cd5f1fd3-aa84-4dd9-8c08-ba0e54afefdb                        Jane
98f65465-9bbd-4551-aafe-c5f212df31db                        Dave
```

"Jane" and "Dave" match the first names that we provided in your SQL script.

Everything checks out! You can now minimize or close your connection.

[END_BOX]
