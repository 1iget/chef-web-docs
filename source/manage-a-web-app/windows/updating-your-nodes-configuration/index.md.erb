---
title: "Appendix: Updating your node's configuration"
order: 10
keywords: TODO
layout: lesson
sections: []
appendix: true
meta_tags: [{name: "ROBOTS", content: "NOINDEX, NOFOLLOW"}]
---
In this tutorial, you developed a web application cookbook locally. Only after verifying that the final configuration works as expected on a local test instance did you upload your cookbook to Chef server and apply it to a bootstrapped node.

Here are some steps you can take to update your nodes as you improve your cookbooks and add features. You can practice these steps by making a small change to the `awesome_customers_windows` cookbook and then uploading and applying your updated configuration to your node. 

[START_BOX]

## Verify your changes locally

Whenever you make a change to a cookbook, it's best to run your cookbook through Test Kitchen on a clean instance to verify that it works as expected before you commit your work to source control or upload to Chef server.

A basic workflow looks like this:

1. Run `kitchen destroy` to clean up any prior instances.
1. Run `kitchen converge` to bring up a clean instance and apply your cookbook.
1. Verify your work, either by remotely connecting to your services from your workstation or by running `kitchen login` to verify the configuration directly from the instance. 
1. Run `kitchen destroy` to clean up your test environment.

As you [learn about the various kinds of testing](/test-your-infrastructure-code/windows/), you'll also want to verify that your tests continue to pass. Automated testing helps you quickly verify that you're not breaking existing functionality as you add new features.

[END_BOX]

[START_BOX]

## Update your cookbook's version metadata

You should always update your cookbook's version metadata to ensure that each version is tied to a specific set of functionality. Your cookbook's <code class="file-path">metadata.rb</code> file holds the cookbook's version. When you run the<br>`chef generate cookbook` command to create your cookbook, the initial version is set to 0.1.0. Here's an example.

```ruby
# ~/learn-chef/cookbooks/awesome_customers_windows
name 'awesome_customers_windows'
maintainer 'The Authors'
maintainer_email 'you@example.com'
license 'all_rights'
description 'Installs/Configures awesome_customers_windows'
long_description 'Installs/Configures awesome_customers_windows'
version '0.1.0'

depends 'sql_server', '~> 2.5.0'
depends 'iis', '~> 4.1.6'
```

Most Chef cookbooks follow the [Semantic Versioning](http://semver.org) scheme. Version numbers are typically written as MAJOR.MINOR.PATCH, where:

* MAJOR specifies a change that's incompatible with previous versions.
* MINOR specifies new functionality that's backwards-compatible with previous versions.
* PATCH specifies backwards-compatible bug fixes.

According to [Semantic Versioning](http://semver.org), you should set your cookbook's version number to 1.0.0 at the point it's ready to use in production.

[END_BOX]

[START_BOX]

## Upload your work to Chef server

After you've verified your work locally and updated the version metadata, you're ready to upload your work to Chef server.

There are serveral ways to upload your changes to Chef server. You might start with a manual process. As your process matures, you might use a [continuous delivery](https://en.wikipedia.org/wiki/Continuous_delivery) (CD) system, such as [Chef Delivery](https://www.chef.io/delivery/). Your CD pipeline could include a step that uploads your changes to Chef server after they are validated.

Here's a manual process that you can start with.

### 1. Use Berkshelf to install new dependencies

If you introduced any new cookbook dependencies in your cookbook, run `berks install` from your cookbook's directory before you upload your updated cookbook to Chef server. This command installs the new depdendencies in Berkshelf's cache, <% fp '~/.berkshelf/cookbooks' %>.

### 2. Use Berkshelf to upload your updated cookbooks to the Chef server

After you've resolved your cookbook's dependencies on other cookbooks, run `berks upload` to upload everything to the Chef server.

When you pin to specific cookbook versions in your cookbook's <% fp 'metadata.rb' %> file, Berkshelf can skip the upload process for cookbook versions that already exist on the Chef server.

[COMMENT] Remember, Berkshelf requires a trusted SSL certificate in order to upload cookbooks. If you're using your own Chef server, and not hosted Chef, you'll need to configure Chef server [to use a trusted SSL certificate](https://osxdominion.wordpress.com/2015/02/25/configuring-chef-server-12-to-use-trusted-ssl-certs/). The [Chef documentation](http://docs.chef.io/server_security.html#ssl-protocols) describes how Chef server works with SSL certificates.<br/><br/>Alternatively, for testing purposes you can run `berks upload --no-ssl-verify` to disable SSL verification.

### 3. Upload any other data to the Chef server

If you're using [roles](https://docs.chef.io/roles.html) or [environments](https://docs.chef.io/environments.html), run [knife upload](https://docs.chef.io/knife_upload.html) to upload any changed settings to your Chef server.

If you're using [data bags](https://docs.chef.io/data_bags.html), run [knife data bag](https://docs.chef.io/knife_data_bag.html) to upload any changes to those items as well.

[END_BOX]

[START_BOX]

## Run chef-client on your node

Now that your updated cookbooks and other data are on the Chef server, you're ready to apply the changes to your node. Remember that when you run `chef-client`, your node checks in with the Chef server to get the latest cookbooks and other information and then applies the run-list.

Here are some ways you might start a `chef-client` run on your node.

* Set up `chef-client` as [a service](https://docs.chef.io/install_windows.html#run-as-a-service) or [scheduled task](https://docs.chef.io/install_windows.html#run-as-a-scheduled-task) that runs periodically, say every 30 or 60 minutes. 
* Run [knife winrm](https://github.com/chef/knife-windows#knife-winrm) or use [push jobs](https://docs.chef.io/push_jobs.html).
* Use [Chef provisioning](https://docs.chef.io/provisioning.html) in a cookbook. With Chef provisioning, you model your infrastructure like you do any other Chef resource. For example, the [machine](https://docs.chef.io/resource_machine.html) resource provides the `:converge` and `:converge_only` actions, which run `chef-client` on the machine.

For example, if you're using a CD system, you might use `knife ssh`, push jobs, or Chef provisioning to kick off a `chef-client` run as part of your pipeline. 

<hr>

A manual way that you can start with involves running `knife winrm` from your workstation. `knife winrm` takes as an argument the command to run on the node. Here, you specify `chef-client`.

Here's an example for use with this tutorial. Replace <code class="placeholder">ADDRESS</code> with your remote node's external address, <code class="placeholder">USER</code> with your username, and <code class="placeholder">PASSWORD</code> with your password.

```bash
# ~/learn-chef
$ knife winrm ADDRESS 'chef-client' --manual-list --winrm-user USER --winrm-password 'PASSWORD' --winrm-transport ssl --winrm-ssl-verify-mode verify_none
```

For example:

```bash
# ~/learn-chef
$ knife winrm 52.36.120.7 'chef-client' --manual-list --winrm-user Administrator --winrm-password 'R7dP$f(JN3' --winrm-transport ssl --winrm-ssl-verify-mode verify_none
WARNING: * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
SSL validation of HTTPS requests for the WinRM transport is disabled. HTTPS WinRM
connections are still encrypted, but knife is not able to detect forged replies
or spoofing attacks.

To fix this issue add an entry like this to your knife configuration file:

``
  # Verify all WinRM HTTPS connections (default, recommended)
  knife[:winrm_ssl_verify_mode] = :verify_peer
``
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
52.36.120.7 [2016-02-13T01:02:58+00:00] INFO: *** Chef 12.7.2 ***
52.36.120.7 [2016-02-13T01:02:58+00:00] INFO: Chef-client pid: 1376
52.36.120.7 [2016-02-13T01:03:03+00:00] INFO: Run List is [recipe[awesome_customers_windows]]
[...]
52.36.120.7 [2016-02-13T01:03:20+00:00] INFO: Chef Run complete in 17.187073 seconds
52.36.120.7 [2016-02-13T01:03:20+00:00] INFO: Running report handlers
52.36.120.7 [2016-02-13T01:03:20+00:00] INFO: Report handlers complete
52.36.120.7 [2016-02-13T01:03:20+00:00] INFO: Sending resource update report (run-id: ea332274-563f-42b8-ac92-1ff9ce27e491)
```

[END_BOX]

[START_BOX]

## Keep up with the latest dependent cookbooks

In this tutorial you _pinned_, or specified, version constraints on the community cookbooks your cookbook depends on. Here's an example from the `awesome_customers_windows` cookbook's metadata file.

```ruby
# ~/learn-chef/cookbooks/awesome_customers_windows
name 'awesome_customers_windows'
maintainer 'The Authors'
maintainer_email 'you@example.com'
license 'all_rights'
description 'Installs/Configures awesome_customers_windows'
long_description 'Installs/Configures awesome_customers_windows'
version '0.1.0'

depends 'sql_server', '~> 2.5.0'
depends 'iis', '~> 4.1.6'
```

Most Chef cookbooks follow the [Semantic Versioning](http://semver.org) scheme. Version numbers are typically written as MAJOR.MINOR.PATCH.

Pinning to the specific versions of the cookbooks you depend on is a recommended practice because it declares a version your cookbook is known to work with. If you don't pin the version, Berkshelf will always download the latest version, which may be incompatible with your cookbook.

Recall that the `~>` syntax, called the _pessimistic version constraint_, tells Chef that we want the latest version of the cookbook that's greater than or equal to MAJOR.MINOR.PATCH but less than MAJOR.(MINOR+1).0. The third digit in a Chef cookbook's version typically relates to bug fixes or patches that are compatible with prior versions, and are typically acceptable to pick up automatically. The documentation explains [other ways to specify version constraints](http://docs.chef.io/cookbook_versions.html).

You may want to occasionally update your version constraints to point to newer (or perhaps the latest) versions of dependent cookbooks. Newer versions typically include new features, security fixes, and improved ease of use. Unless you require a new feature in your cookbook, you may want to update to newer cookbook versions independently of any other changes to your cookbook. Doing so will minimize complications in case something stops working.

You can get the latest version of a community cookbook from its page on Chef Supermarket or by running the<br>`knife cookbook site show` command, like this.

```bash
# ~/learn-chef
$ knife cookbook site show httpd | grep latest_version
latest_version:     https://supermarket.chef.io/api/v1/cookbooks/httpd/versions/0.3.5
```

When you update your dependent cookbook versions, always test and verify that they continue to behave as you expect. Updates to the MINOR version are typically backwards-compatible with previous releases. Updates to the MAJOR version may require you to modify how you use the cookbook.

After you verify updates locally using Test Kitchen, you'll need to run the `berks update` command to update the Berkshelf cache with the newer cookbook versions. `berks update` differs from `berks install` in that `berks install` downloads any new cookbooks that you don't have on your workstation. `berks update` updates existing cookbooks.

[END_BOX]