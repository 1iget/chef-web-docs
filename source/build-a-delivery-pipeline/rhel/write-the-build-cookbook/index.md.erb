---
title: 'Write the build cookbook'
order: 3
keywords: TODO
layout: lesson
sections: []
next: {heading: Next, partial: next}
time_to_complete: 60 minutes
meta_tags: [{name: 'robots', content: 'noindex, nofollow'}]
---
So far, you have a basically empty build cookbook. In this lesson, you'll add functionality to the phases highlighted here:

| Verify     | Build      | Acceptance    | Union         | Rehearsal     | Delivered     |
|------------|------------|---------------|---------------|---------------|---------------|
| <span class="highlight-text">**Unit**</span>   | <span class="highlight-text">**Unit**</span>   | <span class="highlight-text">**Provision**</span> | <span class="highlight-text">**Provision**</span> | <span class="highlight-text">**Provision**</span> | <span class="highlight-text">**Provision**</span> |
| <span class="highlight-text">**Lint**</span>   | <span class="highlight-text">**Lint**</span>   | <span class="highlight-text">**Deploy** </span>   | <span class="highlight-text">**Deploy**</span>    | <span class="highlight-text">**Deploy**</span>    | <span class="highlight-text">**Deploy**</span>    |
| <span class="highlight-text">**Syntax**</span> | <span class="highlight-text">**Syntax**</span> | <span class="highlight-text">**Smoke**</span>     | <span class="highlight-text">**Smoke**</span>     | <span class="highlight-text">**Smoke**</span>     | <span class="highlight-text">**Smoke**</span>     |
|            | Quality    | Functional    | Functional    | Functional    | Functional    |
|            | Security   |               |               |               |               |
|            | <span class="highlight-text">**Publish**</span>|               |               |               |               |

Your build cookbook consists of recipes. Each recipe corresponds to a phase, such as lint or syntax. Any time that a phase runs, no matter in which stage, it uses the same recipe. For example, the recipe for the lint phase runs in the Verify and Build stages. You can use conditional logic to customize how the recipe behaves for a given stage.

How you define each phase depends on your project and its requirements. For example, if your project contains JavaScript, you might run JSLint as part of the lint phase. Alternatively, if you don't currently run lint tests on your code, you can leave the phase empty or configure Chef Delivery to skip it.

Our project is the `awesome_customers` cookbook. Here's a brief summary of what each phase will accomplish.

* **unit** &ndash; runs ChefSpec.
* **lint** &ndash; runs Foodcritic and RuboCop.
* **syntax** &ndash; runs `knife cookbook test`.
* **publish** &ndash; uploads `awesome_customers` and the cookbooks it depends on to the Chef server.
* **provision** &ndash; uses Chef provisioning to bootstrap the web application server. The server will have the `awesome_customers` cookbook in its run-list. For AWS, the phase also brings up the instance if it is not yet created.
* **deploy** &ndash; runs `chef-client` on the web application server.
* **smoke** &ndash; verifies that the web server is at least minimally functional.

To help implement these steps, we'll use the [delivery-truck](https://github.com/chef-cookbooks/delivery-truck) cookbook. This cookbook performs tasks that are typical for a cookbook project. For example, its `unit` recipe runs ChefSpec and its `lint` recipe runs Foodcritic and RuboCop. You'll start by adding `delivery-truck` as a dependency to your build cookbook. Then, step-by-step, you'll add the recipes for each phase.

You'll also update the build cookbook so that it uploads an encrypted data bag to Chef server. The Customers application needs the items in the data bag to access its database.

## 1. Incorporate the delivery-truck cookbook

In this part, you'll add a dependency on the `delivery-truck` cookbook and run each of its phases.

First, verify that you're on the `master` branch.

```bash
$ git branch
  add-delivery-config
* master
```

Create a new branch named `add-delivery-truck`.

```bash
# ~/Development/deliver-customers-rhel
$ git checkout -b add-delivery-truck
Switched to a new branch 'add-delivery-truck'
```

Verify that you're on the new branch.

```bash
# ~/Development/deliver-customers-rhel
$ git branch
  add-delivery-config
* add-delivery-truck
  master
```

### Add the dependency

Now modify <code class="file-path">~/Development/deliver-customers-rhel/.delivery/build-cookbook/metadata.rb</code> like this. The metadata file lists which cookbooks the build cookbook depends on.

```ruby
# ~/Development/deliver-customers-rhel/.delivery/build-cookbook/metadata.rb
name 'build-cookbook'
maintainer 'The Authors'
maintainer_email 'you@example.com'
license 'all_rights'
version '0.1.0'

depends 'delivery-truck'
```

Now modify <code class="file-path">~/Development/deliver-customers-rhel/.delivery/build-cookbook/Berksfile</code> like this. The <code class="file-path">Berksfile</code> describes where to get dependent cookbooks.

The [Learn to manage a basic Red Hat Enterprise Linux web application](/manage-a-web-app/rhel) tutorial, [explains the process](/manage-a-web-app/rhel/apply-and-verify-your-web-server-configuration) in more detail.

```ruby
# ~/Development/deliver-customers-rhel/.delivery/build-cookbook/Berksfile
source 'https://supermarket.chef.io'

metadata

group :delivery do
  cookbook 'delivery_build', git: 'https://github.com/chef-cookbooks/delivery_build'
  cookbook 'delivery-base', git: 'https://github.com/chef-cookbooks/delivery-base'
  cookbook 'test', path: './test/fixtures/cookbooks/test'
end

cookbook 'delivery-sugar', git: 'https://github.com/chef-cookbooks/delivery-sugar'
cookbook 'delivery-truck', git: 'https://github.com/chef-cookbooks/delivery-truck'
```

[PRODNOTE] `delivery-truck` depends on `delivery-sugar`, but the build process complained about not having it. Maybe I did something wrong. Can someone try omitting the dep on `delivery-sugar` and let me know what happens?

### Include the delivery-truck cookbook's recipes

Now you'll include each of the `delivery-truck` cookbook's recipes in your build cookbook's recipes.

For example, make your `build-cookcook` cookbook's default recipe, <code class="file-path">default.rb</code>, look like this.

```ruby
# ~/Development/deliver-customers-rhel/.delivery/build-cookbook/recipes/default.rb
include_recipe 'delivery-truck::default'
```

Follow the same pattern for the remaining recipes: <code class="file-path">deploy.rb</code>, <code class="file-path">functional.rb</code>, <code class="file-path">lint.rb</code>, <code class="file-path">provision.rb</code>, <code class="file-path">publish.rb</code>, <code class="file-path">quality.rb</code>, <code class="file-path">security.rb</code>, <code class="file-path">smoke.rb</code>, and <code class="file-path">unit.rb</code>.

### Commit the changes

Run `git status` to see the unstaged changes.

```bash
# ~/Development/deliver-customers-rhel
$ git status
On branch add-delivery-truck
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   .delivery/build-cookbook/Berksfile
	modified:   .delivery/build-cookbook/metadata.rb
	modified:   .delivery/build-cookbook/recipes/default.rb
	modified:   .delivery/build-cookbook/recipes/deploy.rb
	modified:   .delivery/build-cookbook/recipes/functional.rb
	modified:   .delivery/build-cookbook/recipes/lint.rb
	modified:   .delivery/build-cookbook/recipes/provision.rb
	modified:   .delivery/build-cookbook/recipes/publish.rb
	modified:   .delivery/build-cookbook/recipes/quality.rb
	modified:   .delivery/build-cookbook/recipes/security.rb
	modified:   .delivery/build-cookbook/recipes/smoke.rb
	modified:   .delivery/build-cookbook/recipes/syntax.rb
	modified:   .delivery/build-cookbook/recipes/unit.rb
	modified:   .delivery/config.json

no changes added to commit (use "git add" and/or "git commit -a")
```

Now run `git add .` to stage them for commit.

```bash
# ~/Development/deliver-customers-rhel
$ git add .
```

Finally, commit the changes.

```bash
# ~/Development/deliver-customers-rhel
$ git commit -m "pull in delivery-truck cookbook"
[add-delivery-truck 24f7971] pull in delivery-truck cookbook
 14 files changed, 17 insertions(+), 1 deletion(-)
```

### Submit the change for review

When you set up the project, you ran `delivery init` to create the project and move it through the pipeline.

This time, since the project already exists, run `delivery review` to submit your change as a candidate to be merged into the project's `master` branch.

```bash
# ~/Development/deliver-customers-rhel
$ delivery review
Chef Delivery
Loading configuration from /home/thomaspetchel/Development/deliver-customers-rhel
Review for change add-delivery-truck targeted for pipeline master
Created new patchset
https://10.194.11.99/e/test/#/organizations/learn-chef/projects/deliver-customers-rhel/changes/a09401ca-4e39-48e4-96d7-23ed1631f9e0
```

[COMMENT] If you use GitHub, you know that pull requests let you tell others about your changes. The `delivery review` command is similar. It allows others to review your changes. Once approved, your changes can be merged into `master` and continue through the rest of the pipeline.

The first stage of the pipeline, Verify, begins and the Delivery UI appears. Trace the change's progress through the pipeline just as you did when you validated the pipeline.

1. Review the changes in the web interface. Click **Approve** when all tests pass.
1. Watch the change progress through the Build and Acceptance stages.
1. After the Acceptance stage completes, press the **Deliver** button.
1. Watch the change progress through the Acceptance, Union, Rehearsal, and Delivered stages.

[PRODNOTE] Need to go back through and see exactly what happens at each phase. For example, I don't think unit does anything because the cookbook hasn't yet changed. Verify and talk about it here...

Great work. You've successfully incorporated the `delivery-truck` cookbook into your build cookbook.

### Integrate the change locally

Just as you did for the initial `add-delivery-config` branch that set up the project, you now need to merge the `master` branch to your local repository. Here's how.

```bash
# ~/Development/deliver-customers-rhel
$ git checkout master
Switched to branch 'master'
Your branch is up-to-date with 'delivery/master'.
$ git fetch
remote: Counting objects: 1, done.
remote: Total 1 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (1/1), done.
From ssh://test@10.194.11.99:8989/test/learn-chef/deliver-customers-rhel
   a9471ce..bd8a8b2  master     -> delivery/master
$ git pull delivery master
From ssh://test@10.194.11.99:8989/test/learn-chef/deliver-customers-rhel
 * branch            master     -> FETCH_HEAD
Updating a9471ce..bd8a8b2
Fast-forward
 .delivery/build-cookbook/Berksfile             | 3 +++
 .delivery/build-cookbook/metadata.rb           | 2 ++
 .delivery/build-cookbook/recipes/default.rb    | 1 +
 .delivery/build-cookbook/recipes/deploy.rb     | 1 +
 .delivery/build-cookbook/recipes/functional.rb | 1 +
 .delivery/build-cookbook/recipes/lint.rb       | 1 +
 .delivery/build-cookbook/recipes/provision.rb  | 1 +
 .delivery/build-cookbook/recipes/publish.rb    | 1 +
 .delivery/build-cookbook/recipes/quality.rb    | 1 +
 .delivery/build-cookbook/recipes/security.rb   | 1 +
 .delivery/build-cookbook/recipes/smoke.rb      | 1 +
 .delivery/build-cookbook/recipes/syntax.rb     | 1 +
 .delivery/build-cookbook/recipes/unit.rb       | 1 +
 .delivery/config.json                          | 2 +-
 14 files changed, 17 insertions(+), 1 deletion(-)
```

[GITHUB] The final code for this section is available on [GitHub](https://github.com/learn-chef/deliver-customers-rhel/tree/add-delivery-truck-v1.0.0) (tag `add-delivery-truck-v1.0.0`.)

## 2. Publish the awesome_customers cookbook to your Chef server

Where you publish your projects is up to you. You might publish a cookbook project to Chef server, Chef Supermarket, GitHub, or all of the above.

In this tutorial, you'll publish the `awesome_customers` cookbook to Chef server. You'll also need to publish an encrypted data bag to Chef server. This data bag contains encrypted database passwords that the `awesome_customers` requires to set up the web application ([learn more about the process](/manage-a-web-app/rhel/create-a-password-store/).)

The `delivery-truck` cookbook's `publish` recipe is already set up to publish your cookbook to Chef server, Chef Supermarket, and GitHub. All you need to do is set a node attribute.

### Create a branch

First, verify that you're on the `master` branch.

```bash
# ~/Development/deliver-customers-rhel
$ git branch
  add-delivery-config
  add-delivery-truck
* master
```

Run these commands to create the `publish-customers-app` branch and verify that you're on that branch.

```bash
# ~/Development/deliver-customers-rhel
$ git checkout -b publish-customers-app
Switched to a new branch 'publish-customers-app'
$ git branch
  add-delivery-config
  add-delivery-truck
  master
* publish-customers-app
```

### Create a default node attributes file

To enable the `delivery-truck` cookbook to upload your cookbook to Chef server, you need set a node attribute. First, create a default node attributes file.

Run this command to generate the file.

```bash
# ~/Development/deliver-customers-rhel/.delivery
$ chef generate attribute .delivery/build-cookbook default
Compiling Cookbooks...
Recipe: code_generator::attribute
  * directory[./.delivery/build-cookbook/attributes] action create
    - create new directory ./.delivery/build-cookbook/attributes
  * template[./.delivery/build-cookbook/attributes/default.rb] action create
    - create new file ./.delivery/build-cookbook/attributes/default.rb
    - update content in file ./.delivery/build-cookbook/attributes/default.rb from none to e3b0c4
    (diff output suppressed by config)
```

### Set the node attribute to publish to Chef server

To tell the `delivery-truck` cookbook that you want to publish your cookbooks to Chef server, you need to set the `node['delivery']['config']['delivery-truck']['publish']['chef_server']` attribute.

Add this to your default node attributes file, <code class="file-path">default.rb</code>.

```ruby
# ~/Development/deliver-customers-rhel/.delivery/build-cookbook/attributes/default.rb
default['delivery']['config']['delivery-truck']['publish']['chef_server'] = true
```

The `delivery-truck` cookbook reads this attribute and automatically uploads any changed cookbooks to the Chef server during the publish phase, which is part of the Build stage.

### Prepare your encryption key and encrypted data bag items

If you've gone through the [Learn to manage a basic Red Hat Enterprise Linux web application](/manage-a-web-app/rhel) tutorial, copy your encrypted data bag items, <code class="file-path">db_admin_password.json</code> and <code class="file-path">sql_server_root_password.json</code> to the <code class="file-path">~/Development/deliver-customers-rhel/data_bags/passwords</code> directory. You can then move to the next step.

If you haven't gone through this tutorial, or no longer have your encrypted data bag items or your encryption key, you'll create them now.

The first step is to replace the encrypted versions of the data bag items that come with the project with plain-text versions, like this.

```ruby
# ~/Development/deliver-customers-rhel/data_bags/passwords/db_admin_password.json
{
  "id": "db_admin_password",
  "password": "database_password"
}
```

```ruby
# ~/Development/deliver-customers-rhel/data_bags/passwords/sql_server_root_password.json
{
  "id": "sql_server_root_password",
  "password": "learnchef_mysql"
}
```

Next, perform [step 1](/manage-a-web-app/rhel/create-a-password-store#step1) from this previous tutorial lesson to create an encryption key.

Then perform [step 8](/manage-a-web-app/rhel/create-a-password-store#step8) from that same lesson to encrypt the data bag items locally.

You don't have to perform the other steps because you'll write code that uploads your encrypted data bag items to the Chef server in a later step.

### Upload the encrypted data bag items

The `delivery-truck` cookbook's `publish` recipe takes care of uploading the `awesome_customers` cookbook to Chef server for us. We need to now set up the build cookbook's `publish` recipe to upload the data bag items.

The build node runs the build cookbook in local mode, which means that the cookbook runs on a temporary, in-memory Chef server (we introduced running `chef-client` in local mode [in the first tutorial](/learn-the-basics/rhel/make-your-recipe-more-manageable#step4)). In order to upload the encrypted data bag to the Chef server, we need to change the behavior of `chef-client` to work with our Chef server.

To do that, you call the `with_server_config` helper method. This helper method sets the Chef server configuration, calls the provided block, and then restores the previous configuration.

To upload the encrypted data bag items, we'll use the built-in `execute` resource to run the `knife` command. We need to both create the data bag and then upload our two data bag items.

[PRODNOTE] Why do we need `--config` if we're already saying `with_server_config`? It seeme redundant, but it's the only way that works.

Write out your build cookbook's `publish` recipe like this.

```ruby
# ~/Development/deliver-customers-rhel/.delivery/build-cookbook/recipes/publish.rb
include_recipe 'delivery-truck::publish'

with_server_config do
  execute 'create passwords data bag' do
    cwd node['delivery']['workspace']['repo']
    command "knife data bag create passwords --config #{delivery_knife_rb}"
    not_if "knife data bag list --config #{delivery_knife_rb} | grep '^passwords$'"
  end
  %w(db_admin_password sql_server_root_password).each do |data_bag_item|
    execute "create #{data_bag_item} data bag item" do
      cwd node['delivery']['workspace']['repo']
      command "knife data bag from file passwords #{data_bag_item}.json --config #{delivery_knife_rb}"
    end
  end
end
```

The first `execute` resource uses a `not_if` guard to ensure that the data bag is created only if it doesn't exist. The second `execute` resource uploads the data bag items each time they go through the pipeline in case they ever change.

### Increment the awesome_customers cookbook's version

The `delivery-truck` cookbook acts only on cookbooks that have changed (in other words, only on cookbooks that have files that are part of the current Git commit.) This enables the pipeline to move more quickly by performing only necessary work.

Let's make a basic change to trigger the unit, lint, syntax, and publish phases to run. You'll increment the `awesome_customers` cookbook's version from 0.3.0 to 1.0.0, which, according to [Semantic Versioning](http://semver.org), marks the cookbook as ready for production.

In your `awesome_customers` cookbook's metadata file, <code class="file-path">metadata.rb</code>, update the `version` field from 0.3.0 to 1.0.0, like this.

```ruby
# ~/Development/deliver-customers-rhel/cookbooks/awesome_customers/metadata.rb
name 'awesome_customers'
maintainer 'The Authors'
maintainer_email 'you@example.com'
license 'all_rights'
description 'Installs/Configures awesome_customers'
long_description 'Installs/Configures awesome_customers'
version '1.0.0'

depends 'httpd', '~> 0.2.18'
depends 'selinux', '~> 0.9.0'
depends 'iptables', '~> 1.0.0'
depends 'mysql2_chef_gem', '~> 1.0.1'
depends 'mysql', '~> 6.0.17'
depends 'database', '~> 4.0.3'
```

Run these commands to commit your changes.

```bash
# ~/Development/deliver-customers-rhel
$ git status
On branch publish-customers-app
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   cookbooks/awesome_customers/metadata.rb

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	.delivery/build-cookbook/attributes/

no changes added to commit (use "git add" and/or "git commit -a")
$ git add .
$ git commit -m "publish version 1.0.0 to Chef server"
[publish-customers-app b9b9bf0] publish version 1.0.0 to Chef server
 2 files changed, 2 insertions(+), 1 deletion(-)
 create mode 100644 .delivery/build-cookbook/attributes/default.rb
```

Now run `delivery review` to submit your changes to the pipeline.

```bash
# ~/Development/deliver-customers-rhel
$ delivery review
Chef Delivery
Loading configuration from /home/thomaspetchel/Development/deliver-customers-rhel
Review for change publish-customers-app targeted for pipeline master
Created new patchset
https://10.194.11.99/e/test/#/organizations/learn-chef/projects/deliver-customers-rhel/changes/ac585f79-2d35-4e4d-ae57-c83d1b4922ba
```

You'll see the unit, lint and syntax phases test the `awesome_customers` cookbook. For example, the lint phase runs Foodcritic and RuboCop.

![](delivery/delivery-lint.png)

Trace the change's progress through the pipeline to the Acceptance stage, as you did when you validated the pipeline.

1. Review the changes in the web interface. Click **Approve** when all tests pass.
1. Watch the change progress through the Build and Acceptance stages.

After Acceptance succeeds, don't press the **Deliver** button. We'll queue up additional changes and deliver them as a single unit.

### Verify that the awesome_customers cookbook and the data bag are on your Chef server

The publish phase uploads your cookbooks and any dependencies that are listed in your <code class="file-path">Berksfile</code>.

Let's verify that your cookbook is on the Chef server. There are two ways to do this &ndash; from the command line or from the Chef management console.

#### Verify from the command line

The `delivery-cluster` cookbook sets up a `knife` configuration file, <code class="file-path">knife.rb</code>, and server certificates to enable you to administer your Chef server from your workstation or provisioning node.

To verify the status of the `awesome_customers` cookbook from the command line, first, move to the <code class="file-path">~/Development/delivery-cluster/.chef</code> directory.

```bash
# ~/Development/deliver-customers-rhel
$ cd ~/Development/delivery-cluster/.chef
```

You'll see your <code class="file-path">knife.rb</code> file and the <code class="file-path">trusted_certs</code> directory, which contains the Chef server's SSL certificates.

```bash
# ~/Development/delivery-cluster/.chef
$ ls
delivery-cluster-data       knife.rb          syntaxcache
delivery-cluster-data-test  local-mode-cache  trusted_certs
```

Run the `knife cookbook list` command to list all cookbooks and then search the result for the `awesome_customers` cookbook.

```bash
# ~/Development/delivery-cluster/.chef
$ knife cookbook list | grep awesome_customers
awesome_customers     1.0.0
```

As expected, version 1.0.0 is on the Chef server.

Now run `knife data bag show passwords` to list the contents of the passwords data bag.

```bash
# ~/Development/delivery-cluster/.chef
$ knife data bag show passwords
db_admin_password
sql_server_root_password
```

As expected, the data bag exists and contains the database administrator and root passwords.

#### Verify from the Chef management console

When you use the `delivery-cluster` cookbook to set up your Chef server, the cookbook installs the Chef management console.

To access the management console, you'll need the Chef server URL and the administrator password. To get the Chef server URL, first move to the <code class="file-path">~/Development/delivery-cluster</code> directory.

```bash
# ~/Development/delivery-cluster/.chef
$ cd ~/Development/delivery-cluster
```

Now run the `rake info:list_core_services` command to see information about your Chef Delivery cluster.

```bash
# ~/Development/delivery-cluster
$ rake info:list_core_services
2 items found

delivery-server-test:
  ipaddress: 10.194.11.99

build-node-test-1:
  ipaddress: 10.194.13.122

chef_server_url      'https://10.194.12.65/organizations/test'
```

Navigate to your `chef_server_url` and login as `delivery`:`delivery`.

From the **Policy** tab, you'll see that the `awesome_customers` cookbook's version is listed as 1.0.0.

![](delivery/management-console-customers-cookbook.png)

Choose **Data Bags** from the menu on the left, then select **passwords**. You'll see the items for the database administrator and root passwords.

![](delivery/management-console-passwords-data-bag.png)

### Integrate the change locally

As we did previously, we need to merge the remote `master` branch to your local repo. Here's a reminder of how to do this.

First, move to your <code class="file-path">~/Development/deliver-customers-rhel</code> directory.

```bash
# ~/Development/delivery-cluster
$ cd ~/Development/deliver-customers-rhel
```

Now run these commands.

```bash
# ~/Development/deliver-customers-rhel
$ git checkout master
Switched to branch 'master'
Your branch is up-to-date with 'delivery/master'.
$ git fetch
remote: Counting objects: 1, done.
remote: Total 1 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (1/1), done.
From ssh://test@10.194.11.99:8989/test/learn-chef/deliver-customers-rhel
   bd8a8b2..a100d45  master     -> delivery/master
$ git pull delivery master
From ssh://test@10.194.11.99:8989/test/learn-chef/deliver-customers-rhel
 * branch            master     -> FETCH_HEAD
Updating bd8a8b2..a100d45
Fast-forward
 .delivery/build-cookbook/attributes/default.rb           | 1 +
 cookbooks/awesome_customers/metadata.rb                  | 2 +-
 2 files changed, 2 insertions(+), 1 deletion(-)
 create mode 100644 .delivery/build-cookbook/attributes/default.rb
```

[GITHUB] The final code for this section is available on [GitHub](https://github.com/learn-chef/deliver-customers-rhel/tree/publish-customers-app-v1.0.0) (tag `publish-customers-app-v1.0.0`.)

## 3. Provision your Acceptance, Union, Rehearsal, and Delivered stages

In this part, we'll provision the last four stages of your pipeline with the infrastructure they need to run the awesome_customers cookbook. Just as you did when you installed Chef Delivery, you can choose to use AWS to provision the stages or to provision them manually, via SSH. No matter which one you select, we'll use key-based authentication because it's more secure than password authentication and it's simpler to use.

When you installed Chef Delivery, the installer created an encryption key for you, located at  <code class="file-path">~/Development/delivery-cluster/.chef/delivery-cluster-data/encrypted\_data\_bag\_secret</code>. We'll use that key to:

  * Encrypt our AWS credentials in a data bag if you're using the AWS provisioner.
  * Encrypt the private key used for SSH authentication in a data bag for both AWS and SSH.
  * Encrypt the secret file used to decrypt the database password used by the Customers web application.

You'll create node attributes in your build cookbook that describe your Acceptance, Union, Rehearsal, and Delivered stages and reference those attributes in your recipe for the provision phase.

[PRODNOTE] I can't get this to work using the SSH driver. I need someone to help fix what's wrong.

### Create a data bag to hold provisioning data

In this part, you'll create a data bag to hold your SSH private key. You'll also encrypt your AWS credentials in a data bag if you're using AWS.

```bash
$ cd ~/Development/delivery-cluster
```

```bash
# ~/Development/delivery-cluster
$ knife data bag create provisioning-data
Created data_bag[provisioning-data]
```

### Encrypt and upload your private key

In [Get set up](/build-a-delivery-pipeline/rhel/get-set-up/), you chose whether to use AWS or SSH to provision your Acceptance, Union, Rehearsal, and Delivered stages. In either case, you have a private key file that enables you to connect to the servers over SSH. In this part, you'll encrypt your key and add it to your data bag.

Create <code class="file-path">~/Development/delivery-cluster/.chef/delivery-cluster-data/ssh_key.json</code> and add this, replacing `YOUR_NAME` and `YOUR_PRIVATE_KEY` with your values.

```ruby
# ~/Development/delivery-cluster/.chef/delivery-cluster-data/ssh_key.json
{
  "id": "ssh_key",
  "name": "YOUR_NAME"
  "private_key": "YOUR_PRIVATE_KEY"
}
```

You'll need to replace each line break with `\n` in your file. For example:

```ruby
# ~/Development/delivery-cluster/.chef/delivery-cluster-data/ssh_key.json
{
  "id": "ssh_key",
  "name": "learn-chef"
  "private_key": "-----BEGIN RSA PRIVATE KEY-----\ngz5jKCX3TO...j8ErLWsr==\n-----END RSA PRIVATE KEY-----"
}
```

Encrypt and upload the data bag item.

```bash
# ~/Development/delivery-cluster
$ knife data bag from file provisioning-data ./.chef/delivery-cluster-data/ssh_key.json --secret-file .chef/delivery-cluster-data/encrypted_data_bag_secret
Updated data_bag_item[provisioning-data::ssh_key]
```

Verify you can decrypt it back.

```bash
# ~/Development/delivery-cluster
$ knife data bag show provisioning-data ssh_key --secret-file .chef/delivery-cluster-data/encrypted_data_bag_secret
Encrypted data bag detected, decrypting with provided secret.
id:          ssh_key
name:        learn-chef
private_key: -----BEGIN RSA PRIVATE KEY-----
gz5jKCX3TO...
...j8ErLWsr==
-----END RSA PRIVATE KEY-----
```

### EC2 only - Encrypt and upload your AWS credentials

Create <code class="file-path">~/Development/delivery-cluster/.chef/delivery-cluster-data/aws_creds.json</code> and add this, replacing `YOUR_ACCESS_KEY_ID` and `YOUR_SECRET_ACCESS_KEY` with your values.

```ruby
# ~/Development/delivery-cluster/.chef/delivery-cluster-data/aws_creds.json
{
  "id": "aws_creds",
  "access_key_id": "YOUR_ACCESS_KEY_ID",
  "secret_access_key": "YOUR_SECRET_ACCESS_KEY"
}
```

For example:

```ruby
# ~/Development/delivery-cluster/.chef/delivery-cluster-data/aws_creds.json
{
  "id": "aws_creds",
  "region": "us-west-2",
  "access_key_id": "AKIAIOSFODNN7EXAMPLE",
  "secret_access_key": "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
}
```

Encrypt and upload the data bag item.

```bash
# ~/Development/delivery-cluster
$ knife data bag from file provisioning-data ./.chef/delivery-cluster-data/aws_creds.json --secret-file .chef/delivery-cluster-data/encrypted_data_bag_secret
Updated data_bag_item[provisioning-data::aws_creds]
```

Verify you can decrypt it back.

```bash
# ~/Development/delivery-cluster
$ knife data bag show provisioning-data aws_creds --secret-file .chef/delivery-cluster-data/encrypted_data_bag_secret
Encrypted data bag detected, decrypting with provided secret.
access_key_id:     AKIAIOSFODNN7EXAMPLE
secret_access_key: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
id:                aws_creds
```

### Encrypt and upload the decryption key for the Customers web application

In this step, you'll encrypt and upload the decryption key for the Customers web application. You can either use the key you generated in [Learn to manage a basic Red Hat Enterprise Linux web application](/manage-a-web-app/rhel/), or the one you generated in the [Encrypt and upload your private key](/build-a-delivery-pipeline/rhel/write-the-build-cookbook#encryptanduploadyourprivatekey) portion of this tutorial.

Create <code class="file-path">~/Development/delivery-cluster/.chef/delivery-cluster-data/database\_passwords\_key.json</code> and add this:

```ruby
# ~/Development/delivery-cluster/.chef/delivery-cluster-data/database_passwords_key.json
{
  "id": "database_passwords_key",
  "content": "YOUR_DECRYPTION_KEY"
}
```

For example:

```ruby
# ~/Development/delivery-cluster/.chef/delivery-cluster-data/database_passwords_key.json
{
  "id": "database_passwords_key",
  "content": "u8eF924qkscvx+edZfynrpMi3JS0fLE1qHoJaN9Yzba0O79H5WQGUjRWaXTqUEaj/TqeEYL4F1j8R4jiwI5hJPmo91hukcWhpgxCrvvw0ajku1e3InKMWWDcOAv8frkHgTwoqLXjkbVJyYJ4A1o9Hc/jHTlweicK39pETi76emkaxVXQCRcq9pi+OxNVYMeRucGqZZrp8kgRChPLYrmzTOpkJ5uaFXq/OVRZSQUA7lAUAcBVwXSvnY5PiisZjsEwF/cOTlLfLjcRGz4820RpM0TyxgqG5o4JsJ/tfKbn8bz2DExaW5rIUhx/EAdaK8xOiihTsP8n67XV7fwAT1wHmeTg4n/aAr57OW3hZk2eAXP2l9hRKy3b8W42jJnUZ92rOKBTIfAz2B7lxBzDphdntrQYtuLO7PmaKjDwZX7U7OoEUNvKjnnp0nTZcyECc3dlF0JSj1w6yobK1uzlyQRoRUcD8TtAOWBazmol3pY9fhLu5ZVhOYoOuKmyDDCYgk8SLSL/rSSHbPKtHo77amqR68IDT9gCK3ZCM7XF97IJBefoK5UYDFwKIYKaX9GYhUoJf0EXZLvHn/GxzEDK8fanFeaIYFU68WBpmONng8IGndYhgBhu6yA3hyrlvQRkZHpf+1pDxjOh1neDv0+A12FusGbehZOKhCfn1I0Q5rQLO7V="
}
```

Encrypt and upload the data bag item.

```bash
# ~/Development/delivery-cluster
$ knife data bag from file provisioning-data ./.chef/delivery-cluster-data/database_passwords_key.json --secret-file .chef/delivery-cluster-data/encrypted_data_bag_secret
Updated data_bag_item[provisioning-data::database_passwords_key]
```

Verify you can decrypt it back.

```bash
# ~/Development/delivery-cluster
$ knife data bag show provisioning-data database_passwords_key --secret-file .chef/delivery-cluster-data/encrypted_data_bag_secret
Encrypted data bag detected, decrypting with provided secret.
content: u8eF924qkscvx+edZfynrpMi3JS0fLE1qHoJaN9Yzba0O79H5WQGUjRWaXTqUEaj/TqeEYL4F1j8R4jiwI5hJPmo91hukcWhpgxCrvvw0ajku1e3InKMWWDcOAv8frkHgTwoqLXjkbVJyYJ4A1o9Hc/jHTlweicK39pETi76emkaxVXQCRcq9pi+OxNVYMeRucGqZZrp8kgRChPLYrmzTOpkJ5uaFXq/OVRZSQUA7lAUAcBVwXSvnY5PiisZjsEwF/cOTlLfLjcRGz4820RpM0TyxgqG5o4JsJ/tfKbn8bz2DExaW5rIUhx/EAdaK8xOiihTsP8n67XV7fwAT1wHmeTg4n/aAr57OW3hZk2eAXP2l9hRKy3b8W42jJnUZ92rOKBTIfAz2B7lxBzDphdntrQYtuLO7PmaKjDwZX7U7OoEUNvKjnnp0nTZcyECc3dlF0JSj1w6yobK1uzlyQRoRUcD8TtAOWBazmol3pY9fhLu5ZVhOYoOuKmyDDCYgk8SLSL/rSSHbPKtHo77amqR68IDT9gCK3ZCM7XF97IJBefoK5UYDFwKIYKaX9GYhUoJf0EXZLvHn/GxzEDK8fanFeaIYFU68WBpmONng8IGndYhgBhu6yA3hyrlvQRkZHpf+1pDxjOh1neDv0+A12FusGbehZOKhCfn1I0Q5rQLO7V=
id:      database_passwords_key
```

### Create a branch

* Move to your <code class="file-path">~/Development/delivery-cluster</code> directory.

```bash
# ~/Development/delivery-cluster
$ cd ~/Development/deliver-customers-rhel/
```

First, verify that you're on the `master` branch.

```bash
# ~/Development/deliver-customers-rhel
$ git branch
  add-delivery-config
  add-delivery-truck
* master
  publish-customers-app
```

Run these commands to create the `provision-environments` branch and verify that you're on that branch.

```bash
# ~/Development/deliver-customers-rhel
$ git checkout -b provision-environments
Switched to a new branch 'provision-environments'
$ git branch
  add-delivery-config
  add-delivery-truck
  master
* provision-environments
  publish-customers-app
```

### Create node attributes that describe your environments

You've already created a file to hold your default attributes.

Append this code to your default node attributes file, <code class="file-path">default.rb</code>.

```ruby
# ~/Development/deliver-customers-rhel/.delivery/build-cookbook/attributes/default.rb
default['deliver-customers-rhel']['run_list'] = ['recipe[awesome_customers::default]']

%w(acceptance union rehearsal delivered).each do |stage|
  default['deliver-customers-rhel'][stage]['driver'] = 'ssh'
end

%w(acceptance union rehearsal delivered).each do |stage|
  default['deliver-customers-rhel'][stage]['aws']['config'] = {
    region: 'us-west-2',
    profile: 'default',
    machine_options: {
      admin: nil,
      bootstrap_options: {
        instance_type: 't2.micro',
        security_group_ids: ['sg-cbacf8ae'],
        subnet_id: 'subnet-19ac017c',
        output_key_path: nil,
        output_key_format: nil
      },
      convergence_options: {
        ssl_verify_mode: :verify_none
      },
      image_id: 'ami-09f7d239',
      ssh_username: 'root',
      transport_address_location: :private_ip,
      validator: nil
    }
  }
end

default['deliver-customers-rhel']['acceptance']['ssh']['config'] = {
  machine_options: {
    transport_options: {
      ip_address: '52.27.142.7',
      username: 'root',
      ssh_options: {
        user: 'root'
      },
      options: {
        prefix: 'sudo '
      }
    }
  }
}

default['deliver-customers-rhel']['union']['ssh']['config'] = {
  machine_options: {
    transport_options: {
      ip_address: '52.89.111.13',
      username: 'root',
      ssh_options: {
        user: 'root'
      },
      options: {
        prefix: 'sudo '
      }
    }
  }
}

default['deliver-customers-rhel']['rehearsal']['ssh']['config'] = {
  machine_options: {
    transport_options: {
      ip_address: '52.88.245.86',
      username: 'root',
      ssh_options: {
        user: 'root'
      },
      options: {
        prefix: 'sudo '
      }
    }
  }
}

default['deliver-customers-rhel']['delivered']['ssh']['config'] = {
  machine_options: {
    transport_options: {
      ip_address: '54.69.73.21',
      username: 'root',
      ssh_options: {
        user: 'root'
      },
      options: {
        prefix: 'sudo '
      }
    }
  }
}
```

This code defines the attributes of both the AWS and SSH drivers. You'll configure the one you're using.

In line 1, `default['deliver-customers-rhel']['run_list']` specifies the run-list that configures the Customers web application. You'll use this attribute later when you provision the stages's infrastructure environments.

Lines 3-5 set the stages to use either the AWS or SSH driver. The example sets up the stages to use SSH. If you're using the AWS driver, ensure this value is set to 'aws' rather than 'ssh'. The code sets each stage to use the same driver, but you can configure it so that different stages use different drivers. For example, here's how you would configure the Acceptance, Union, and Rehearsal stages to use the AWS driver and the Delivered stage to use the SSH driver.

```ruby
# ~/Development/deliver-customers-rhel/.delivery/build-cookbook/attributes/default.rb
%w(acceptance union rehearsal).each do |stage|
  default['deliver-customers-rhel'][stage]['driver'] = 'aws'
end
default['deliver-customers-rhel']['delivered']['driver'] = 'ssh'
```

Lines 7-29 describe the configuration of the AWS driver.

For simplicity, define each stage the same way. But in practice, you might have different configurations for each stage. For example, you might run your Acceptance stage as a t2.micro instance with an open firewall through your security groups. Your Delivered stage might be a larger instance with a more constrained security group setting.

If you're using the AWS driver, replace the following with your values.

* `region`
* `profile`
* `instance_type`
* `security_group_ids`
* `subnet_id`
* `image_id`
* `ssh_username`
* `transport_address_location`

If you're not using the AWS driver, you can ignore this section of the file.

Lines 31-89 describes the configuration of the SSH driver. If you're using the SSH driver, replace the following with your values.

* `ip_address`
* `username`
* `user`

[PRODNOTE] What's the difference between `username` and `user`??.

### Write the recipe for the provision phase

Now that our Chef server has the encrypted data bag items that we need to provision our Acceptance, Union, Rehearsal, and Delivered stages, we can write the recipe for the provision phase.

We need to:

* Decrypt the encryption key that decrypts the data bags containing the database passwords. The Customers application uses these passwords to connect to the database in order to retrieve customer records. We perform this step in this recipe because Chef provisioning enables us to easily pass that file to the machine when it's provisioned.
* Decrypt the SSH key that's used to connect to the machine (for both the AWS and SSH drivers). Chef provisioning uses that key to connect to the machine so it can install and run chef-client.
* Set up the appropriate library for the Chef provisioning driver, which can be either AWS or SSH.
* Bring up the machine and bootstrap it to our Chef server, using the driver-specific options that we specified in the default attributes file.


#### Decrypt the encryption key that contains the database passwords

In [Learn to manage a basic Red Hat Enterprise Linux web application](/manage-a-web-app/rhel), we showed how to use `Chef::EncryptedDataBagItem` to load and decrypt the encrypted database passwords from a data bag. For this project, we'll use the [chef-sugar](https://supermarket.chef.io/cookbooks/chef-sugar) cookbook from Chef Supermarket to make the process easier. The `chef-sugar` cookbook provides the `encrypted_data_bag_item_for_environment` helper method to decrypt data bag items.

To load the `chef-sugar` cookbook, add the line `depends 'chef-sugar'` to your build cookbook's metadata file, <code class="file-path">metadata.rb</code>, making the entire file look like this.

```ruby
# ~/Development/deliver-customers-rhel/.delivery/build-cookbook/metadata.rb
name 'build-cookbook'
maintainer 'The Authors'
maintainer_email 'you@example.com'
license 'all_rights'
version '0.1.0'

depends 'delivery-truck'
depends 'chef-sugar'
```

In your `provision` recipe, include the `chef-sugar` cookbook's default recipe.

```ruby
# ~/Development/deliver-customers-rhel/.delivery/build-cookbook/recipes/provision.rb
include_recipe 'delivery-truck::provision'
include_recipe 'chef-sugar::default'
```

Earlier, you used `with_server_config` to change the behavior of `chef-client` to work with your Chef server rather than with a temporary in-memory version.

We need to follow the same pattern here in order to access the encrypted data bags. But this time we need to call the `Chef_Delivery::ClientHelper.enter_client_mode_as_delivery` helper method. This is because `with_server_config` takes a block, and when that block completes, the previous Chef server configuration (the one for the in-memory version) is restored. Chef provisioning requires the real Chef server context for longer because it can perform additional processing in the background.

[PRODNOTE] Can a reviewer try replacing `Chef_Delivery::ClientHelper.enter_client_mode_as_delivery` with `load_delivery_chef_config` and report back to me? It's a new helper method that's now preferred. Hot off the presses, in fact.

Add this to your `provision` recipe.

```ruby
# ~/Development/deliver-customers-rhel/.delivery/build-cookbook/recipes/provision.rb
include_recipe 'delivery-truck::provision'
include_recipe 'chef-sugar::default'

Chef_Delivery::ClientHelper.enter_client_mode_as_delivery
```

Now append this to your `provision` recipe to decrypt the data bag that holds the database passwords.

```ruby
# ~/Development/deliver-customers-rhel/.delivery/build-cookbook/recipes/provision.rb
# Decrypt the encryption key that decrypts the database passwords and save that file to disk.
database_passwords_key = encrypted_data_bag_item_for_environment('provisioning-data', 'database_passwords_key')
database_passwords_key_path = File.join(node['delivery']['workspace']['cache'], node['delivery']['change']['project'])
directory database_passwords_key_path
file File.join(database_passwords_key_path, 'database_passwords_key') do
  sensitive true
  content database_passwords_key['content']
  owner node['delivery_builder']['build_user']
  group node['delivery_builder']['build_user']
  mode '0664'
end
```

#### Decrypt the SSH key

Append this to your `provision` recipe to decrypt the data bag that holds the SSH private key that you use to connect to your Acceptance, Union, Rehearsal, and Delivered infrastructure environments.

```ruby
# ~/Development/deliver-customers-rhel/.delivery/build-cookbook/recipes/provision.rb
# Decrypt the SSH private key Chef provisioning uses to connect to the machine and save the key to disk.
ssh_key = encrypted_data_bag_item_for_environment('provisioning-data', 'ssh_key')
ssh_private_key_path = File.join(node['delivery']['workspace']['cache'], '.ssh')
directory ssh_private_key_path
file File.join(ssh_private_key_path, "#{ssh_key['name']}.pem")  do
  sensitive true
  content ssh_key['private_key']
  owner node['delivery_builder']['build_user']
  group node['delivery_builder']['build_user']
  mode '0600'
end
```

#### Set up the Chef provisioning driver

In this step, we configure the Chef provisioning driver. We include both AWS- and SSH-specific details in the same recipe.

Before we do so, let's create a few variables that we'll use throughout the recipe:

* the name of the project
* the current Chef Delivery stage
* the name of the Chef provisioning driver for this stage
* the region and profile your AWS credentials are associated with

Append this to your `provision` recipe.

```ruby
# ~/Development/deliver-customers-rhel/.delivery/build-cookbook/recipes/provision.rb
# Read common configuration options from node attributes so that we can later access them more easily.
project = node['delivery']['change']['project'] # for example, 'deliver-customers-rhel'
stage = node['delivery']['change']['stage'] # for example, 'acceptance' or 'union'
driver = node[project][stage]['driver'] # for example, 'aws' or 'ssh'
region = node[project][stage][driver]['config']['region'] # for example, 'us-west-2'
profile = node[project][stage][driver]['config']['profile'] # for example, 'default'
```

* Now let's perform driver-specific initialization. We need to:
  * load the driver library.
  * set the current driver.
  * use the driver-specific method for specifying the SSH private key.
* For AWS, we'll also need to load the AWS credentials from the encrypted data bag.
* For SSH, we'll need to download and install the `chef-provisioning-ssh` Gem package.

Before we do that, let's write a recipe named `_aws_creds` that decrypts the AWS credentials from the data bag and and writes them to file.

Run the following.

```bash
# ~/Development/deliver-customers-rhel
$ chef generate recipe .delivery/build-cookbook _aws_creds
Compiling Cookbooks...
Recipe: code_generator::recipe
  * directory[.delivery/build-cookbook/spec/unit/recipes] action create (up to date)
[...]
  * template[.delivery/build-cookbook/recipes/_aws_creds.rb] action create
    - create new file .delivery/build-cookbook/recipes/_aws_creds.rb
    - update content in file .delivery/build-cookbook/recipes/_aws_creds.rb from none to ea684f
    (diff output suppressed by config)
```

The underscore `_` notation in the file name is a convention that shows that the recipe supports other recipes, and doesn't implement one of the core Chef Delivery phases.

Add this to <code class="file-path">\_aws\_creds.rb</code>.

TODO: Explain it.

```ruby
# ~/Development/deliver-customers-rhel/.delivery/build-cookbook/recipes/_aws_creds.rb
with_server_config do
  # Read common configuration options from node attributes so that we can later access them more easily.
  project = node['delivery']['change']['project'] # for example, 'deliver-customers-rhel'
  stage = node['delivery']['change']['stage'] # for example, 'acceptance' or 'union'
  driver = node[project][stage]['driver'] # for example, 'aws' or 'ssh'
  region = node[project][stage][driver]['config']['region'] # for example, 'us-west-2'
  profile = node[project][stage][driver]['config']['profile'] # for example, 'default'

  # Decrypt the AWS credentials from the data bag.
  aws_creds = encrypted_data_bag_item_for_environment('provisioning-data', 'aws_creds')

  # Create a string to hold the contents of the credentials file.
  aws_config_contents = <<-EOF
  [#{profile}]
  region = #{region}
  aws_access_key_id = #{aws_creds['access_key_id']}
  aws_secret_access_key = #{aws_creds['secret_access_key']}
  EOF

  # Compute the path to the credentials file.
  aws_config_filename = File.join(node['delivery']['workspace']['cache'], node['delivery']['change']['project'], 'aws_config')

  # Ensure parent directory exists.
  directory File.join(node['delivery']['workspace']['cache'], node['delivery']['change']['project'])

  # Write the AWS credentials to disk.
  # Alternatively, you can use the template resource.
  file aws_config_filename do
    sensitive true
    content aws_config_contents
  end

  # Set the AWS_CONFIG_FILE environment variable.
  # Chef provisioning reads this environment variable to access the AWS credentials file.
  ENV['AWS_CONFIG_FILE'] = aws_config_filename
end
```

Add this to <code class="file-path">provision.rb</code>.

TODO: Explain.

```ruby
# ~/Development/deliver-customers-rhel/.delivery/build-cookbook/recipes/provision.rb
# Perform driver-specific initialization, such as loading the appropriate library.
# For learning purposes, we'll do that directly in this recipe.
# In practice, you might abstract this into a helper library.
case driver
when 'aws'
  # Load the AWS driver.
  require "chef/provisioning/aws_driver"
  # Load AWS credentials.
  include_recipe "#{cookbook_name}::_aws_creds"
  # Set the AWS driver as the current one.
  with_driver "aws::#{region}::#{profile}"
  # Use the driver-specific method for specifying the SSH private key.
  with_machine_options(
    bootstrap_options: {
      key_name: ssh_key['name'],
      key_path: ssh_private_key_path,
    }
  )
when 'ssh'
  # chef-provisioning-ssh does not come with the Chef DK, so we need to install it manually.
  # For learning purposes, we'll install it if it's not already installed.
  # In practice, you might pin it to a specific version and upgrade it periodically.
  execute 'install the chef-provisioning-ssh gem' do
    cwd node['delivery_builder']['repo']
    command 'chef gem install chef-provisioning-ssh'
    not_if "chef gem list chef-provisioning-ssh | grep 'chef-provisioning-ssh'"
    user node['delivery_builder']['build_user']
  end
  # Load the SSH driver.
  require "chef/provisioning/ssh_driver"
  # Set the SSH driver as the current one.
  with_driver 'ssh'
  # Use the driver-specific method for specifying the SSH private key.
  with_machine_options(
    transport_options: {
      ssh_options: {
        keys: [File.join(ssh_private_key_path, "#{ssh_key['name']}.pem")]
      }
    }
  )
end
```

#### Bring up the machine

To bring up the machine, you'll use the [machine](https://docs.chef.io/resource_machine.html) resource.

To bootstrap the machine to your Chef server, you first call the `with_chef_server` method. This method sets information about your Chef server configuration that Chef provisioning uses to bootstrap the machine.

Append this to your `provision` recipe.

```ruby
# ~/Development/deliver-customers-rhel/.delivery/build-cookbook/recipes/provision.rb
# Specify information about our Chef server.
# Chef provisioning uses this information to bootstrap the machine.
with_chef_server Chef::Config[:chef_server_url],
  client_name: Chef::Config[:node_name],
  signing_key_filename: Chef::Config[:client_key],
  ssl_verify_mode: :verify_none,
  verify_api_cert: false

# Ensure that the machine is bootstrapped, has the correct run-list, and is ready to run chef-client.
# If you're using the AWS driver, this will create the instance if the instance does not exist.
machine_name = "#{stage}-#{project}-#{driver}"
machine machine_name do
  action [:setup]
  chef_environment delivery_environment
  converge false
  files '/etc/chef/encrypted_data_bag_secret' => File.join(database_passwords_key_path, 'database_passwords_key')
  run_list node[project]['run_list']
  add_machine_options node[project][stage][driver]['config']['machine_options']
end
```

The [:setup](https://docs.chef.io/resource_machine.html#actions) action gets the machine ready to use with Chef by bootstrapping it to your Chef server and installing `chef-client`. It does not apply the run-list.

The machine name can be anything you like. A common convention is to concatenate the current stage name and the project name. In this tutorial, were concatenate the current stage name, the project name, and the driver.

For the Acceptance stage, the name will be either 'acceptance-deliver-customers-rhel-aws' or 'acceptance-deliver-customers-rhel-ssh', depending on which driver you're using.

One benefit to including the driver name is that you can switch between the AWS and the SSH driver as you experiment. For example, you can start with the AWS driver to create a machine named 'acceptance-deliver-customers-rhel-aws'. If you later switch the SSH driver by setting the `node['deliver-customers-rhel'][stage]['driver']` node attribute to 'ssh', Chef provisioning will switch over to the machine named 'acceptance-deliver-customers-rhel-ssh'.

[COMMENT] It's common practice to write your `machine` and other Chef provisioning resources so that they can be used by multiple drivers. For example, here we use node attributes and the `add_machine_options` method to separate driver-specific data from the `machine` resource that defines each environment.<br><br>As your project grows in complexity, you can write helper libraries that abstract driver-specific features even further. A good example is from the `delivery-cluster` cookbook. This cookbook defines the [DeliveryCluster::Provisioning::Base](https://github.com/chef-cookbooks/delivery-cluster/blob/master/libraries/_base.rb) class to abstract away common driver-specific details, such as how to access a machine's IP address. The [DeliveryCluster::Provisioning::Aws](https://github.com/chef-cookbooks/delivery-cluster/blob/master/libraries/aws.rb) and [DeliveryCluster::Provisioning::Ssh](https://github.com/chef-cookbooks/delivery-cluster/blob/master/libraries/ssh.rb) classes fill in the details for the `Base` class. When the cookbook runs, for example to set up [Chef server](https://github.com/chef-cookbooks/delivery-cluster/blob/38123d94ae786caf7222966fcfc1b4747a55ae32/recipes/setup_chef_server.rb) or [Chef Delivery](https://github.com/chef-cookbooks/delivery-cluster/blob/38123d94ae786caf7222966fcfc1b4747a55ae32/recipes/setup_delivery_server.rb), it loads the appropriate helper class that provides the specific details required to set up the server using either the AWS or the SSH provisioning driver.

The complete `provision` recipe looks like this.

```ruby
# ~/Development/deliver-customers-rhel/.delivery/build-cookbook/recipes/provision.rb
include_recipe 'delivery-truck::provision'
include_recipe 'chef-sugar::default'

Chef_Delivery::ClientHelper.enter_client_mode_as_delivery

# Decrypt the encryption key that decrypts the database passwords and save that file to disk.
database_passwords_key = encrypted_data_bag_item_for_environment('provisioning-data', 'database_passwords_key')
database_passwords_key_path = File.join(node['delivery']['workspace']['cache'], node['delivery']['change']['project'])
directory database_passwords_key_path
file File.join(database_passwords_key_path, 'database_passwords_key') do
  sensitive true
  content database_passwords_key['content']
  owner node['delivery_builder']['build_user']
  group node['delivery_builder']['build_user']
  mode '0664'
end

# Decrypt the SSH private key Chef provisioning uses to connect to the machine and save the key to disk.
ssh_key = encrypted_data_bag_item_for_environment('provisioning-data', 'ssh_key')
ssh_private_key_path = File.join(node['delivery']['workspace']['cache'], '.ssh')
directory ssh_private_key_path
file File.join(ssh_private_key_path, "#{ssh_key['name']}.pem")  do
  sensitive true
  content ssh_key['private_key']
  owner node['delivery_builder']['build_user']
  group node['delivery_builder']['build_user']
  mode '0600'
end

# Read common configuration options from node attributes so that we can later access them more easily.
project = node['delivery']['change']['project'] # for example, 'deliver-customers-rhel'
stage = node['delivery']['change']['stage'] # for example, 'acceptance' or 'union'
driver = node[project][stage]['driver'] # for example, 'aws' or 'ssh'

# Perform driver-specific initialization, such as loading the appropriate library.
# For learning purposes, we'll do that directly in this recipe.
# In practice, you might abstract this into a helper library.
case driver
when 'aws'
  # Load the AWS driver.
  require "chef/provisioning/aws_driver"
  # Load AWS credentials.
  include_recipe "#{cookbook_name}::_aws_creds"
  # Set the AWS driver as the current one.
  with_driver "aws::#{region}::#{profile}"
  # Use the driver-specific method for specifying the SSH private key.
  with_machine_options(
    bootstrap_options: {
      key_name: ssh_key['name'],
      key_path: ssh_private_key_path,
    }
  )
when 'ssh'
  # chef-provisioning-ssh does not come with the Chef DK, so we need to install it manually.
  # For learning purposes, we'll install it if it's not already installed.
  # In practice, you might pin it to a specific version and upgrade it periodically.
  execute 'install the chef-provisioning-ssh gem' do
    cwd node['delivery_builder']['repo']
    command 'chef gem install chef-provisioning-ssh'
    not_if "chef gem list chef-provisioning-ssh | grep 'chef-provisioning-ssh'"
    user node['delivery_builder']['build_user']
  end
  # Load the SSH driver.
  require "chef/provisioning/ssh_driver"
  # Set the SSH driver as the current one.
  with_driver 'ssh'
  # Use the driver-specific method for specifying the SSH private key.
  with_machine_options(
    transport_options: {
      ssh_options: {
        keys: [File.join(ssh_private_key_path, "#{ssh_key['name']}.pem")]
      }
    }
  )
end

# Specify information about our Chef server.
# Chef provisioning uses this information to bootstrap the machine.
with_chef_server Chef::Config[:chef_server_url],
  client_name: Chef::Config[:node_name],
  signing_key_filename: Chef::Config[:client_key],
  ssl_verify_mode: :verify_none,
  verify_api_cert: false

# Ensure that the machine is bootstrapped, has the correct run-list, and is ready to run chef-client.
# If you're using the AWS driver, this will create the instance if the instance does not exist.
machine_name = "#{stage}-#{project}-#{driver}"
machine machine_name do
  action [:setup]
  chef_environment delivery_environment
  converge false
  files '/etc/chef/encrypted_data_bag_secret' => File.join(database_passwords_key_path, 'database_passwords_key')
  run_list node[project]['run_list']
  add_machine_options node[project][stage][driver]['config']['machine_options']
end
```

### Apply the provision phase

Follow the same process you used earlier to commit your changes and submit them to the Chef Delivery pipeline. The steps are shown here.

```bash
# ~/Development/deliver-customers-rhel
$ git status
On branch provision-environments
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   .delivery/build-cookbook/attributes/default.rb
	modified:   .delivery/build-cookbook/metadata.rb
	modified:   .delivery/build-cookbook/recipes/provision.rb

no changes added to commit (use "git add" and/or "git commit -a")
$ git add .
$ git commit -m "provision the environments"
[provision-environments ff7aea3] provision the environments
 3 files changed, 186 insertions(+)
$ delivery review
Chef Delivery
Loading configuration from /home/thomaspetchel/Development/deliver-customers-rhel
Review for change provision-environments targeted for pipeline master
Created new patchset
https://10.194.11.99/e/test/#/organizations/learn-chef/projects/deliver-customers-rhel/changes/78c5739c-5365-4f92-8b07-c70e7097a59b
```

#### Review and approve the change

Trace the change's progress through the pipeline to the Acceptance stage, as you did previously.

1. Review the changes in the web interface. Click **Approve** when all tests pass.
1. Watch the change progress through the Build and Acceptance stages.

After Acceptance succeeds, don't press the **Deliver** button. We'll queue up additional changes and deliver them as a single unit.

#### Verify the creation of the Acceptance stage

Now let's verify that the infrastructure environment for the Acceptance stage was successfully created. We'll run the `awesome_customers` cookbook in that infrastructure environment when we write the recipe for the deploy phase in the next step.

One way to verify the Acceptance stage is to move to your <code class="file-path">~/Development/delivery-cluster/.chef</code> and run the `knife node list` command, similar to how you confirmed that the `awesome_customers` cookbook was successfully published to the Chef server. Remember, this directory holds your `knife` configuration file and enables you to administer your Chef server from your workstation or provisioning node.

First, move to the <code class="file-path">~/Development/delivery-cluster/.chef</code> directory.

```bash
# ~/Development/deliver-customers-rhel
$ cd ~/Development/delivery-cluster/.chef
```

The machine name is the same as the node name. Recall that for the Acceptance stage, the name will be either 'acceptance-deliver-customers-rhel-aws' or 'acceptance-deliver-customers-rhel-ssh', depending on which driver you're using.

Now run `knife node list` and search for your Acceptance stage.

```bash
# ~/Development/delivery-cluster/.chef
$ knife node list | grep acceptance-deliver-customers-rhel-
acceptance-deliver-customers-rhel-aws
```

As expected, the infrastructure environment for the Acceptance stage appears in the node list.

Now move back to your <code class="file-path">~/Development/deliver-customers-rhel</code> directory.

```bash
# ~/Development/delivery-cluster/.chef
$ cd ~/Development/deliver-customers-rhel
```

#### Merge the change locally

* Let's commit our work back to our local `master` branch.
* As we did previously, we need to merge the `master` branch locally. Here's a reminder how.

```bash
# ~/Development/deliver-customers-rhel
$ git checkout master
Switched to branch 'master'
Your branch is up-to-date with 'delivery/master'.
$ git fetch
remote: Counting objects: 21, done.
remote: Compressing objects: 100% (19/19), done.
remote: Total 21 (delta 7), reused 3 (delta 2)
Unpacking objects: 100% (21/21), done.
From ssh://test@10.194.11.99:8989/test/learn-chef/deliver-customers-rhel
   a100d45..dfc7a5d  master     -> delivery/master
$ git pull delivery master
From ssh://test@10.194.11.99:8989/test/learn-chef/deliver-customers-rhel
 * branch            master     -> FETCH_HEAD
Updating a100d45..dfc7a5d
Fast-forward
 .delivery/build-cookbook/attributes/default.rb     | 90 ++++++++++++++++++++
 .delivery/build-cookbook/metadata.rb               |  1 +
 .delivery/build-cookbook/recipes/_aws_creds.rb     | 38 +++++++++
 .delivery/build-cookbook/recipes/provision.rb      | 96 ++++++++++++++++++++++
 .delivery/build-cookbook/recipes/publish.rb        | 14 ++++
 .delivery/build-cookbook/spec/spec_helper.rb       |  2 +
 .../spec/unit/recipes/_aws_creds.rb_spec.rb        | 20 +++++
 .../spec/unit/recipes/_aws_creds_spec.rb           | 20 +++++
 8 files changed, 281 insertions(+)
 create mode 100644 .delivery/build-cookbook/recipes/_aws_creds.rb
 create mode 100644 .delivery/build-cookbook/spec/spec_helper.rb
 create mode 100644 .delivery/build-cookbook/spec/unit/recipes/_aws_creds.rb_spec.rb
 create mode 100644 .delivery/build-cookbook/spec/unit/recipes/_aws_creds_spec.rb
```

[GITHUB] The final code for this section is available on [GitHub](https://github.com/learn-chef/deliver-customers-rhel/tree/provision-environments-v1.0.0) (tag `provision-environments-v1.0.0`.)

## 4. Deploy to the Acceptance stage

Now that we know that the Acceptance stage is provisioned, we can deploy to it. In this step, we write the recipe for the deploy phase.

### Create a branch

First, verify that you're on the `master` branch.

```bash
# ~/Development/deliver-customers-rhel
$ git branch
  add-delivery-config
  add-delivery-truck
* master
  provision-environments
  publish-customers-app
```

Run these commands to create the `publish-customers-app` branch and verify that you're on that branch.

```bash
# ~/Development/deliver-customers-rhel
$ git checkout -b deploy-customers-app
Switched to a new branch 'deploy-customers-app'
$ git branch
  add-delivery-config
  add-delivery-truck
* deploy-customers-app
  master
  provision-environments
  publish-customers-app
```

### Write the recipe

In the provision phase, we set the `chef_environment` attribute to associate the machine with an [environment](https://docs.chef.io/environments.html).

```ruby
# ~/Development/deliver-customers-rhel/.delivery/build-cookbook/recipes/provision.rb
# [...]
machine machine_name do
  action [:setup]
  chef_environment delivery_environment
  converge false
  files '/etc/chef/encrypted_data_bag_secret' => File.join(database_passwords_key_path, 'database_passwords_key')
  run_list node[project]['run_list']
  add_machine_options node[project][stage][driver]['config']['machine_options']
end
```

The provision and deploy phases run the Acceptance, Union, Rehearsal, and Delivered stages. When the recipe runs in each stage, the machine is tagged for the current Chef environment.

In the deploy phase, we can use [search](https://docs.chef.io/chef_search.html) to find the names of every node in the current Chef environment (see lines 75 through 82, below.) This technique is useful when you associate multiple infrastructure nodes with a stage, such as in a multi-tier application.

Write out your `deploy` recipe like this.

```ruby
# ~/Development/deliver-customers-rhel/.delivery/build-cookbook/recipes/deploy.rb
include_recipe 'delivery-truck::deploy'
include_recipe 'chef-sugar::default'

Chef_Delivery::ClientHelper.enter_client_mode_as_delivery

# Decrypt the SSH private key Chef provisioning uses to connect to the machine and save the key to disk.
ssh_key = encrypted_data_bag_item_for_environment('provisioning-data', 'ssh_key')
ssh_private_key_path = File.join(node['delivery']['workspace']['cache'], '.ssh')
directory ssh_private_key_path
file File.join(ssh_private_key_path, "#{ssh_key['name']}.pem")  do
  sensitive true
  content ssh_key['private_key']
  owner node['delivery_builder']['build_user']
  group node['delivery_builder']['build_user']
  mode '0600'
end

# Read common configuration options from node attributes so that we can later access them more easily.
project = node['delivery']['change']['project'] # for example, 'deliver-customers-rhel'
stage = node['delivery']['change']['stage'] # for example, 'acceptance' or 'union'
driver = node[project][stage]['driver'] # for example, 'aws' or 'ssh'
region = node[project][stage][driver]['config']['region'] # for example, 'us-west-2'
profile = node[project][stage][driver]['config']['profile'] # for example, 'default'

# Perform driver-specific initialization, such as loading the appropriate library.
# For learning purposes, we'll do that directly in this recipe.
# In practice, you might abstract this into a helper library.
case driver
when 'aws'
  # Load the AWS driver.
  require "chef/provisioning/aws_driver"
  # Load AWS credentials.
  include_recipe "#{cookbook_name}::_aws_creds"
  # Set the AWS driver as the current one.
  with_driver "aws::#{region}::#{profile}"
  # Use the driver-specific method for specifying the SSH private key.
  with_machine_options(
    bootstrap_options: {
      key_name: ssh_key['name'],
      key_path: ssh_private_key_path,
    }
  )
when 'ssh'
  # chef-provisioning-ssh does not come with the Chef DK, so we need to install it manually.
  # For learning purposes, we'll install it if it's not already installed.
  # In practice, you might pin it to a specific version and upgrade it periodically.
  execute 'install the chef-provisioning-ssh gem' do
    cwd node['delivery_builder']['repo']
    command 'chef gem install chef-provisioning-ssh'
    not_if "chef gem list chef-provisioning-ssh | grep 'chef-provisioning-ssh'"
    user node['delivery_builder']['build_user']
  end
  # Load the SSH driver.
  require "chef/provisioning/ssh_driver"
  # Set the SSH driver as the current one.
  with_driver 'ssh'
  # Use the driver-specific method for specifying the SSH private key.
  with_machine_options(
    transport_options: {
      ssh_options: {
        keys: [File.join(ssh_private_key_path, "#{ssh_key['name']}.pem")]
      }
    }
  )
end

# Specify information about our Chef server.
# Chef provisioning uses this information to bootstrap the machine.
with_chef_server Chef::Config[:chef_server_url],
  client_name: Chef::Config[:node_name],
  signing_key_filename: Chef::Config[:client_key],
  ssl_verify_mode: :verify_none,
  verify_api_cert: false

# Create a search query that matches the current environment.
search_query = "chef_environment:#{delivery_environment}"

# Run the query.
nodes = delivery_chef_server_search(:node, search_query)

# Replace each result with just the node's name.
nodes.map!(&:name)

# Run chef-client on each machine in the current environment.
nodes.each do |name|
  machine name do
    action [:converge_only]
    chef_environment delivery_environment
    converge true
    run_list node[project]['run_list']
    add_machine_options node[project][stage][driver]['config']['machine_options']
  end
end
```

The `machine` resource resembles the one you used in your provision phase, except that it uses the `:converge_only` action to run `chef-client` on the node. The node pulls the latest cookbooks from its run-list from Chef server and apply them.

You'll notice that this recipe repeats many of the steps that the `provision` recipe performs. One reason for this is to accommodate multiple build nodes.

As an example, assume you have two build nodes and each build node runs a different phase. The first build node runs the provision phase and the second build node runs the deploy phase. The second build node requires the SSH private key to connect to the node and run `chef-client`. To get the key, it loads it from the encrypted data bag and writes the key file to disk. These are the same steps that occur during provisioning.

In practice, you can write helper recipes and use node attributes to share data between the helper and the main recipe, or you can write a [library](https://docs.chef.io/libraries.html) that abstracts common functionality.

### Review and approve the change

Let's try out our recipe. Follow the same steps as before to submit your change and trigger the pipeline.

```bash
~/Development/deliver-customers-rhel
$ git status
On branch deploy-customers-app
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   .delivery/build-cookbook/recipes/deploy.rb

no changes added to commit (use "git add" and/or "git commit -a")
$ git add .
$ git commit -m "deploy to the environments"
[deploy-customers-app d85bd04] deploy to the environments
 1 file changed, 92 insertions(+)
$ delivery review
Chef Delivery
Loading configuration from /home/thomaspetchel/Development/deliver-customers-rhel
Review for change deploy-customers-app targeted for pipeline master
```

Trace the change's progress through the pipeline to the Acceptance stage, as you did previously.

1. Review the changes in the web interface. Click **Approve** when all tests pass.
1. Watch the change progress through the Build and Acceptance stages.

After Acceptance succeeds, don't press the **Deliver** button. We'll queue up additional changes and deliver them as a single unit.

### Verify the deployment to the Acceptance stage

Let's verify that the `awesome_customers` cookbook successfully deployed to your Acceptance stage. To do that, you'll need the IP address of your server.

If you're using the SSH driver, you already have it. If you're using the AWS driver, you can get its IP address from its node attributes.

If you're using the AWS driver, move to the <code class="file-path">~/Development/delivery-cluster/.chef</code> directory.

```bash
# ~/Development/deliver-customers-rhel
$ cd ~/Development/delivery-cluster/.chef
```

Now run `knife node show`, providing the name of the node for your Acceptance stage, and then search for the node's IP address.

```bash
# ~/Development/delivery-cluster/.chef
$ knife node show acceptance-deliver-customers-rhel-aws | grep IP:
IP:          10.194.12.61
```

Now move back to your <code class="file-path">~/Development/deliver-customers-rhel</code> directory.

```bash
# ~/Development/delivery-cluster/.chef
$ cd ~/Development/deliver-customers-rhel
```

From a web browser, navigate to your node's IP address.

![](delivery/acceptance-customers-verify.png)

Congratulations! You've successfully deployed the Customers web application to Acceptance!

### Integrate the change locally

As we did previously, let's merge the `master` branch locally. Here's a reminder how.

```bash
# ~/Development/deliver-customers-rhel
$ git checkout master
Switched to branch 'master'
Your branch is up-to-date with 'delivery/master'.
$ git fetch
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
From ssh://test@10.194.11.99:8989/test/learn-chef/deliver-customers-rhel
   dfc7a5d..ee4ff54  master     -> delivery/master
$ git pull delivery master
From ssh://test@10.194.11.99:8989/test/learn-chef/deliver-customers-rhel
 * branch            master     -> FETCH_HEAD
Updating dfc7a5d..ee4ff54
Fast-forward
 .delivery/build-cookbook/recipes/_aws_creds.rb |  3 +
 .delivery/build-cookbook/recipes/deploy.rb     | 92 ++++++++++++++++++++++++++
 2 files changed, 95 insertions(+)
```

[GITHUB] The final code for this section is available on [GitHub](https://github.com/learn-chef/deliver-customers-rhel/tree/deploy-customers-app-v1.0.0) (tag `deploy-customers-app-v1.0.0`.)

## 5. Run smoke tests and deploy to your Union, Rehearsal, and Delivered stages

In the previous step, you manually verified that the Customers application is running in Acceptance. In practice, it's common to have some manual verification process to validate that your application or service is up and functioning. For example, if you're deploying a web application, someone will typically test out a new feature manually on a pre-production server before releasing the feature to production.

However, you can also write _smoke tests_ to help quickly validate that the application or service is running and functional. If the smoke tests fail, you know that the application or service has failed.

### Create a branch

First, verify that you're on the `master` branch.

```bash
# ~/Development/deliver-customers-rhel
$ git branch
  add-delivery-config
  add-delivery-truck
  deploy-customers-app
* master
  provision-environments
  publish-customers-app
```

Run these commands to create the `smoke-test-customers-app` branch and verify that you're on that branch.

```bash
# ~/Development/deliver-customers-rhel
$ git checkout -b smoke-test-customers-app
Switched to a new branch 'smoke-test-customers-app'
$ git branch
  add-delivery-config
  add-delivery-truck
  deploy-customers-app
  master
  provision-environments
  publish-customers-app
* smoke-test-customers-app
```

### Write the smoke recipe

Smoke tests are meant to be fast so that you quickly receive feedback if the application or service is not working. For the Customers web application, we'll simply run cURL to verify that the home page comes up and that the server responds with 200 (OK) HTTP status code.

Write your `smoke` recipe like this.

```ruby
# ~/Development/deliver-customers-rhel/.delivery/build-cookbook/recipes/smoke.rb
include_recipe 'delivery-truck::smoke'

# Create a search query that matches the current environment.
search_query = "chef_environment:#{delivery_environment}"

# Run the query.
nodes = delivery_chef_server_search(:node, search_query)

# cURL the IP address of each result and verify a 200 (OK) response.
nodes.each do |node|
  address = node['ipaddress']
  execute "cURL #{address} and verify 200 response" do
    command "curl -IL #{address} | grep '^HTTP/1\.1 200 OK'"
  end
end
```

This code performs a similar query as the deploy phase. For each node in the environment (we expect only one), we use the `execute` resource to run `curl` with the `-IL` flag and search for the expected response code.

### Review and approve the change

Let's try out our smoke test. Follow the same steps as before to submit your change and trigger the pipeline.

```bash
~/Development/deliver-customers-rhel
$ git status
On branch smoke-test-customers-app
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   .delivery/build-cookbook/recipes/smoke.rb

no changes added to commit (use "git add" and/or "git commit -a")
$ git add .
$ git commit -m "smoke test environments"
[smoke-test-customers-app 1b7b529] smoke test environments
 1 file changed, 14 insertions(+)
$ delivery review
Chef Delivery
Loading configuration from /home/thomaspetchel/Development/deliver-customers-rhel
Review for change smoke-test-customers-app targeted for pipeline master
Created new patchset
https://10.194.11.99/e/test/#/organizations/learn-chef/projects/deliver-customers-rhel/changes/639d2844-c94a-4015-b4cb-bc000b1c9172
```

Trace the change's progress through the pipeline to the Acceptance stage.

1. Review the changes in the web interface. Click **Approve** when all tests pass.
1. Watch the change progress through the Build and Acceptance stages.

You'll see that the smoke test passes.

![](delivery/acceptance-smoke-test.png)

Previously, you verified your change up to the Acceptance stage. This time, after Acceptance succeeds, press the **Deliver** button, then press **Confirm**.

![](delivery/deliver-customers.png)

This moves the change through the Union, Rehearsal, and Delivered stages.

![](delivery/customers-delivered.png)

### Verify the change was successfully delivered

* Let's verify that the `awesome_customers` cookbook successfully deployed to your Delivered stage.

* As before, you'll need the IP address of your server.
* If you're using the SSH driver, you already have it.
* If you're using the AWS driver, you can get its IP address from its node attributes.

If you're using the AWS driver, move to the <code class="file-path">~/Development/delivery-cluster/.chef</code> directory.

```bash
# ~/Development/deliver-customers-rhel
$ cd ~/Development/delivery-cluster/.chef
```

Now run `knife node show`, providing the name of the node for your Delivered stage, and then search for the node's IP address.

```bash
# ~/Development/delivery-cluster/.chef
$ knife node show delivered-deliver-customers-rhel-aws | grep IP:
IP:          10.194.15.90
```

Now move back to your <code class="file-path">~/Development/deliver-customers-rhel</code> directory.

```bash
# ~/Development/delivery-cluster/.chef
$ cd ~/Development/deliver-customers-rhel
```

From a web browser, navigate to your node's IP address.

![](delivery/delivered-customers-verify.png)

Congratulations! You've successfully delivered the Customers web application!

### Integrate the change locally

As we did previously, let's merge the `master` branch locally. Here's a reminder how.

```bash
# ~/Development/deliver-customers-rhel
$ git checkout master
Switched to branch 'master'
Your branch is up-to-date with 'delivery/master'.
$ git fetch
remote: Counting objects: 1, done.
remote: Total 1 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (1/1), done.
From ssh://test@10.194.11.99:8989/test/learn-chef/deliver-customers-rhel
   ee4ff54..e46f7b2  master     -> delivery/master
$ git pull delivery master
From ssh://test@10.194.11.99:8989/test/learn-chef/deliver-customers-rhel
 * branch            master     -> FETCH_HEAD
Updating ee4ff54..e46f7b2
Fast-forward
 .delivery/build-cookbook/recipes/smoke.rb | 14 ++++++++++++++
 1 file changed, 14 insertions(+)
```

[GITHUB] The final code for this section is available on [GitHub](https://github.com/learn-chef/deliver-customers-rhel/tree/smoke-test-customers-app-v1.0.0) (tag `smoke-test-customers-app-v1.0.0`.)

## Skipped phases

There are many other types of tests you can run that we haven't discussed here. For example, the Build stage has a quality phase. You can use this phase to run additional test suites and code analysis tools that are too time consuming to run in the Verify stage. You don't want to run these tests until you know the code is approved.

In many organizations, a suite of security tests must be run before a change can be deployed. The Build phase is a good place to run these tests, as well.

Functional tests can run in the Acceptance, Union, Rehearsal and Delivered stages. These tests should give you confidence that the system is meeting its business requirements.
