---
title: 'Verify your resources are properly defined'
order: 3
keywords: TODO
layout: lesson
sections: []
next: {heading: Next, partial: next}
time_to_complete: 60 minutes
meta_tags: [{name: "ROBOTS", content: "NOINDEX, NOFOLLOW"}]
---
> ChefSpec simulates the execution of your resources, giving you an even faster feedback loop as you create and refine your recipes.

In the previous lesson, you wrote InSpec tests that automatically verify that your basic web server cookbook configures Apache as you expect. Although automated testing is faster than manual testing, it can still take some time for the instance to come up, run `chef-client`, and run the tests.

You'll want to verify your work on a virtual instance before you run your cookbook in production, but as you develop your cookbook, you can use [ChefSpec](https://docs.chef.io/chefspec.html) to speed up the feedback cycle even more. ChefSpec _simulates_ the execution of your resources in memory, and does not involve the creation of a virtual instance. It's the fastest way to test your resources and is a great way to validate the correctness of your work, even before you set up a virtual instance to test on.

ChefSpec testing is also helpful when you use [continuous delivery](https://en.wikipedia.org/wiki/Continuous_delivery) (CD) systems such as [Chef Delivery](/delivery/get-started/) because ChefSpec enables you to verify your code without the need to bring up additional test systems.

ChefSpec provides a kind of _unit_ testing, where you verify that a single component, such as a Chef resource, functions correctly. Unlike integration testing, unit testing does not focus on how multiple components work together.

ChefSpec testing is most useful when a component's behavior varies based on the environment or other variable input. For example, say you define this `package` resource to install the `vim` text editor.

```ruby
# default.rb
package 'vim' do
  action :install
end
```

You don't need to write a unit test here because this `package` resource can do only one thing &ndash; install the `vim` package if it's not already installed. However, say your `package` resource reads from a node attribute to determine which text editor to install.

```ruby
# default.rb
package node['text_editor'] do
  action :install
end
```

In this case, you might want to validate that when the `node['text_editor']` attribute is set, that the appropriate text editor would be installed.

In this lesson, you'll modify the `webserver_test` cookbook to work on both CentOS and Ubuntu. The way Apache is installed and managed differs slightly on both platforms.

Recall that your `webserver_test` cookbook's default recipe looks like this.

```ruby
# ~/learn-chef/cookbooks/webserver_test/recipes/default.rb
# Install the Apache package.
package 'httpd'

# Start and enable the httpd service.
service 'httpd' do
  action [:enable, :start]
end

# Serve a custom home page.
file '/var/www/html/index.html' do
  content '<html>
  <body>
    <h1>hello world</h1>
  </body>
</html>'
end
```

You know that this configuration works on CentOS, but on Ubuntu, both the package and service name is `apache2`, not `httpd`.

For this part, let's revise the requirements for the web server configuration to focus on these two criteria:

<% unstyled_list do %>
  <% icon_list_item('square-o') do %> 
    On CentOS, install the <code>httpd</code> package and enable and start the <code>httpd</code> service.
  <% end %>
  <% icon_list_item('square-o') do %>
    On Ubuntu, install the <code>apache2</code> package and enable and start the <code>apache2</code> service.
  <% end %>
<% end %>

You need to write code to ensure that your cookbook performs the correct steps in both environments. Here you'll write ChefSpec tests that verify that the code is defined correctly for both platforms &ndash; without the need to run it on a local instance.

You'll start by writing ChefSpec tests that verify your existing CentOS web server configuration. Then you'll add additional tests for the same configuration on Ubuntu. After seeing the tests fail, you'll go back to your recipe and add just enough code to make the tests pass.

Here's what you'll do:

1. [Write ChefSpec tests that verify the current web server configuration](#step1)
1. [Define the CentOS context](#step2)
1. [Write ChefSpec tests for the Ubuntu web server configuration](#step3)
1. [Revise the webserver_test cookbook to support Ubuntu](#step4)
1. [Refactor the tests to reduce repeated code](#step5)

Here's a 60-minute webcast that goes in greater depth on ChefSpec and shows working examples. You can watch the video before or after you complete this tutorial.

<% accordion('tdd-webcast', 'Watch the webcast') do %>

<script type="text/javascript" src="https://www.brighttalk.com/clients/js/embed/embed.js"></script> <object class="BrightTALKEmbed" width="705" height="660">     <param name="player" value="channel_player"/>     <param name="domain" value="https://www.brighttalk.com"/>     <param name="channelid" value="11349"/>     <param name="communicationid" value="194483"/>     <param name="autoStart" value="false"/>     <param name="theme" value=""/> </object>

<% end %>
<br>

[START_BOX]

## 1. Write ChefSpec tests that verify the current web server configuration

Let's begin by writing ChefSpec tests that verify the CentOS web server configuration.

For ChefSpec, tests go in your cookbook's `spec` directory. The `chef generate cookbook` command creates this directory for you. 

```bash
# ~/learn-chef
$ tree cookbooks/webserver_test/spec
spec
├── spec_helper.rb
└── unit
    └── recipes
        └── default_spec.rb

2 directories, 2 files
```

You typically define one test, or spec, file for each recipe. So <code class="file-path">default\_spec.rb</code> maps to the default recipe, <code class="file-path">default.rb</code>. If you had a second recipe, say <code class="file-path">firewall.rb</code>, then you would have a spec named <code class="file-path">firewall\_spec.rb</code>.

The default spec that's generated looks like this.

```ruby
# ~/learn-chef/cookbooks/webserver_test/spec/unit/recipes/default_spec.rb
require 'spec_helper'

describe 'webserver_test::default' do
  context 'When all attributes are default, on an unspecified platform' do
    let(:chef_run) do
      runner = ChefSpec::ServerRunner.new
      runner.converge(described_recipe)
    end

    it 'converges successfully' do
      expect { chef_run }.to_not raise_error
    end
  end
end
```

The `describe` blocks tells ChefSpec to run the `webserver_test::default` recipe in memory. The `let` block simulates the `chef-client` run. It also defines the `chef_run` variable, which is used in each test to validate the result.

`ChefSpec::ServerRunner` specifies how to run `chef-client` in memory. It's a common option because it also simulates an in-memory Chef server, allowing you to access [data bags](https://docs.chef.io/data_bags.html) and other features.

ChefSpec code resembles InSpec because both are based on the [RSpec](http://rspec.info) testing framework. RSpec [provides two ways to express tests](http://rspec.info/blog/2012/06/rspecs-new-expectation-syntax/). In the previous lesson, you used what's commonly called RSpec's _should_ syntax. In this part, you'll use RSpec's _expectation_ syntax. 

Modify your copy of <% fp 'default_spec.rb' %> like this.

```ruby
# ~/learn-chef/cookbooks/webserver_test/spec/unit/recipes/default_spec.rb
require 'spec_helper'

describe 'webserver_test::default' do
  let(:chef_run) do
    runner = ChefSpec::ServerRunner.new
    runner.converge(described_recipe)
  end

  it 'converges successfully' do
    expect { chef_run }.to_not raise_error
  end

  it 'installs httpd' do
    expect(chef_run).to install_package 'httpd'
  end

  it 'enables the httpd service' do
    expect(chef_run).to enable_service 'httpd'
  end

  it 'starts the httpd service' do
    expect(chef_run).to start_service 'httpd'
  end
end
```

Like InSpec, ChefSpec tests resemble natural language. For example, this test expects the Chef run to install the `httpd` package.

```ruby
# ~/learn-chef/cookbooks/webserver_test/spec/unit/recipes/default_spec.rb
it 'installs httpd' do
  expect(chef_run).to install_package 'httpd'
end
```

The `install_package` part is known as a _matcher_. The [ChefSpec documentation](http://www.rubydoc.info/github/sethvargo/chefspec) lists the matchers that are available in your tests. For example, [ServiceMatchers](http://www.rubydoc.info/github/sethvargo/chefspec/ChefSpec/API/ServiceMatchers) describes the `enable_service` and `start_service` matchers.

[COMMENT] A great way to learn how to write good tests is by example. The ChefSpec project contains [example tests](https://github.com/sethvargo/chefspec/tree/master/examples) for many common Chef resource types.

Now let's run your tests. In the previous lesson, you ran your InSpec tests through Test Kitchen. To run ChefSpec tests, you run a program called [rspec](https://relishapp.com/rspec/rspec-core/docs/command-line).

First, make sure you're in the <% fp 'webserver_test' %> directory.

```bash
$ cd ~/learn-chef/cookbooks/webserver_test
```

Now run this command run your tests. The [chef exec](https://docs.chef.io/ctl_chef.html#chef-exec) part ensures that `rpsec` is run using Chef's Ruby. The `--color` part is optional, but can help you visually distinguish passing from failing tests.

```bash
# ~/learn-chef/cookbooks/webserver_test
$ chef exec rspec --color spec/unit/recipes/default_spec.rb
....

Finished in 0.50257 seconds (files took 2.34 seconds to load)
4 examples, 0 failures
```

[COMMENT] If you had multiple ChefSpec files, you would use `chef exec rspec --color spec/unit/recipes/*.rb` to run them all.

You see that no failures were reported. You've successfully validated the first requirement, which is to configure Apache on CentOS.

<% unstyled_list do %>
  <% icon_list_item('check-square-o') do %> 
    On CentOS, install the <code>httpd</code> package and enable and start the <code>httpd</code> service.
  <% end %>
  <% icon_list_item('square-o') do %>
    On Ubuntu, install the <code>apache2</code> package and enable and start the <code>apache2</code> service.
  <% end %>
<% end %>

[COMMENT] Remember, ChefSpec only simluates the execution of your resources; it doesn't run the code on a real instance. Therefore we can't verify things like whether port 80 would be open or whether `curl localhost` would succeed like you did in your InSpec tests because ChefSpec does not have that information. ChefSpec tests only what's expressed directly in your code.

[END_BOX]

[START_BOX]

## 2. Define the CentOS context

The next step is to write tests for the Ubuntu web server configuration. The Ubuntu tests will resemble the CentOS tests, but will use the `apache2` package and service name instead of `httpd`.

To keep the tests organized by platform, you'll use a _context_ block. You define one context for CentOS and one for Ubuntu. The following example illustrates this structure. 

```ruby
# default_spec.rb
require 'spec_helper'

describe 'webserver_test::default' do
  context 'when run on CentOS 7.2.1511' do
    # CentOS tests go here...
  end
  
  context 'when run on Ubuntu 14.04' do
    # Ubuntu tests go here...
  end
end
```

Before we write tests for Ubuntu, let's first add a context for CentOS. Modify your copy of <% fp 'default_spec.rb' %> like this.

```ruby
# ~/learn-chef/cookbooks/webserver_test/spec/unit/recipes/default_spec.rb
require 'spec_helper'

describe 'webserver_test::default' do
  context 'when run on CentOS 7.2.1511' do
    let(:chef_run) do
      runner = ChefSpec::ServerRunner.new(platform: 'centos', version: '7.2.1511')
      runner.converge(described_recipe)
    end

    it 'converges successfully' do
      expect { chef_run }.to_not raise_error
    end

    it 'installs httpd' do
      expect(chef_run).to install_package 'httpd'
    end

    it 'enables the httpd service' do
      expect(chef_run).to enable_service 'httpd'
    end

    it 'starts the httpd service' do
      expect(chef_run).to start_service 'httpd'
    end
  end
end
```

Notice two differences in this example.

The first difference is that the tests are grouped in a `context` block. A `context` block groups related tests.

The second difference is that the `ServerRunner` object is created by specifying the platform and version. ChefSpec uses these values to construct [automatic node attributes](https://docs.chef.io/ohai.html#automatic-attributes), for example `node['platform']` and `node['platform_version']`.

Recall Chef server holds information about your nodes, called _node attributes_, and that your node can access these attributes when `chef-client` runs. 

Because ChefSpec simulates your recipes, but does not run them, it needs a way to also simulate access to node attributes. [Ohai](https://docs.chef.io/ohai.html) is the tool that normally detects node attributes and provides them to the `chef-client` at the start of every run. To simulate the process, ChefSpec uses [fauxhai](https://github.com/customink/fauxhai). Fauxhai provides _mock_, or test, data for [common platforms](https://github.com/customink/fauxhai/tree/master/lib/fauxhai/platforms).

For CentOS, to know which value to specify for `version`, you can log into a Test Kitchen instance and run `cat /etc/centos-release`.

```bash
# ~/learn-chef/cookbooks/webserver_test
$ kitchen login
Last login: Tue May  3 04:30:02 2016 from 10.0.2.2
[vagrant@default-centos-72 ~]$ cat /etc/centos-release
CentOS Linux release 7.2.1511 (Core)
```

Fauxhai provides node attributes for [CentOS 7.2.1511](https://github.com/customink/fauxhai/blob/master/lib/fauxhai/platforms/centos/7.2.1511.json). Although these values might not match your configuration, you can use them to verify the correctness of your resources.

[COMMENT] You can [override](https://github.com/customink/fauxhai#overriding) node attributes in your test code. You can also use [real server data](https://github.com/customink/fauxhai#fetching) or [provide your own attributes file](https://github.com/customink/fauxhai#fixturing).
 
 
```bash
# ~/learn-chef/cookbooks/webserver_test
$ chef exec rspec --color spec/unit/recipes/default_spec.rb
....

Finished in 0.54235 seconds (files took 1.97 seconds to load)
4 examples, 0 failures
```

Next, you'll add a second `context` block that holds the tests for Ubuntu.

[END_BOX]

[START_BOX]

## 3. Write ChefSpec tests for the Ubuntu web server configuration 

Now let's repeat the pattern for CentOS by adding ChefSpec tests for the Ubuntu configuration.
 
Begin by adding tests to <% fp 'spec/unit/recipes/default_spec.rb' %> that validate that the proper package and service names are used on both CentOS and Ubuntu. The entire file looks like this.

```ruby
# ~/learn-chef/cookbooks/webserver_test/spec/unit/recipes/default_spec.rb
require 'spec_helper'

describe 'webserver_test::default' do
  context 'when run on CentOS 7.2.1511' do
    let(:chef_run) do
      runner = ChefSpec::ServerRunner.new(platform: 'centos', version: '7.2.1511')
      runner.converge(described_recipe)
    end

    it 'converges successfully' do
      expect { chef_run }.to_not raise_error
    end

    it 'installs httpd' do
      expect(chef_run).to install_package 'httpd'
    end

    it 'enables the httpd service' do
      expect(chef_run).to enable_service 'httpd'
    end

    it 'starts the httpd service' do
      expect(chef_run).to start_service 'httpd'
    end
  end

  context 'when run on Ubuntu 14.04' do
    let(:chef_run) do
      runner = ChefSpec::ServerRunner.new(platform: 'ubuntu', version: '14.04')
      runner.converge(described_recipe)
    end

    it 'converges successfully' do
      expect { chef_run }.to_not raise_error
    end

    it 'installs apache2' do
      expect(chef_run).to install_package 'apache2'
    end

    it 'enables the apache2 service' do
      expect(chef_run).to enable_service 'apache2'
    end

    it 'starts the apache2 service' do
      expect(chef_run).to start_service 'apache2'
    end
  end
end
```

Now run the ChefSpec tests, like this.

```bash
# ~/learn-chef/cookbooks/webserver_test
$ chef exec rspec --color spec/unit/recipes/default_spec.rb
.....FFF

Failures:

  1) webserver_test::default when run on Ubuntu 14.04 installs apache2
     Failure/Error: expect(chef_run).to install_package 'apache2'

       expected "package[apache2]" with action :install to be in Chef run. Other package resources:

         apt_package[httpd]

     # ./spec/unit/recipes/default_spec.rb:91:in `block (3 levels) in <top (required)>'

  2) webserver_test::default when run on Ubuntu 14.04 enables the apache2 service
     Failure/Error: expect(chef_run).to enable_service 'apache2'

       expected "service[apache2]" with action :enable to be in Chef run. Other service resources:

         service[httpd]

     # ./spec/unit/recipes/default_spec.rb:95:in `block (3 levels) in <top (required)>'

  3) webserver_test::default when run on Ubuntu 14.04 starts the apache2 service
     Failure/Error: expect(chef_run).to start_service 'apache2'

       expected "service[apache2]" with action :start to be in Chef run. Other service resources:

         service[httpd]

     # ./spec/unit/recipes/default_spec.rb:99:in `block (3 levels) in <top (required)>'

Finished in 1.04 seconds (files took 2.29 seconds to load)
8 examples, 3 failures

Failed examples:

rspec ./spec/unit/recipes/default_spec.rb:90 # webserver_test::default when run on Ubuntu 14.04 installs apache2
rspec ./spec/unit/recipes/default_spec.rb:94 # webserver_test::default when run on Ubuntu 14.04 enables the apache2 service
rspec ./spec/unit/recipes/default_spec.rb:98 # webserver_test::default when run on Ubuntu 14.04 starts the apache2 service
```

As you might expect, the CentOS tests pass, but the Ubuntu tests fail. 

```bash
Failed examples:

rspec ./spec/unit/recipes/default_spec.rb:90 # webserver_test::default when run on Ubuntu 14.04 installs apache2
rspec ./spec/unit/recipes/default_spec.rb:94 # webserver_test::default when run on Ubuntu 14.04 enables the apache2 service
rspec ./spec/unit/recipes/default_spec.rb:98 # webserver_test::default when run on Ubuntu 14.04 starts the apache2 service
```

The Ubuntu tests fail because the default recipe configures `httpd` unconditionally on all platforms. Your ChefSpec tests expect the recipe to configure `apache2` when run on Ubuntu.

As with our InSpec tests, having failing tests shows what functionality is missing and gives us clear goals to work towards.

[END_BOX]

[START_BOX]

## 4. Revise the webserver_test cookbook to support Ubuntu
 
Let's revise the `webserver_test` cookbook to run on both CentOS and Ubuntu. To do so, we'll define variables that hold the name of the package and service to manage. We'll use the built-in `node['platform']` node attribute to set these variables to their appropriate values.

Modify your `webserver_test` cookbook's default recipe like this.

```ruby
# ~/learn-chef/cookbooks/webserver_test/recipes/default.rb
package_name = service_name = case node['platform']
when 'centos' then 'httpd'
when 'ubuntu' then 'apache2'
end

# Install the package.
package package_name

# Start and enable the service.
service service_name do
  action [:enable, :start]
end

# Serve a custom home page.
file '/var/www/html/index.html' do
  content '<html>
  <body>
    <h1>hello world</h1>
  </body>
</html>'
end
```

This code uses a [case](http://ruby-doc.org/docs/keywords/1.9/Object.html#method-i-case) statement to match the platform name to the name of the package and the service. The `package_name` and `service_name` variables are later used in the `package` and `service` resources.

[COMMENT] For learning purposes, we're building a basic multi-platform cookbook from scratch. In practice, you might use the [httpd](https://supermarket.chef.io/cookbooks/httpd) cookbook from Chef Supermarket, which already supports multiple platforms.

Now let's verify whether our updated cookbook passes our ChefSpec tests. We want to see whether the tests for Ubuntu now pass and also verify that the tests for CentOS continue to pass.

```bash
# ~/learn-chef/cookbooks/webserver_test
$ chef exec rspec --color spec/unit/recipes/default_spec.rb
........

Finished in 1 second (files took 2.01 seconds to load)
8 examples, 0 failures
```

Great! All tests pass. In this example, the entire run took about 2 seconds to complete. This process is much faster than applying the configuration on real CentOS and Ubuntu instances, and is a great way to quickly validate that the resources are properly defined.

[COMMENT] We introduced InSpec testing first because many people find this kind of testing to be the easiest way to understand the concept and the value of testing. In practice, you might actually create your ChefSpec tests first because ChefSpec tests typically run more quickly, and can help identify potential issues earlier in the process.

[END_BOX]

[START_BOX]

## 5. Refactor the tests to reduce repeated code

Notice that the tests for Ubuntu and CentOS are similar. Each set of tests validates the same concerns. The only difference is the names used for the package and the service.

```ruby
# ~/learn-chef/cookbooks/webserver_test/spec/unit/recipes/default_spec.rb
require 'spec_helper'

describe 'webserver_test::default' do
  context 'when run on CentOS 7.2.1511' do
    let(:chef_run) do
      runner = ChefSpec::ServerRunner.new(platform: 'centos', version: '7.2.1511')
      runner.converge(described_recipe)
    end

    it 'converges successfully' do
      expect { chef_run }.to_not raise_error
    end

    it 'installs httpd' do
      expect(chef_run).to install_package 'httpd'
    end

    it 'enables the httpd service' do
      expect(chef_run).to enable_service 'httpd'
    end

    it 'starts the httpd service' do
      expect(chef_run).to start_service 'httpd'
    end
  end

  context 'when run on Ubuntu 14.04' do
    let(:chef_run) do
      runner = ChefSpec::ServerRunner.new(platform: 'ubuntu', version: '14.04')
      runner.converge(described_recipe)
    end

    it 'converges successfully' do
      expect { chef_run }.to_not raise_error
    end

    it 'installs apache2' do
      expect(chef_run).to install_package 'apache2'
    end

    it 'enables the apache2 service' do
      expect(chef_run).to enable_service 'apache2'
    end

    it 'starts the apache2 service' do
      expect(chef_run).to start_service 'apache2'
    end
  end
end
```

If you wanted to add a new test or modify an existing one, you would need to repeat that code for each platform you support. As you support additional platforms, the process can become tedious and error-prone.

Although not required, you might refactor some tests to reduce the amount of repeated code. One way you might refactor these tests is to use a [shared example](http://modocache.io/shared-examples-in-rspec).

A shared example enables you to define reusable test code. A shared example can contain parameters that are specified by other tests.

To try it, replace the contents of <% fp 'default_spec.rb' %> with this code.

```ruby
# ~/learn-chef/cookbooks/webserver_test/spec/unit/recipes/default_spec.rb
require 'spec_helper'

shared_examples 'webserver_test' do |platform, version, package, service|
  context "when run on #{platform} #{version}" do
    let(:chef_run) do
      runner = ChefSpec::ServerRunner.new(platform: platform, version: version)
      runner.converge(described_recipe)
    end

    it 'converges successfully' do
      expect { chef_run }.to_not raise_error
    end

    it "installs #{package}" do
      expect(chef_run).to install_package package
    end

    it "enables the #{service} service" do
      expect(chef_run).to enable_service service
    end

    it "starts the #{service} service" do
      expect(chef_run).to start_service service
    end
  end
end

describe 'webserver_test::default' do
  platforms = {
    'centos' => ['7.2.1511', 'httpd', 'httpd'],
    'ubuntu' => ['14.04', 'apache2', 'apache2']
  }

  platforms.each do |platform, platform_data|
    include_examples 'webserver_test', platform, *platform_data
  end
end
```

The `shared_examples` block takes as its arguments the platform name and version, as well as the Apache package and service names. These values are filled-in when the tests run. 

The `describe` block at the end of this example defines the test data. The `include_examples` method calls the `webserver_test` shared examples two times, once for Ubuntu and once for CentOS.

[COMMENT] `*platform_data` is an example of a [splat](http://www.justinweiss.com/articles/fun-with-keyword-arguments/). A splat extracts the values of an array so they can be used as individual arguments to the `webserver_test` shared examples.

Run ChefSpec to verify that the refactored tests continue to pass.

```bash
# ~/learn-chef/cookbooks/webserver_test
$ chef exec rspec --color spec/unit/recipes/default_spec.rb
........

Finished in 0.97828 seconds (files took 3.22 seconds to load)
8 examples, 0 failures
```

[END_BOX]