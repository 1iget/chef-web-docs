---
title: 'Get alerted when chef-client runs on your node'
order: 3
keywords: TODO
layout: lesson
sections: [exercises]
next: {heading: Conclusion, partial: conclusion}
time_to_complete: 60 minutes
show_disqus: false
---
[HEADLINE] Alerts help keep your team informed of important events that occur on your Chef server.

The Chef documentation [provides an overview](https://docs.chef.io/analytics.html) of Chef Analytics' components. In brief, Chef Analytics enables you to set up an _alert_ or _notification_, or an action that occurs in response to an event. You also set up _rules_, or the conditions that define which events cause an alert or notification to be sent.

An alert is a message that appears in the Chef Analytics web interface. Alerts are categorized as informational messages, warnings, and errors. A notification can be sent through email, HipChat, Slack, Splunk, or to any HTTP endpoint.

In this lesson, you'll set up a basic alert that is triggered when a `chef-client` run completes on a node. You'll then modify your rule to provide additional information, such as the time the run completed, whether it succeeded for failed, and where where to get more information about a failed run.

[START_BOX]

## 1. Sign in to the Chef Analytics web interface

[CALLOUT networks/workstation.png] Perform this part from your workstation.

From your web browser, navigate to the URL for your Chef Analytics server. Click the **Start Analytics** button and you'll be temporarily redirected to your Chef server logon page.

[COMMENT] If you installed Chef Analytics through the AWS Marketplace or Azure Marketplace, append port 8443 to the URL, for example, https://52.35.72.84:8443/. The port is required because the Chef server uses ports the default HTTPS port, 443.

![The Chef Analytics sign-in page](chef-analytics/sign-in.png)

Sign in with the administrator username and password that you used when you set up your Chef server.

![The Chef Manage sign-in page](chef-analytics/sign-in-redirect.png)

Click **Yes** to authorize Chef Analytics to use your Chef account.

![Authorize Chef Analytics to use your Chef account](chef-analytics/authorize.png)

On the home page you'll see an event timeline. This timeline is a rolling list of events that are happening in your infrastructure &ndash; machines that are checking in to Chef server, users updating cookbooks, and so on.

![The Chef Analytics home page](chef-analytics/home-page.png)

In the next step, you'll run `chef-client` on your node and watch an event appear on the timeline.

[END_BOX]

[START_BOX]

## 2. Run chef-client on your node

[CALLOUT networks/workstation.png] Perform this part from your workstation.

Now let's run the `hello_chef_server` cookbook on the node that you bootstrapped in the [Install and manage your own Chef server](/install-and-manage-your-own-chef-server/linux/) tutorial. You can use another cookbook if you prefer.

Refer to these pages for a refresher on how to run `chef-client` on your node. Choose the version that matches your node's operating system.

* [Red Hat Enterprise Linux or CentOS](/manage-a-node/rhel/update-your-nodes-configuration#step3)
* [Windows Server](/manage-a-node/windows/update-your-nodes-configuration#step3)
* [Ubuntu](/manage-a-node/ubuntu/update-your-nodes-configuration#step3)

Here's a complete example for a Linux node:

```bash
# ~/learn-chef/chef-repo
$ knife ssh 52.37.45.242 'sudo chef-client' --manual-list --ssh-user root --identity-file ~/.ssh/my.pem
52.37.45.242 Starting Chef Client, version 12.7.2
52.37.45.242 resolving cookbooks for run list: ["hello_chef_server"]
52.37.45.242 Synchronizing Cookbooks:
52.37.45.242   - hello_chef_server (0.1.0)
52.37.45.242 Compiling Cookbooks...
52.37.45.242 Converging 1 resources
52.37.45.242 Recipe: hello_chef_server::default
52.37.45.242   * file[/var/chef/cache/hello.txt] action create (up to date)
52.37.45.242
52.37.45.242 Running handlers:
52.37.45.242 Running handlers complete
52.37.45.242 Chef Client finished, 0/1 resources updated in 03 seconds
```

Now go back to the Chef Analytics web interface. From the **Nodes** tab, scroll to the bottom of the page and you'll see that Chef Analytics reports the successful `chef-client` run.

![The Nodes tab](chef-analytics/nodes-success.png)

Click your node from the list that appears at the bottom of the page (for example, **node1**) and you'll see details about the latest `chef-client` run.

![The node details screen](chef-analytics/node-status.png)

[END_BOX]

[START_BOX]

## 3. Create a rule that triggers an alert when chef-client runs

[CALLOUT rhel/platform-logos/chef-analytics.svg,networks/workstation.png] Connect to the Chef Analytics web interface from your workstation.

Rules are essentially conditional (_if this, then that_) logic for your infrastructure events. The general syntax of a rule is:

```ruby
# Untitled
rule on <message_type>
  when
    // some condition
  then
    // some action
  end
end
```

Some message types are:

* `action` &ndash; an operation occurred on the Chef server
* `run_converge` &ndash; a `chef-client` run has occurred
* `run_resource` &ndash; a single resource was updated
* `run_control` &ndash; a control run as part of [audit mode](https://docs.chef.io/analytics.html#audit-mode) occurred

You can [find all of the message types](https://docs.chef.io/analytics_rules.html#message-types) in the Chef documentation.

[COMMENT] Remember, to _converge_ a node means to run `chef-client` and bring the node towards its desired configuration.

We want a rule that alerts us every time a node converges, so we'll write a rule for the `run_converge` message type.

From the Chef Analytics web interface, click **Rules** and then click **+** to create a new rule. From the rule editor, click `New Rule Group 1` and rename it to `alert_on_run_converge`.

![Adding a new rule](chef-analytics/add-rule.png)

Replace the default rule with this one.

```ruby
rules 'alert_on_every_converge'
  rule on run_converge
  when
    true
  then
    alert:info("The node {{ message.node_name }} just converged.")
  end
end
```

This rule matches `run_converge`, which means it is processed when `chef-client` runs on a node.

The `when true` part means that the rule is always processed. The `then` part triggers an informational alert.<br><code ng-non-bindable>{{ message.node_name }}</code> is replaced with the name of the node when the alert triggers.

Click **Save** and you are brought back to the list of rules.

![Saving the rule](chef-analytics/add-rule-save.png)

[END_BOX]

[START_BOX]

## 4. Run chef-client to trigger your rule

[CALLOUT networks/workstation.png] Perform this part from your workstation.

Now run `chef-client` the same way you did in step 2. Here's an example:

```bash
# ~/learn-chef/chef-repo
$ knife ssh 52.37.45.242 'sudo chef-client' --manual-list --ssh-user root --identity-file ~/.ssh/my.pem
52.37.45.242 Starting Chef Client, version 12.7.2
52.37.45.242 resolving cookbooks for run list: ["hello_chef_server"]
52.37.45.242 Synchronizing Cookbooks:
52.37.45.242   - hello_chef_server (0.1.0)
52.37.45.242 Compiling Cookbooks...
52.37.45.242 Converging 1 resources
52.37.45.242 Recipe: hello_chef_server::default
52.37.45.242   * file[/var/chef/cache/hello.txt] action create (up to date)
52.37.45.242
52.37.45.242 Running handlers:
52.37.45.242 Running handlers complete
52.37.45.242 Chef Client finished, 0/1 resources updated in 03 seconds
```

From the web interface, navigate to the **Alerts** tab. You'll see something like this.

![Adding a new rule](chef-analytics/alert-converged.png)

[TIP] If your alerts or notifications don't trigger as you expect, you can run `sudo opscode-analytics-ctl tail` on your Chef Analytics system to help diagnose what's happening.

[END_BOX]

[START_BOX]

## 5. Modify the rule to alert a failed chef-client run

Knowing that `chef-client` completed on your node is a good first step, but you may be interested in knowing more about what happened during the run, for example:

* Whether `chef-client` completed successfully or with errors.
* The time the run completed.
* The number of resources that were updated.
* Where to get more information about a failed run.

Let's update our rule to capture these items. From the **Rules** tab, select the `alert_on_run_converge` rule and modify it like this.

```ruby
rules 'alert_on_every_converge'
  rule 'succeeded run' on run_converge
  when
    status = 'success'
  then
    alert:info("{{ message.node_name }} successfully converged at {{ message.end_time }}. {{ message.updated_resource_count }}/{{ message.total_resource_count }} resources were updated.")
  end

  rule 'failed run' on run_converge
  when
    status = 'failure'
  then
    alert:error("{{ message.node_name }} failed to converge at {{ message.end_time }}. You can find the error log here: https://{{ message.chef_server_fqdn }}/organizations/{{ message.organization_name }}/runs/{{ message.run_id }}/error_log")
  end
end
```

This code contains two rules. The first rule triggers an informational alert when `chef-client` completes successfully. It uses the built-in `message` object to retrieve the node's name, completion time, and the number of resources that were updated.

The second rule triggers an error alert when `chef-client` fails. It uses the built-in `message` object to build the URL to the page on Chef server that details the failure.

[DOCS] [Learn more about how to write rules](https://docs.chef.io/analytics_rules.html) in the Chef documentation.

[END_BOX]

[START_BOX]

## 6. Trigger the success and failure alerts

[CALLOUT networks/workstation.png] Perform this part from your workstation.

Now let's see both the success and failure alerts in action. We'll start with the success alert.

Now run `chef-client` the same way you did in steps 2 and 4. Here's an example:

```bash
# ~/learn-chef/chef-repo
$ knife ssh 52.37.45.242 'sudo chef-client' --manual-list --ssh-user root --identity-file ~/.ssh/my.pem
52.37.45.242 Starting Chef Client, version 12.7.2
52.37.45.242 resolving cookbooks for run list: ["hello_chef_server"]
52.37.45.242 Synchronizing Cookbooks:
52.37.45.242   - hello_chef_server (0.1.0)
52.37.45.242 Compiling Cookbooks...
52.37.45.242 Converging 1 resources
52.37.45.242 Recipe: hello_chef_server::default
52.37.45.242   * file[/var/chef/cache/hello.txt] action create (up to date)
52.37.45.242
52.37.45.242 Running handlers:
52.37.45.242 Running handlers complete
52.37.45.242 Chef Client finished, 0/1 resources updated in 03 seconds
```

From the web interface, navigate to the **Alerts** tab. You'll see something like this.

![The success alert](chef-analytics/alert-success.png)

As expected, the `chef-client` run succeeded. Zero resources were updated because the node is already in the desired state.

Now let's modify the `hello_chef_server` cookbook to fail so that we can trigger the failure alert. If you are using your own cookbook, you can add a similar failure.

Modify your cookbook's default recipe like this.

```ruby
# ~/learn-chef/chef-repo/hello_chef_server/recipes/default.rb
file "#{Chef::Config[:file_cache_path]}/hello.txt" do
  content 'Hello, Chef server!'
end

raise 'A fatal error has occurred.'
```

This example [raises an exception](http://ruby-doc.org/core-2.1.1/Exception.html) to cause the `chef-client` run to fail.

Now upload your updated cookbook to the Chef server.

```bash
# ~/learn-chef/chef-repo/
$ knife cookbook upload hello_chef_server
Uploading hello_chef_server [0.1.0]
Uploaded 1 cookbook.
```

Run `chef-client` on your node. Here's an example:

```bash
# ~/learn-chef/chef-repo
$ knife ssh 52.37.45.242 'sudo chef-client' --manual-list --ssh-user root --identity-file ~/.ssh/my.pem
52.37.45.242 Starting Chef Client, version 12.7.2
52.37.45.242 resolving cookbooks for run list: ["hello_chef_server"]
52.37.45.242 Synchronizing Cookbooks:
52.37.45.242   - hello_chef_server (0.1.0)
52.37.45.242 Compiling Cookbooks...
52.37.45.242
52.37.45.242 ================================================================================
52.37.45.242 Recipe Compile Error in /var/chef/cache/cookbooks/hello_chef_server/recipes/default.rb
52.37.45.242 ================================================================================
52.37.45.242
52.37.45.242 RuntimeError
52.37.45.242 ------------
52.37.45.242 A fatal error has occurred.
52.37.45.242
52.37.45.242 Cookbook Trace:
52.37.45.242 ---------------
52.37.45.242   /var/chef/cache/cookbooks/hello_chef_server/recipes/default.rb:10:in `from_file'
52.37.45.242
52.37.45.242 Relevant File Content:
52.37.45.242 ----------------------
52.37.45.242 /var/chef/cache/cookbooks/hello_chef_server/recipes/default.rb:
52.37.45.242
52.37.45.242   3:  # Recipe:: default
52.37.45.242   4:  #
52.37.45.242   5:  # Copyright (c) 2016 The Authors, All Rights Reserved.
52.37.45.242   6:  file "#{Chef::Config[:file_cache_path]}/hello.txt" do
52.37.45.242   7:    content 'Hello, Chef server!'
52.37.45.242   8:  end
52.37.45.242   9:
52.37.45.242  10>> raise 'A fatal error has occurred.'
52.37.45.242  11:
52.37.45.242
52.37.45.242
52.37.45.242 Running handlers:
52.37.45.242 [2016-02-26T16:48:38+00:00] ERROR: Running exception handlers
52.37.45.242 Running handlers complete
52.37.45.242 [2016-02-26T16:48:38+00:00] ERROR: Exception handlers complete
52.37.45.242 Chef Client failed. 0 resources updated in 03 seconds
52.37.45.242 [2016-02-26T16:48:38+00:00] FATAL: Stacktrace dumped to /var/chef/cache/chef-stacktrace.out
52.37.45.242 [2016-02-26T16:48:38+00:00] FATAL: Please provide the contents of the stacktrace.out file if you file a bug report
52.37.45.242 [2016-02-26T16:48:38+00:00] ERROR: A fatal error has occurred.
52.37.45.242 [2016-02-26T16:48:38+00:00] FATAL: Chef::Exceptions::ChildConvergeError: Chef run process exited unsuccessfully (exit code 1)
```

You'll see from the output that the exception is raised.

From the web interface, navigate to the **Alerts** tab. You'll see something like this.

![The success alert](chef-analytics/alert-failure.png)

Now you can navigate to the provided URL to learn more about the error.

![Examining the error from the Chef server web interface](chef-analytics/chef-server-diagnose-error.png)

Congratulations! With your alert in place, you now have greater visibility into when `chef-client` runs on your nodes and you can take action more quickly when a `chef-client` run fails.

[END_BOX]
