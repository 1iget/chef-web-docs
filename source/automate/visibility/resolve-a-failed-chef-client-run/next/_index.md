In this tutorial, you bootstrapped your demo environment's nodes to the Chef server. You then learned how push jobs enable you to run `chef-client` on multiple nodes that share a common run-list. Along the way, you learned how Chef Automate gives you visibility into the status of your infrastructure. You used Chef Automate to detect a failed `chef-client` run, took action to resolve the failure, and then verified that the fix was good.

The Chef Automate web interface you used in this tutorial supports many workflows. The workflow you used here was largely manual &ndash; you uploaded your change directly to the Chef server and ran `chef-client` on your nodes from your workstation. In practice, multiple teams commonly work together on complex systems made up of multiple components and services. To successfully ship code faster, with less effort, and with higher quality, you need a more centralized approach that promotes the DevOps principles of cross-team collaboration, cooperation, and transparency.

In the next tutorial, [Deploy a cookbook with Chef Automate](/automate/deploy-cookbook/), you'll use Chef Automate's workflow capabilities to deliver changes to `awesome_customers_delivery` web application cookbook to the Chef server and to verify the cookbook's behavior in a production-like environment. You'll learn how Chef Automate can automatically verify the correctness of new features that you submit to the pipeline, how to approve code changes made by others, and how to extend Chef's built-in mechanism for deploying new cookbook features.

If you need a break, you can [temporarily stop your AWS instances](/automate/install/managing-your-aws-instances#stoppingandrestartingyourawsinstances) and restart them later when you're ready.
