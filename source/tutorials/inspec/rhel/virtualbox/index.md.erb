---
title: 'Use InSpec to verify your server configuration'
short_title: 'Verify with InSpec'
platform: Red Hat Enterprise Linux
platform_id: rhel
category: local-development
logo: tests.svg
order: 3
layout: lesson
time_to_complete: 60 minutes
snippet_path: test-your-infrastructure-code/rhel/virtualbox/verify-desired-state
snippet_workstation: ubuntu
machine_config: snippets/test-your-infrastructure-code/rhel/virtualbox/machine_config.md
environment: virtualbox
headings: [
  { label: 'Prerequisites', href: '#prerequisites' },
  { label: '1. Create a cookbook', href: '#step1' },
  { label: '2. Write the first test', href: '#step2' },
  { label: '3. Run the test', href: '#step3' },
  { label: '4. Make the test pass', href: '#step4' },
  { label: '5. Verify the configuration', href: '#step5' },
  { label: '6. Write the remaining tests', href: '#step6' },
  { label: '7. Watch the tests fail', href: '#step7' },
  { label: '8. Make the remaining tests pass', href: '#step8' },
  { label: '9. Verify the updated configuration', href: '#step9' },
  { label: '10. Verify on a clean instance', href: '#step10' },
]
---
[HEADLINE] Running InSpec tests through Test Kitchen lets you automatically verify your configuration on temporary instances, giving you added confidence that your changes will work as you expect in production. You can also use InSpec to test your production servers.

In this tutorial, you'll learn how to use [InSpec](http://inspec.io/) to automatically verify a basic web server configuration. You'll run InSpec from Test Kitchen on a virtual machine running on your workstation.

[COMMENT] If you're new to automated testing, consider reading [Getting started with automated testing](/skills/get-started-with-testing/) before you start this tutorial.

InSpec provides a kind of [integration testing](https://en.wikipedia.org/wiki/Integration_testing), where you verify that multiple components function correctly together. With InSpec, you write code that describes the desired state of the server. InSpec translates this code into SSH commands that it runs on the server.

It's common to write InSpec tests after you write your configuration code. But another way is to take a _test-driven_ approach, where you write your tests first before you write any Chef code.

The idea behind test-driven development is to use tests, also called _specifications_ or _specs_, to clearly document your requirements. You run your tests on the server and watch them each fail. Then you write just enough Chef code to make at least one failing test pass. You then repeat the process until all of your tests pass.

Here's a 60-minute webcast that discusses the test-driven process in greater depth and shows working examples. You can watch the video before or after you complete this tutorial.

<script type="text/javascript" src="https://www.brighttalk.com/clients/js/embed/embed.js"></script> <object class="BrightTALKEmbed" width="705" height="660">     <param name="player" value="channel_player"/>     <param name="domain" value="https://www.brighttalk.com"/>     <param name="channelid" value="11349"/>     <param name="communicationid" value="191263"/>     <param name="autoStart" value="false"/>     <param name="theme" value=""/> </object>

An important benefit of test-driven development is that it helps limit scope. You know you're done when all tests pass. And because the tests are code, they're versionable through source control. When a requirement changes, you capture that change by updating the tests. This gives you the complete history of your requirements and better insight into when and how your requirements changed.

Here you'll create a basic cookbook that resembles the Apache web server configuration that you wrote [previously](/tutorials/learn-the-basics/rhel/free/configure-a-package-and-service/). Let's begin by defining clear goals for the web server configuration.

Here's the criteria for the web server configuration:

<% unstyled_list do %>
  <% icon_list_item('square-o') do %>
    Install the Apache package, <code>httpd</code>, on Red Hat Enterprise Linux systems.
  <% end %>
  <% icon_list_item('square-o') do %>
    Start and enable the <code>httpd</code> service.
  <% end %>
  <% icon_list_item('square-o') do %>
    Serve a custom home page.
  <% end %>
  <% icon_list_item('square-o') do %>
    Open port 80 to incoming traffic.
  <% end %>
<% end %>

<p>
You'll follow the test-driven approach by first writing a test, watching it fail, and then writing just enough code to make it pass.

Let's start by making sure you're set up for local development.
</p>

<% accordion('test-configuration', 'Test configuration') do %>

<% markdown do %>

<% render_machine_config(current_page.data.machine_config) %>

<% end %>

<% end %>


[START_BOX]

## Prerequisites

### Understand hardware requirements

To successfully complete this tutorial, you'll need a Windows, MacOS, or Linux workstation that has relatively powerful hardware. We recommend that your workstation have at least 15GB of free disk space and at least 4GB of available memory so that you can download the base image and run a few virtual machine instances.

### Set up your workstation for local development

This tutorial builds on top off knowledge gained in [Develop locally](/tutorials/local-development/rhel/) and [Manage a basic web application](/manage-a-web-app/rhel/).

First, you'll need to have the latest version of the Chef Development Kit on your workstation. You'll also need a programmer's text editor that you're comfortable working with and a directory to work from &ndash; the tutorials use <% fp '~/learn-chef' %>. [Follow these steps](/tutorials/manage-a-node/rhel/hosted/set-up-your-workstation/) to get set up.

You'll also need the virtualization software [VirtualBox](https://www.virtualbox.org/) and [Vagrant](https://www.vagrantup.com/). If you don't have VirtualBox and Vagrant installed, [follow steps 1&mdash;3](/tutorials/learn-the-basics/rhel/virtualbox/set-up-a-machine-to-manage) to get set up. Optionally, you can follow steps 4&mdash;7 to verify you can successfully bring up a local virtual machine.

### Build local development skills using Test Kitchen

This tutorial requires familiarity with local development using Test Kitchen.

If you're not familiar with Test Kitchen, work through [Develop locally](/tutorials/local-development/rhel/) before you start this tutorial. This tutorial teaches you the basics of how to apply cookbooks on local test instances, all on your workstation.

The [Manage a basic web application](/manage-a-web-app/rhel/) tutorial provides additional hands-on practice with local development. Working through this tutorial is optional. Here, you configure a basic but complete web application using Test Kitchen. The [quickstart](/manage-a-web-app/rhel/bring-up-the-web-app-using-test-kitchen/) brings up the final configuration on a local test instance in just a few minutes.

[END_BOX]

[START_BOX]

## 1. Create a web server cookbook

From your terminal window, begin by moving to the <% fp '~/learn-chef' %> directory.

<% command_snippet(page: current_page, path: 'create-the-web-server-cookbook/cd-learn-chef', features: :stdin) %>

Next, run the following `chef generate cookbook` command to create a cookbook named `webserver_test` under the <% fp '~/learn-chef/cookbooks' %> directory..

<% command_snippet(page: current_page, path: 'create-the-web-server-cookbook/chef-generate-cookbook') %>

The "test" part of the cookbook's name is simply to distinguish this cookbook from those used in other Learn Chef tutorials. In practice, you might simply name the cookbook `webserver`.

[END_BOX]

[START_BOX]

## 2. Write the first test

Before writing any configuration code, let's write a test that verifies the first requirement:

<% unstyled_list do %>
  <% icon_list_item('arrow-right') do %>
    <b>Install the Apache package, <code>httpd</code>, on Red Hat Enterprise Linux systems.</b>
  <% end %>
  <% icon_list_item('square-o') do %>
    Start and enable the <code>httpd</code> service.
  <% end %>
  <% icon_list_item('square-o') do %>
    Serve a custom home page.
  <% end %>
  <% icon_list_item('square-o') do %>
    Open port 80 to incoming traffic.
  <% end %>
<% end %>

The file <% fp 'test/recipes/default/default_test.rb' %> will hold our tests. You typically have one test file for each recipe in your cookbooks. Here, <% fp 'default_test.rb' %> contains tests for the default recipe, <% fp 'default.rb' %>. For this tutorial, you'll add all configuration code to the default recipe.

As with many test frameworks, InSpec code resembles natural language. Here's the format of an InSpec test.

```ruby
# default_test.rb
describe '<entity>' do
  it { <expection> }
end
```

An InSpec test has two main components: the _subject to examine_ and the subject's _expected state_. Here, `<entity>` is the subject you want to examine, for example, a package name, service, file, or network port. The `<expectation>` part specifies the desired result or expected state, for example, that a port should be open (or perhaps _should not_ be open.)

[COMMENT] In this tutorial, you use RSpec's "should" syntax. You can also use the [expect syntax](http://rspec.info/blog/2012/06/rspecs-new-expectation-syntax/).

Replace the contents of <% fp 'default_test.rb' %> with this code. This code tests whether the `httpd` package is installed.

<% code_snippet(page: current_page, path: 'write-the-first-test/default_test-1') %>

This code uses InSpec's [package](http://inspec.io/docs/reference/resources/package) resource to test whether the `httpd` package is installed on the system.

[COMMENT] If you've used [RSpec](http://rspec.info) or [Serverspec](http://serverspec.org/), InSpec code will look familiar to you. You can continue to use the Serverspec tests that you've already written and also write new Serverspec tests. One difference between InSpec and Serverspec is that InSpec does not install additional software on your target system. On Linux, it performs all tests over SSH. On Windows, it performs tests over WinRM.

[END_BOX]

[START_BOX]

## 3. Run the test on a CentOS virtual machine

Now you'll run the test through Test Kitchen on a CentOS virtual machine and watch it fail.

Modify <code class="file-path">.kitchen.yml</code> like this to specify CentOS 7.2 as the target platform.

<% code_snippet(page: current_page, path: 'run-the-first-test/kitchen-yml') %>

The `verifier` part specifies that the cookbook contains InSpec tests. The `inspec_tests` part specifies that the tests exist under the cookbook's <% fp 'test/recipes' %> directory.

Next, `cd` to your cookbook directory.

<% command_snippet(page: current_page, path: 'run-the-first-test/cd-webserver_test-1', features: :stdin) %>

Run `kitchen list` to verify that the instance has not yet been created.

<% command_snippet(page: current_page, path: 'run-the-first-test/kitchen-list-1') %>

In the previous tutorials, you ran `kitchen converge` to bring up your virtual machine and apply your Chef code. This time, run `kitchen verify` to bring up the virtual machine and run just your tests.

<% command_snippet(page: current_page, path: 'run-the-first-test/kitchen-verify-1', features: [:stdin, :stdout, :stderr]) %>

You see from the output that the test failed.

```bash
# ~/learn-chef/cookbooks/webserver_test
System Package
   ✖  httpd should be installed
   expected that `System Package httpd` is installed
```

You should expect the test to fail because you have not yet written any code to install the package. Having a failing test shows what functionality is missing and gives you a clear goal to work towards. You also now have a way to quickly get feedback on whether the changes you make bring you closer to your goal.

[END_BOX]

[START_BOX]

## 4. Write just enough code to make the test pass

To make the test pass, you need to install the `httpd` package. To do that, you can use the [package](https://docs.chef.io/resource_package.html) resoruce. Write out the default recipe, <% fp 'default.rb' %>, like this.

<% code_snippet(page: current_page, path: 'make-first-test-pass/default-1-rhel') %>

[COMMENT] For learning purposes, you use the built-in `package` resource to install Apache. A more robust solution might use the [httpd](https://supermarket.chef.io/cookbooks/httpd) cookbook from Chef Supermarket. You use the `httpd` cookbook in the [Manage a basic web application](/manage-a-web-app/rhel/configure-apache/) tutorial.

[END_BOX]

[START_BOX]

## 5. Apply and verify the configuration

The `kitchen verify` command already brought up a CentOS instance. Now run `kitchen converge` to apply your web server cookbook to your instance.

<% command_snippet(page: current_page, path: 'apply-and-verify-the-configuration/kitchen-converge-1') %>

The output shows that the `httpd` package was installed and that the `chef-client` run completed without error.

The next step is to verify that it placed the system in the desired state. Run `kitchen verify` to run your InSpec test.

<% command_snippet(page: current_page, path: 'apply-and-verify-the-configuration/kitchen-verify-2') %>

Success! The test passes. If the test did not pass, you would go back to your recipe, fix the failure, and run your test again.

[COMMENT] Writing just one test is better than having no tests at all. After you have at least one test in place, you have a foundation and a process for writing more.

Run `kitchen list`. You'll see in the `Last Action` column that the instance's state is `Verified`, which means that Test Kitchen's most recent action was to run the tests.

<% command_snippet(page: current_page, path: 'apply-and-verify-the-configuration/kitchen-list-2') %>

[END_BOX]

[START_BOX]

## 6. Write the remaining tests

So far, you've validated the first requirement for your web server configuration.

<% unstyled_list do %>
  <% icon_list_item('check-square-o') do %>
    Install the Apache package, <code>httpd</code>, on Red Hat Enterprise Linux systems.
  <% end %>
  <% icon_list_item('square-o') do %>
    Start and enable the <code>httpd</code> service.
  <% end %>
  <% icon_list_item('square-o') do %>
    Serve a custom home page.
  <% end %>
  <% icon_list_item('square-o') do %>
    Open port 80 to incoming traffic.
  <% end %>
<% end %>

Now let's write the remaining tests.

Append three more InSpec tests to <% fp 'default_test.rb' %>, making the entire file look like this.

<% code_snippet(page: current_page, path: 'write-the-remaining-tests/default_test-2') %>

This code uses InSpec's [service](http://inspec.io/docs/reference/resources/service), [command](http://inspec.io/docs/reference/resources/command), and [port](http://inspec.io/docs/reference/resources/port) resources. The `command` resource uses a regular expression to verify that the home page contains the string "hello".

[RUBY] Regular expressions in Ruby are usually surrounded with forward slashes `/`. [Rubular](http://rubular.com) is a handy way to test out your regular expressions.

[END_BOX]

[START_BOX]

## 7. Watch the remaining tests fail

From your cookbook directory, run `kitchen verify`.

<% command_snippet(page: current_page, path: 'write-the-remaining-tests/kitchen-verify-3', features: [:stdin, :stdout, :stderr]) %>

You'll see from the output that the first test continues to pass, but the new tests fail. Again, this is expected because we didn't write code to configure these parts of the system.

[END_BOX]

[START_BOX]

## 8. Write just enough code to make the remaining tests pass

In practice, you might resolve each remaining test failure individually. This gradual approach enables you to build your cookbooks in small batches. Because Chef uses a test-and-repair approach, you can run Test Kitchen as many times as you need.

To keep things moving, let's resolve the remaining failures all at once. Modify your default recipe, <% fp 'default.rb' %>, like this.

<% code_snippet(page: current_page, path: 'make-remaining-tests-pass/default-2-rhel') %>

This code uses the `service` and `file` resources that you've used in previous tutorials.

This code does not explicitly configure Apache to run on port 80. We'll see in the next step whether we need to write additional code to address that requirement.

[END_BOX]

[START_BOX]

## 9. Apply and verify the updated configuration

Run `kitchen converge` to apply your web server cookbook to your instance.

<% command_snippet(page: current_page, path: 'apply-and-verify-updated-configuration/kitchen-converge-2') %>

The output shows that the `httpd` service was enabled and started and that the home page is set.

Now run `kitchen verify` to run your InSpec tests.

<% command_snippet(page: current_page, path: 'apply-and-verify-updated-configuration/kitchen-verify-4') %>

All 5 tests now pass. (We proposed 4 criteria, but the service criteria covers 2 tests.)

If any test did not pass, you would go back to your recipe, fix the failure, and run your test again.

Congratulations. You've successfully satisfied the basic requirements for your web server.

<% unstyled_list do %>
  <% icon_list_item('check-square-o') do %>
    Install the Apache package, <code>httpd</code>, on Red Hat Enterprise Linux systems.
  <% end %>
  <% icon_list_item('check-square-o') do %>
    Start and enable the <code>httpd</code> service.
  <% end %>
  <% icon_list_item('check-square-o') do %>
    Serve a custom home page.
  <% end %>
  <% icon_list_item('check-square-o') do %>
    Open port 80 to incoming traffic.
  <% end %>
<% end %>

You don't need to write additional code to open port 80 because the default configuration handles that.

As your requirements evolve, you can repeat the process by writing additional tests, watching them fail, and then writing just enough code to make them pass.

[END_BOX]

[START_BOX]

## 10. Verify your configuration on a clean instance

As you experiment and correct mistakes, it's a good practice to apply your configuration and run your tests one final time on a clean instance to ensure that the process is repeatable and isn't the result of any experimentation or intermediate steps you performed along the way.

So far, you ran commands such as `kitchen converge`, `kitchen verify`, and `kitchen destroy` to manage your instances.

You can also run the `kitchen test` command to create, converge, verify, and destroy your instance all in one step. Running `kitchen test` is equivalent to running these commands.

```bash
$ kitchen destroy
$ kitchen create
$ kitchen converge
$ kitchen verify
$ kitchen destroy
```

Run `kitchen test` to apply and test your configuration one final time.

<% command_snippet(page: current_page, path: 'verify-on-clean-instance/kitchen-test-1') %>

You see from the output that the tests pass and the configuration is repeatable. Run `kitchen list` to verify that the instance is destroyed.

<% command_snippet(page: current_page, path: 'verify-on-clean-instance/kitchen-list-3') %>

[COMMENT] The `kitchen test` command is also commonly used in automated pipelines because it ensures that the instance is destroyed immediately after `chef-client` completes and all tests are run. When you use a [cloud driver](https://docs.chef.io/kitchen.html#drivers) with Test Kitchen, `kitchen test` can help minimize cost.

[GITHUB] [Get the code for this lesson](https://github.com/learn-chef/webserver_test/tree/lesson1_rhel) on GitHub.

[END_BOX]

[START_BOX]

## Conclusion

In this tutorial, you used InSpec to verify the correctness of a basic web server cookbook. An increasingly popular way to write cookbooks is to write your tests before you write your Chef code. This _test-driven_ approach helps document your requirements and goals, and the scope of your project. Once all your tests pass, you've satisfied the requirements for your project and can move it to the next phase.

As with any kind of software testing, there's a time trade-off. It can take some time to write your initial tests and incorporate them into your workflow &ndash; arguably, it can take more time to set up your test process than it would take to test your initial configuration manually. Writing test code is also new to many people, and it can take time to ramp up your skills.

But once you have automated testing in place and the skills to start writing tests, verifying changes becomes significantly faster. What once took days or weeks to manually verify can now take hours or even minutes. And because automated testing enables you to more quickly and easily build confidence in your changes, you'll be better able to tackle those small but important changes that you were once hesitant to commit to.

### Next steps

If you're new to Ruby programming or testing with InSpec, one of the best ways to improve your skills is to adapt other examples that you see. The [InSpec documentation](http://inspec.io/docs/reference/resources/) provides the full list of available resource types, and has many good examples. Learn more about writing great tests and see practical examples at [betterspecs.org](http://betterspecs.org).

Although InSpec is a great way to get fast feedback on whether your cookbook behaves as you expect on a real instance, there are ways to verify your work even faster. Next, we recommend the [Unit test with ChefSpec](/tutorials/chefspec/) tutorial. Here you'll learn how to use ChefSpec to speed up the feedback cycle even more by simulating the execution of your resources in memory without the need to create test instances.

Learn more about how to test and debug your Chef code in our [Joy of Automating](/skills/) video series, hosted by Franklin Webber.

If you're involved in your company's compliance and audit process, you may be interested in the [Chef compliance scanner](/tutorials/compliance-assess/rhel/), which uses InSpec as its auditing and testing framework.

You may also be interested in [Chef Automate](https://www.chef.io/automate/), which gives your operations and development teams a common platform for developing, building, testing, and deploying cookbooks, applications, and more. Chef Automate reinforces the Chef workflow, where you begin by developing and testing your configuration from your local workstation. Then, you submit your change to Chef Automate's pipeline, where your change goes through sets of automated tests before going out into production. If you have many different teams, each delivering software in its own way, you can use Chef Automate to bring a standard, proven approach to all of your organization's deployments.

[TRAINING] Ready to dig deeper? Join us in-person or online at an upcoming instructor-led training event. [Learn more about our course offerings](https://www.chef.io/training/) or [check out our upcoming classes](https://www.chef.io/blog/events/category/training-events/). Use discount code **LEARN-CHEF** to save 10%. Use what you've learned to [gain official Chef certification](https://training.chef.io/certification).

[END_BOX]
