[HEADLINE] Running InSpec tests through Test Kitchen lets you automatically verify your configuration on temporary instances, giving you added confidence that your changes will work as you expect in production.

In this part, you'll learn how to use [InSpec](http://inspec.io/docs/reference/resources/) to automatically verify a basic web server configuration. You'll run InSpec from Test Kitchen on a virtual machine running on your workstation.

InSpec provides a kind of _integration_ testing, where you verify that multiple components function correctly together. With InSpec, you write code that describes the desired state of the server. InSpec translates this code into SSH commands that it runs on the server.

[COMMENT] If you've used [RSpec](http://rspec.info) or [Serverspec](http://serverspec.org/), InSpec code will look familiar to you. You can continue to use the Serverspec tests that you've already written and also write new Serverspec tests. One difference between InSpec and Serverspec is that InSpec does not install additional software on your target system. On Linux, it performs all tests over SSH. On Windows, it performs tests over WinRM.

It's common to write InSpec tests after you write your configuration code. But another way is to take a _test-driven_ approach, where you write your tests first before you write any Chef code.

The idea behind test-driven development is to use tests, also called _specifications_ or _specs_, to clearly document your requirements. You run your tests on the server and watch them each fail. Then you write just enough Chef code to make at least one failing test pass. You then repeat the process until all of your tests pass.

Here's a 60-minute webcast that discusses the test-driven process in greater depth and shows working examples. You can watch the video before or after you complete this tutorial.

<script type="text/javascript" src="https://www.brighttalk.com/clients/js/embed/embed.js"></script> <object class="BrightTALKEmbed" width="705" height="660">     <param name="player" value="channel_player"/>     <param name="domain" value="https://www.brighttalk.com"/>     <param name="channelid" value="11349"/>     <param name="communicationid" value="191263"/>     <param name="autoStart" value="false"/>     <param name="theme" value=""/> </object>

An important benefit of test-driven development is that it helps limit scope. You know you're done when all tests pass. And because the tests are code, they're versionable through source control. When a requirement changes, you capture that change by updating the tests. This gives you the complete history of your requirements and better insight into when and how your requirements changed.

In this lesson, you'll create a basic cookbook that resembles the Apache web server configuration that you wrote [previously](/tutorials/learn-the-basics/rhel/free/configure-a-package-and-service/). Let's begin by defining clear goals for the web server configuration.

Here's the criteria for the web server configuration:

<% unstyled_list do %>
  <% icon_list_item('square-o') do %>
    Install the Apache package, <code>httpd</code>, on Red Hat Enterprise Linux systems.
  <% end %>
  <% icon_list_item('square-o') do %>
    Start and enable the <code>httpd</code> service.
  <% end %>
  <% icon_list_item('square-o') do %>
    Serve a custom home page.
  <% end %>
  <% icon_list_item('square-o') do %>
    Open port 80 to incoming traffic.
  <% end %>
<% end %>

You'll follow the test-driven approach by first writing a test, watching it fail, and then writing just enough code to make it pass.

[START_BOX]

## 1. Create a web server cookbook

From your terminal window, begin by moving to the <% fp '~/learn-chef' %> directory.

<% command_snippet(page: current_page, path: 'create-the-web-server-cookbook/cd-learn-chef', features: :stdin) %>

Next, run the following `chef generate cookbook` command to create a cookbook named `webserver_test` under the <% fp '~/learn-chef/cookbooks' %> directory..

<% command_snippet(page: current_page, path: 'create-the-web-server-cookbook/chef-generate-cookbook') %>

The "test" part of the cookbook's name is simply to distinguish this cookbook from those used in other Learn Chef tutorials. In practice, you might simply name the cookbook `webserver`.

[END_BOX]

[START_BOX]

## 2. Write the first test

Before writing any configuration code, let's write a test that verifies the first requirement:

<% unstyled_list do %>
  <% icon_list_item('bullseye') do %>
    <b>Install the Apache package, <code>httpd</code>, on Red Hat Enterprise Linux systems.</b>
  <% end %>
  <% icon_list_item('square-o') do %>
    Start and enable the <code>httpd</code> service.
  <% end %>
  <% icon_list_item('square-o') do %>
    Serve a custom home page.
  <% end %>
  <% icon_list_item('square-o') do %>
    Open port 80 to incoming traffic.
  <% end %>
<% end %>

The file <% fp 'test/recipes/default/default_test.rb' %> will hold our tests. You typically have one test file for each recipe in your cookbooks. Here, <% fp 'default_test.rb' %> contains tests for the default recipe, <% fp 'default.rb' %>. For this tutorial, you'll add all configuration code to the default recipe.

As with many test frameworks, InSpec code resembles natural language. Here's the format of an InSpec test.

```ruby
# default_test.rb
describe '<entity>' do
  it { <expection> }
end
```

An InSpec test has two main components: the _subject to examine_ and the subject's _expected state_. Here, `<entity>` is the subject you want to examine, for example, a package name, service, file, or network port. The `<expectation>` part specifies the desired result or expected state, for example, that a port should be open (or perhaps _should not_ be open.)

[COMMENT] In this tutorial, you use RSpec's "should" syntax. You can also use the [expect syntax](http://rspec.info/blog/2012/06/rspecs-new-expectation-syntax/).

Replace the contents of <% fp 'default_test.rb' %> with this code. This code tests whether the `httpd` package is installed.

<% code_snippet(page: current_page, path: 'write-the-first-test/default_test-1') %>

This code uses InSpec's [package](http://inspec.io/docs/reference/resources/package) resource to test whether the `httpd` package is installed on the system.

[END_BOX]

[START_BOX]

## 3. Run the test on a CentOS virtual machine

Now you'll run the test through Test Kitchen on a CentOS virtual machine and watch it fail.

Modify <code class="file-path">.kitchen.yml</code> like this to specify CentOS 7.2 as the target platform.

<% code_snippet(page: current_page, path: 'run-the-first-test/kitchen-yml') %>

This configuration specifies that the cookbook contains InSpec tests.

Next, `cd` to your cookbook directory.

<% command_snippet(page: current_page, path: 'run-the-first-test/cd-webserver_test-1', features: :stdin) %>

Run `kitchen list` to verify that the instance has not yet been created.

<% command_snippet(page: current_page, path: 'run-the-first-test/kitchen-list-1') %>

In the previous tutorials, you ran `kitchen converge` to bring up your virtual machine and apply your Chef code. This time, run `kitchen verify` to bring up the virtual machine and run just your tests.

<% command_snippet(page: current_page, path: 'run-the-first-test/kitchen-verify-1', features: [:stdin, :stdout, :stderr]) %>

You see from the output that the test failed.

```bash
# ~/learn-chef/cookbooks/webserver_test
âœ–  System Package httpd should be installed (expected that `System Package httpd` is installed)
```

You should expect the test to fail because you have not yet written any code to install the package. Having a failing test shows what functionality is missing and gives you a clear goal to work towards. You also now have a way to quickly get feedback on whether the changes you make bring you closer to your goal.

[END_BOX]

[START_BOX]

## 4. Write just enough code to make the test pass

To make the test pass, you need to install the `httpd` package. To do that, you can use the [package](https://docs.chef.io/resource_package.html) resoruce. Write out the default recipe, <% fp 'default.rb' %>, like this.

<% code_snippet(page: current_page, path: 'make-first-test-pass/default-1-rhel') %>

[COMMENT] For learning purposes, you use the built-in `package` resource to install Apache. A more robust solution might use the [httpd](https://supermarket.chef.io/cookbooks/httpd) cookbook from Chef Supermarket. You used the `httpd` cookbook in the previous tutorial, [Manage a basic web application](/manage-a-web-app/rhel/configure-apache/).

[END_BOX]

[START_BOX]

## 5. Apply and verify the configuration

The `kitchen verify` command already brought up a CentOS instance. Now run `kitchen converge` to apply your web server cookbook to your instance.

<% command_snippet(page: current_page, path: 'apply-and-verify-the-configuration/kitchen-converge-1') %>

The output shows that the `httpd` package was installed and that the `chef-client` run completed without error.

The next step is to verify that it placed the system in the desired state. Run `kitchen verify` to run your InSpec test.

<% command_snippet(page: current_page, path: 'apply-and-verify-the-configuration/kitchen-verify-2') %>

Success! The test passes. If the test did not pass, you would go back to your recipe, fix the failure, and run your test again.

[COMMENT] Writing just one test is better than having no tests at all. After you have at least one test in place, you have a foundation and a process for writing more.

Run `kitchen list`. You'll see in the `Last Action` column that the instance's state is `Verified`, which means that Test Kitchen's most recent action was to run the tests.

<% command_snippet(page: current_page, path: 'apply-and-verify-the-configuration/kitchen-list-2') %>

[END_BOX]

[START_BOX]

## 6. Write the remaining tests

So far, you've validated the first requirement for your web server configuration.

<% unstyled_list do %>
  <% icon_list_item('check-square-o') do %>
    Install the Apache package, <code>httpd</code>, on Red Hat Enterprise Linux systems.
  <% end %>
  <% icon_list_item('square-o') do %>
    Start and enable the <code>httpd</code> service.
  <% end %>
  <% icon_list_item('square-o') do %>
    Serve a custom home page.
  <% end %>
  <% icon_list_item('square-o') do %>
    Open port 80 to incoming traffic.
  <% end %>
<% end %>

Now let's write the remaining tests.

Append three more InSpec tests to <% fp 'default_test.rb' %>, making the entire file look like this.

<% code_snippet(page: current_page, path: 'write-the-remaining-tests/default_test-2') %>

This code uses InSpec's [service](http://inspec.io/docs/reference/resources/service), [command](http://inspec.io/docs/reference/resources/command), and [port](http://inspec.io/docs/reference/resources/port) resources. The `command` resource uses a regular expression to verify that the home page contains the string "hello".

[RUBY] Regular expressions in Ruby are usually surrounded with forward slashes `/`. [Rubular](http://rubular.com) is a handy way to test out your regular expressions.

[END_BOX]

[START_BOX]

## 7. Watch the remaining tests fail

From your cookbook directory, run `kitchen verify`.

<% command_snippet(page: current_page, path: 'write-the-remaining-tests/kitchen-verify-3', features: [:stdin, :stdout, :stderr]) %>

You'll see from the output that the first test continues to pass, but the new tests fail. Again, this is expected because we didn't write code to configure these parts of the system.

[END_BOX]

[START_BOX]

## 8. Write just enough code to make the remaining tests pass

In practice, you might resolve each remaining test failure individually. This gradual approach enables you to build your cookbooks in small batches. Because Chef uses a test-and-repair approach, you can run Test Kitchen as many times as you need.

To keep things moving, let's resolve the remaining failures all at once. Modify your default recipe, <% fp 'default.rb' %>, like this.

<% code_snippet(page: current_page, path: 'make-remaining-tests-pass/default-2-rhel') %>

This code uses the `service` and `file` resources that you've used in previous tutorials.

This code does not explicitly configure Apache to run on port 80. We'll see in the next step whether we need to write additional code to address that requirement.

[END_BOX]

[START_BOX]

## 9. Apply and verify the updated configuration

Run `kitchen converge` to apply your web server cookbook to your instance.

<% command_snippet(page: current_page, path: 'apply-and-verify-updated-configuration/kitchen-converge-2') %>

The output shows that the `httpd` service was enabled and started and that the home page is set.

Now run `kitchen verify` to run your InSpec tests.

<% command_snippet(page: current_page, path: 'apply-and-verify-updated-configuration/kitchen-verify-4') %>

All 5 tests now pass. (The output shows 4 lines, but the second line covers 2 tests.)

If any test did not pass, you would go back to your recipe, fix the failure, and run your test again.

Congratulations. You've successfully satisfied the basic requirements for your web server.

<% unstyled_list do %>
  <% icon_list_item('check-square-o') do %>
    Install the Apache package, <code>httpd</code>, on Red Hat Enterprise Linux systems.
  <% end %>
  <% icon_list_item('check-square-o') do %>
    Start and enable the <code>httpd</code> service.
  <% end %>
  <% icon_list_item('check-square-o') do %>
    Serve a custom home page.
  <% end %>
  <% icon_list_item('check-square-o') do %>
    Open port 80 to incoming traffic.
  <% end %>
<% end %>

You don't need to write additional code to open port 80 because the default configuration handles that.

As your requirements evolve, you can repeat the process by writing additional tests, watching them fail, and then writing just enough code to make them pass.

[END_BOX]

[START_BOX]

## 10. Verify your configuration on a clean instance

As you experiment and correct mistakes, it's a good practice to apply your configuration and run your tests one final time on a clean instance to ensure that the process is repeatable and isn't the result of any experimentation or intermediate steps you performed along the way.

So far, you ran commands such as `kitchen converge`, `kitchen verify`, and `kitchen destroy` to manage your instances.

You can also run the `kitchen test` command to create, converge, verify, and destroy your instance all in one step. Running `kitchen test` is equivalent to running these commands.

```bash
$ kitchen destroy
$ kitchen create
$ kitchen converge
$ kitchen verify
$ kitchen destroy
```

Run `kitchen test` to apply and test your configuration one final time.

<% command_snippet(page: current_page, path: 'verify-on-clean-instance/kitchen-test-1') %>

You see from the output that the tests pass and the configuration is repeatable. Run `kitchen list` to verify that the instance is destroyed.

<% command_snippet(page: current_page, path: 'verify-on-clean-instance/kitchen-list-3') %>

[COMMENT] The `kitchen test` command is also commonly used in automated pipelines because it ensures that the instance is destroyed immediately after `chef-client` completes and all tests are run. When you use a [cloud driver](https://docs.chef.io/kitchen.html#drivers) with Test Kitchen, `kitchen test` can help minimize cost.

[GITHUB] [Get the code for this lesson](https://github.com/learn-chef/webserver_test/tree/lesson1_rhel) on GitHub.

[END_BOX]

<% next_page(current_page) do %>

InSpec is a great way to get fast feedback on whether your cookbook behaves as you expect on a real instance. Next, you'll see how _ChefSpec_ can help us speed up the feedback process even more by simulating a `chef-client` run in memory.

<% end %>
