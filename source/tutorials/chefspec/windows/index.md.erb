---
title: 'Use ChefSpec to verify the correctness of your Windows Server resources'
short_title: 'Windows Server'
platform: Windows Server
platform_id: windows
category: local-development
logo: tests.svg
order: 3
layout: lesson
time_to_complete: 60 minutes
snippet_path: test-your-infrastructure-code/rhel/virtualbox/verify-resources-properly-defined
snippet_workstation: ubuntu
machine_config: snippets/test-your-infrastructure-code/rhel/virtualbox/machine_config.md
environment: virtualbox
headings: [
  { label: 'Prerequisites', href: '#prerequisites' },
  { label: '1. Write tests for current configuration', href: '#step1' },
  { label: '2. Define the CentOS context', href: '#step2' },
  { label: '3. Write tests for Ubuntu', href: '#step3' },
  { label: '4. Revise the cookbook to support Ubuntu', href: '#step4' },
  { label: '5. Refactor the tests', href: '#step5' }
]
---
[HEADLINE] ChefSpec simulates the execution of your resources, giving you an even faster feedback loop as you create and refine your recipes.

In the [Verify with InSpec](/tutorials/inspec/) tutorial, you learned how to use InSpec to automatically verify a basic web server configuration on a virtual machine running on your workstation. Although automated testing is faster than manual testing, it can still take some time for the instance to come up, run `chef-client`, and run the tests.

You'll want to verify your work on a virtual instance before you run your cookbook in production, but as you develop your cookbook, you can use [ChefSpec](https://docs.chef.io/chefspec.html) to speed up the feedback cycle even more. ChefSpec _simulates_ the execution of your resources in memory, and does not involve the creation of a virtual instance. It's the fastest way to test your resources and is a great way to validate the correctness of your work, even before you set up a virtual instance to test on.

[COMMENT] If you're new to automated testing, consider reading [Getting started with automated testing](/skills/get-started-with-testing/) before you start this tutorial.

ChefSpec testing is also helpful when you use [continuous delivery](https://en.wikipedia.org/wiki/Continuous_delivery) (CD) systems such as [Chef Automate](https://www.chef.io/automate/) because ChefSpec enables you to verify your code without the need to bring up additional test systems.

ChefSpec provides a kind of _unit_ testing, where you verify that a single component, such as a Chef resource, functions correctly. Unlike integration testing, unit testing does not focus on how multiple components work together.

ChefSpec testing is most useful when a component's behavior varies based on the environment or other variable input. For example, say you define this `directory` resource to ensure that the <% fp 'C:\Temp' %> directory exists.

```ruby
# default.rb
directory 'C:\Temp' do
  action :create
end
```

You don't need to write a unit test here because this `directory` resource can do only one thing &ndash; create the <% fp 'C:\Temp' %> directory if it does not exist. However, say your `directory` resource reads from a node attribute to determine which directory to create.

```ruby
# default.rb
directory node['temp_path'] do
  action :create
end
```

In this case, you might want to validate that when the `node['temp_path']` attribute is set, that the appropriate directory would be created.

In this tutorial, you'll create a basic cookbook that manages web content. You'll write ChefSpec tests that verify that your web content directory would be created with the required properties &ndash; without the need to run your cookbook on a test instance.

<p>
Here's a 60-minute webcast that discusses ChefSpec in greater depth and shows working examples. You can watch the video before or after you complete this tutorial.
</p>

<script type="text/javascript" src="https://www.brighttalk.com/clients/js/embed/embed.js"></script> <object class="BrightTALKEmbed" width="705" height="660">     <param name="player" value="channel_player"/>     <param name="domain" value="https://www.brighttalk.com"/>     <param name="channelid" value="11349"/>     <param name="communicationid" value="194483"/>     <param name="autoStart" value="false"/>     <param name="theme" value=""/> </object>

<br />
<% accordion('test-configuration', 'Test configuration') do %>

<% markdown do %>

<% render_machine_config(current_page.data.machine_config) %>

<% end %>

<% end %>


[START_BOX]

## 1. Create the web_content cookook

Let's create a cookbook named `web_content`. Start by moving to the <% fp '~/learn-chef' %> directory.

```bash
$ cd ~/learn-chef
```

Next, run the following [chef generate cookbook](https://docs.chef.io/ctl_chef.html#chef-generate-cookbook) command to create the `web_content` cookbook.

```bash
# ~/learn-chef
$ chef generate cookbook cookbooks/web_content
Generating cookbook web_content
- Ensuring correct cookbook file content
- Committing cookbook files to git
- Ensuring delivery configuration
- Ensuring correct delivery build cookbook content
- Adding delivery configuration to feature branch
- Adding build cookbook to feature branch
- Merging delivery content feature branch to master

Your cookbook is ready. To setup the pipeline, type `cd cookbooks/web_content`, then run `delivery init`
```

Finally, move to the cookbook's directory, <% fp 'web_content' %>, for the next part.

```bash
# ~/learn-chef
$ cd ~/learn-chef/cookbooks/web_content
```

## 2. Look at the default test

For ChefSpec, tests go in your cookbook's <% fp 'spec' %> directory. The `chef generate cookbook` command creates this directory for you.

```bash
# ~/learn-chef/cookbooks/web_content
$ tree spec
spec
├── spec_helper.rb
└── unit
    └── recipes
        └── default_spec.rb

2 directories, 2 files
```

```ruby
# ~/learn-chef/cookbooks/web_content/spec/unit/recipes/default_spec.rb
#
# Cookbook:: web_content
# Spec:: default
#
# Copyright:: 2017, The Authors, All Rights Reserved.

require 'spec_helper'

describe 'web_content::default' do
  context 'When all attributes are default, on an unspecified platform' do
    let(:chef_run) do
      runner = ChefSpec::ServerRunner.new
      runner.converge(described_recipe)
    end

    it 'converges successfully' do
      expect { chef_run }.to_not raise_error
    end
  end
end
```

You typically define one test, or spec, file for each recipe. So <% fp 'default_spec.rb' %> maps to the default recipe, <% fp 'default.rb' %>. If you had a second recipe, say <% fp 'firewall.rb' %>, then you would have a spec named <% fp 'firewall_spec.rb' %>.

The `describe` blocks tells ChefSpec to run the `web_content::default` recipe in memory. The `let` block simulates the `chef-client` run. It also defines the `chef_run` variable, which is used in each test to validate the result.

`ChefSpec::ServerRunner` specifies how to run `chef-client` in memory. It's a common option because it also simulates an in-memory Chef server, allowing you to access [data bags](https://docs.chef.io/data_bags.html) and other features.

ChefSpec code resembles InSpec because both are based on the [RSpec](http://rspec.info) testing framework. RSpec [provides two ways to express tests](http://rspec.info/blog/2012/06/rspecs-new-expectation-syntax/). In the [Verify with InSpec](/tutorials/inspec/) tutorial, you use what's commonly called RSpec's _should_ syntax. In this part, you'll use RSpec's _expectation_ syntax.

## 3. Run ChefSpec against the empty cookbook

The default spec comes with one test. The test verifies whether `chef-client` would finish without error.

```ruby
# ~/learn-chef/cookbooks/web_content/spec/unit/recipes/default_spec.rb
it 'converges successfully' do
  expect { chef_run }.to_not raise_error
end
```

Remember that ChefSpec simulates your Chef code in memory. So although ChefSpec cannot tell you whether your system will behave as you expect, knowing that `chef-client` completes without error is a good first step.

From your <% fp '~/learn-chef/cookbooks/web_content' %> directory, run `rspec` to verify that the empty cookbook would run without error.

```bash
#  ~/learn-chef/cookbooks/web_content
$ rspec .
.

Finished in 18.08 seconds (files took 3 seconds to load)
1 example, 0 failures
```

## 4. Specify the platform and platform version

Recall Chef server holds information about your nodes, called _node attributes_, and that your node can access these attributes when `chef-client` runs.

Because ChefSpec simulates your recipes, but does not run them, it needs a way to also simulate access to node attributes. [Ohai](https://docs.chef.io/ohai.html) is the tool that normally detects node attributes and provides them to `chef-client` at the start of every run. To simulate the process, ChefSpec uses [fauxhai](https://github.com/customink/fauxhai). Fauxhai provides _mock_, or test, data for [common platforms](https://github.com/customink/fauxhai/tree/master/lib/fauxhai/platforms).

Fauxhai provides node attributes for [Windows Server 2012 R2](https://github.com/customink/fauxhai/blob/master/lib/fauxhai/platforms/windows/2012R2.json). Although these values might not exactly match your configuration, think of them as test data that you can use to verify the correctness of your resources.

[COMMENT] You can [override](https://github.com/customink/fauxhai#overriding) node attributes in your test code. You can also use [real server data](https://github.com/customink/fauxhai#fetching) or [provide your own attributes file](https://github.com/customink/fauxhai#fixturing).

Tests are grouped in a `context` block. A `context` block groups related tests for a given platform. When you create a `ServerRunner` object, you provide the platform and its version. ChefSpec uses these values to construct [automatic node attributes](https://docs.chef.io/ohai.html#automatic-attributes), for example `node['platform']` and `node['platform_version']`.

Modify your copy of <% fp 'default_spec.rb' %> like this.

```ruby
# ~/learn-chef/cookbooks/web_content/spec/unit/recipes/default_spec.rb
require 'spec_helper'

describe 'web_content::default' do
  context 'On Windows 2012 R2' do
    let(:chef_run) do
      runner = ChefSpec::ServerRunner.new(platform: 'windows', version: '2012R2')
      runner.converge(described_recipe)
    end

    it 'converges successfully' do
      expect { chef_run }.to_not raise_error
    end
  end
end
```

If you wanted to write tests for another platform, for example, Windows Server 2008 R2, you would define a second `context` block. The [Linux version of this tutorial](/tutorials/chefspec/rhel/) shows how to write a single set of tests that can be shared among platforms.

Run `rspec` a second time to verify that the test continues to pass.

```bash
#  ~/learn-chef/cookbooks/web_content
$ rspec .
.

Finished in 0.30837 seconds (files took 2.86 seconds to load)
1 example, 0 failures
```

## 5. Configure the web content directory

Next, let's fill in the `web_content` cookbook's default recipe to configure the web content directory. On a system running Internet Information Services (IIS), it's common to place content in the <% fp 'c:\inetpub\wwwroot' %> directory.

Add the following to your default recipe, <% fp '~/learn-chef/cookbooks/web_content/recipes/default.rb' %>. The [directory](https://docs.chef.io/resource_directory.html) ensures that the <% fp 'c:\inetpub\wwwroot' %> directory exists and that the `IIS_USRS` group has read access. The `recursive` property ensures that any parent directories are also created.

```ruby
# ~/learn-chef/cookbooks/web_content/recipes/default.rb
directory 'c:\inetpub\wwwroot' do
  rights :read, 'IIS_IUSRS'
  recursive true
  action :create
end
```

For this tutorial, we're only concerned with the configuration of the <% fp 'c:\inetpub\wwwroot' %> directory. A more complete solution might copy web content files from a build server or some other location to your web server. You might have a second cookbook that configures IIS or other web server software.

Next, run `rspec` to verify the recipe would run without error.

```bash
#  ~/learn-chef/cookbooks/web_content
$ rspec .
.

Finished in 0.307 seconds (files took 2.1 seconds to load)
1 example, 0 failures
```

You've successfully verified that `chef-client` would run without error.

## 6. Test the directory configuration

Next, you'll write a test that verifies the `directory` resource you just wrote. You'll verify that the <% fp 'c:\inetpub\wwwroot' %> directory would be created, the `IIS_IUSRS` group has read access to that directory, and that any parent directories would also be created.

Modify your default spec to look like this.

```ruby
# ~/learn-chef/cookbooks/web_content/spec/unit/recipes/default_spec.rb
require 'spec_helper'

describe 'web_content::default' do
  context 'On Windows 2012 R2' do
    let(:chef_run) do
      runner = ChefSpec::ServerRunner.new(platform: 'windows', version: '2012R2')
      runner.converge(described_recipe)
    end

    it 'converges successfully' do
      expect { chef_run }.to_not raise_error
    end

    it 'creates a directory with windows rights' do
      expect(chef_run).to create_directory('c:\inetpub\wwwroot')
        .with(
          rights: [{ permissions: :read, principals: 'IIS_IUSRS' }],
          recursive: true
        )
    end
  end
end
```

<% accordion('more-about-expect', 'A closer look at the expect method') do %>

<%= partial 'exception_syntax' %>

<% end %>

Run `rspec` to run your new test.

```bash
#  ~/learn-chef/cookbooks/web_content
$ rspec .
..

Finished in 0.42578 seconds (files took 2.03 seconds to load)
2 examples, 0 failures
```

You see from the output that both tests pass.

## 7. Use a node attribute to make your recipe more flexible

Let's say that multiple teams will use the `web_content` cookbook. Because some teams need to configure their content in a directory other than <% fp 'c:\inetpub\wwwroot' %>, let's use a node attribute to make the cookbook more flexible and reusable.

First, move to the <% fp '~/learn-chef' %> directory.

```bash
# ~/learn-chef/cookbooks/web_content
$ cd ~/learn-chef
```

Next, run this [chef generate attribute](https://docs.chef.io/ctl_chef.html#chef-generate-attribute) command to create a default [attributes file](https://docs.chef.io/attributes.html#use-attribute-files).

```bash
# ~/learn-chef
$ chef generate attribute cookbooks/web_content default
Recipe: code_generator::attribute
  * directory[cookbooks/web_content/attributes] action create
    - create new directory cookbooks/web_content/attributes
  * template[cookbooks/web_content/attributes/default.rb] action create
    - create new file cookbooks/web_content/attributes/default.rb
    - update content in file cookbooks/web_content/attributes/default.rb from none to e3b0c4
    (diff output suppressed by config)
```

Add the following attribute to the default attributes file, <% fp '~/learn-chef/cookbooks/web_content/attributes/default.rb' %>.

```ruby
# ~/learn-chef/cookbooks/web_content/attributes/default.rb
default['web_content']['document_root'] = 'c:\inetpub\wwwroot'
```

Next, modfiy your default recipe to use the node attribute you just created.

```ruby
# ~/learn-chef/cookbooks/web_content/recipes/default.rb
directory node['web_content']['document_root'] do
  rights :read, 'IIS_IUSRS'
  recursive true
  action :create
end
```

It's a common practice to verify that the node attributes you define are used as you expect in your ChefSpec tests. Modify the `let` block in your default spec to explicitly set the `node['web_content']['document_root']` node attribute, like this.

```ruby
# ~/learn-chef/cookbooks/web_content/spec/unit/recipes/default_spec.rb
require 'spec_helper'

describe 'web_content::default' do
  context 'On Windows 2012 R2' do
    let(:chef_run) do
      runner = ChefSpec::ServerRunner.new(platform: 'windows', version: '2012R2') do |node|
        node.override['web_content']['document_root'] = 'c:\inetpub\wwwroot'
      end
      runner.converge(described_recipe)
    end

    it 'converges successfully' do
      expect { chef_run }.to_not raise_error
    end

    it 'creates a directory with windows rights' do
      expect(chef_run).to create_directory('c:\inetpub\wwwroot')
        .with(
          rights: [{ permissions: :read, principals: 'IIS_IUSRS' }],
          recursive: true
        )
    end
  end
end
```

Move to the <% fp 'web_content' %> directory and then run the tests.

```bash
# ~/learn-chef
$ cd ~/learn-chef/cookbooks/web_content
```

```bash
#  ~/learn-chef/cookbooks/web_content
$ rspec .
..

Finished in 0.46295 seconds (files took 2.75 seconds to load)
2 examples, 0 failures
```

You see from the output that the tests continue to pass.

## 8. Resolve a test failure

Let's say that another team is using the `web_content` cookbook to configure a legacy Windows Server system. They require [the IIS_WPG group](https://www.iis.net/learn/get-started/planning-for-security/understanding-built-in-user-and-group-accounts-in-iis), and not `IIS_IUSRS`, to have read access to the content directory.

To illustrate this change, modify your default recipe like this (`IIS_IUSRS` becomes `IIS_WPG`).

```ruby
# ~/learn-chef/cookbooks/web_content/recipes/default.rb
directory 'c:\inetpub\wwwroot' do
  rights :read, 'IIS_WPG'
  recursive true
  action :create
end
```

Run `rspec` to test the change.

```bash
#  ~/learn-chef/cookbooks/web_content
$ rspec .
.F

Failures:

  1) web_content::default On Windows 2012 R2 creates a directory with windows rights
     Failure/Error:
       expect(chef_run).to create_directory('c:\inetpub\wwwroot')
         .with(
           rights: [{ permissions: :read, principals: 'IIS_IUSRS' }],
           recursive: true
         )

       expected "directory[c:\inetpub\wwwroot]" to have parameters:

         rights [{:permissions=>:read, :principals=>"IIS_IUSRS"}], was [{:permissions=>:read, :principals=>"IIS_WPG"}]
       Diff:
       @@ -1,2 +1,2 @@
       -[{:permissions=>:read, :principals=>"IIS_IUSRS"}]
       +[{:permissions=>:read, :principals=>"IIS_WPG"}]
     # ./spec/unit/recipes/default_spec.rb:21:in `block (3 levels) in <top (required)>'

Finished in 0.47839 seconds (files took 3.07 seconds to load)
2 examples, 1 failure

Failed examples:

rspec ./spec/unit/recipes/default_spec.rb:20 # web_content::default On Windows 2012 R2 creates a directory with windows rights
```

The output shows an error. The test expects the `IIS_IUSRS` group to have read access, but the default recipe now specifies `IIS_WPG`.

In practice, this error might be discovered during the development phase or by a continuous delivery system, such as [Chef Automate](https://www.chef.io/automate/). (The [Deploy infrastructure changes](/tutorials/deploy-infrastructure/) tutorial walks you through an example of using Chef Automate's workflow feature to safely move changes from development to production, including running any associated tests.)

After discovering the error, you and your team would make a decision on how to resolve it. You decide that, like the content directory, the group name must be flexible.

To resolve the error, you can create a node attribute that holds the group name, similar to what you did for the web content directory.

Modify your default attributes file like this.

```ruby
# ~/learn-chef/cookbooks/web_content/attributes/default.rb
default['web_content']['document_root'] = 'c:\inetpub\wwwroot'
default['web_content']['username'] = 'IIS_IUSRS'
```

Next, modify your default recipe to use the node attribute you just created, like this.

```ruby
# ~/learn-chef/cookbooks/web_content/recipes/default.rb
directory node['web_content']['document_root'] do
  rights :read, node['web_content']['username']
  recursive true
  action :create
end
```

Next, set the same node attribute in the default spec.

```ruby
# ~/learn-chef/cookbooks/web_content/spec/unit/recipes/default_spec.rb
require 'spec_helper'

describe 'web_content::default' do
  context 'On Windows 2012 R2' do
    let(:chef_run) do
      runner = ChefSpec::ServerRunner.new(platform: 'windows', version: '2012R2') do |node|
        node.override['web_content']['document_root'] = 'c:\inetpub\wwwroot'
        node.override['web_content']['username'] = 'IIS_IUSRS'
      end
      runner.converge(described_recipe)
    end

    it 'converges successfully' do
      expect { chef_run }.to_not raise_error
    end

    it 'creates a directory with windows rights' do
      expect(chef_run).to create_directory('c:\inetpub\wwwroot')
        .with(
          rights: [{ permissions: :read, principals: 'IIS_IUSRS' }],
          recursive: true
        )
    end
  end
end
```

Finally, run `rspec` to verify the changes.

```bash
#  ~/learn-chef/cookbooks/web_content
$ rspec .
..

Finished in 0.44301 seconds (files took 2.03 seconds to load)
2 examples, 0 failures
```

Default node attributes provide sensible default values that can be used in many configurations. In practice, you might use a [wrapper cookbook](https://blog.chef.io/2013/12/03/doing-wrapper-cookbooks-right/) or [role](https://docs.chef.io/roles.html) to override these values.

## 9. Refactor your tests to be more general

Recall that your default spec looks like this.

```ruby
# ~/learn-chef/cookbooks/web_content/spec/unit/recipes/default_spec.rb
require 'spec_helper'

describe 'web_content::default' do
  context 'On Windows 2012 R2' do
    let(:chef_run) do
      runner = ChefSpec::ServerRunner.new(platform: 'windows', version: '2012R2') do |node|
        node.override['web_content']['document_root'] = 'c:\inetpub\wwwroot'
        node.override['web_content']['username'] = 'IIS_IUSRS'
      end
      runner.converge(described_recipe)
    end

    it 'converges successfully' do
      expect { chef_run }.to_not raise_error
    end

    it 'creates a directory with windows rights' do
      expect(chef_run).to create_directory('c:\inetpub\wwwroot')
        .with(
          rights: [{ permissions: :read, principals: 'IIS_IUSRS' }],
          recursive: true
        )
    end
  end
end
```

Your `web_content` cookbook . The intent of your ChefSpec tests aren't to verify that the <% fp 'c:\inetpub\wwwroot' %> directory would be created or that the `IIS_IUSRS` group would have read access. Rather, the intent is to verify that given a set of inputs (node attributes), `chef-client` would produce the expected outputs (resources).

To illustrate this, modify your default spec to use <% fp 'c:\fake_path' %> for the content directory and `fake_group` for the group name. You need to update both the node attributes and the `create_directory` matcher that uses them.

```ruby
# ~/learn-chef/cookbooks/web_content/spec/unit/recipes/default_spec.rb
require 'spec_helper'

describe 'web_content::default' do
  context 'On Windows 2012 R2' do
    let(:chef_run) do
      runner = ChefSpec::ServerRunner.new(platform: 'windows', version: '2012R2') do |node|
        node.override['web_content']['document_root'] = 'c:\fake_path'
        node.override['web_content']['username'] = 'fake_group'
      end
      runner.converge(described_recipe)
    end

    it 'converges successfully' do
      expect { chef_run }.to_not raise_error
    end

    it 'creates a directory with windows rights' do
      expect(chef_run).to create_directory('c:\fake_path')
        .with(
          rights: [{ permissions: :read, principals: 'fake_group' }],
          recursive: true
        )
    end
  end
end
```

Run `rspec` to verify the changes.

```bash
#  ~/learn-chef/cookbooks/web_content
$ rspec .
..

Finished in 0.47645 seconds (files took 3.02 seconds to load)
2 examples, 0 failures
```

Great work! Although it is basic, you now have a web content cookbook that you can build upon. As you add features, you can write additional tests that verify their behavior. Running `rspec` regularly also helps ensure that existing functionality continues to work as you expect.

Although unit testing with ChefSpec may seem redundant, it's a great way to verify the correctness of your resources. This is especially true when the behavior of your resources depend on the environment or other variable input.

You may be interested in reading the [Linux version of this tutorial](/tutorials/chefspec/rhel/), which illustrates other ways you can use ChefSpec that were not covered here.

## Prerequisites

This tutorial builds on the `webserver_test` cookbook that you create in the [Verify with InSpec](/tutorials/inspec/) tutorial. We recommend you work through that tutorial before you begin this one.

If you want to get started right away with this tutorial, or no longer have the code from the previous ones, run this command from the <% fp '~/learn-chef' %> directory to create the `webserver_test` cookbook.

<% command_snippet(workstation: 'ubuntu', path: 'test-your-infrastructure-code/rhel/virtualbox/verify-desired-state/create-the-web-server-cookbook/chef-generate-cookbook') %>

[END_BOX]

[START_BOX]

## 1. Write ChefSpec tests that verify the current web server configuration

Let's begin by writing ChefSpec tests that verify the CentOS web server configuration.

For ChefSpec, tests go in your cookbook's `spec` directory. The `chef generate cookbook` command creates this directory for you.

<% command_snippet(page: current_page, path: 'write-chefspec-tests/tree-spec-dir') %>

You typically define one test, or spec, file for each recipe. So <code class="file-path">default\_spec.rb</code> maps to the default recipe, <code class="file-path">default.rb</code>. If you had a second recipe, say <code class="file-path">firewall.rb</code>, then you would have a spec named <code class="file-path">firewall\_spec.rb</code>.

The default spec that's generated looks like this.

<% code_snippet(page: current_page, path: 'write-chefspec-tests/default_spec-0') %>

The `describe` blocks tells ChefSpec to run the `webserver_test::default` recipe in memory. The `let` block simulates the `chef-client` run. It also defines the `chef_run` variable, which is used in each test to validate the result.

`ChefSpec::ServerRunner` specifies how to run `chef-client` in memory. It's a common option because it also simulates an in-memory Chef server, allowing you to access [data bags](https://docs.chef.io/data_bags.html) and other features.

ChefSpec code resembles InSpec because both are based on the [RSpec](http://rspec.info) testing framework. RSpec [provides two ways to express tests](http://rspec.info/blog/2012/06/rspecs-new-expectation-syntax/). In the [Verify with InSpec](/tutorials/inspec/) tutorial, you use what's commonly called RSpec's _should_ syntax. In this part, you'll use RSpec's _expectation_ syntax.

Modify your copy of <% fp 'default_spec.rb' %> like this.

<% code_snippet(page: current_page, path: 'write-chefspec-tests/default_spec-1') %>

Like InSpec, ChefSpec tests resemble natural language. For example, this test expects the Chef run to install the `httpd` package.

```ruby
# ~/learn-chef/cookbooks/webserver_test/spec/unit/recipes/default_spec.rb
it 'installs httpd' do
  expect(chef_run).to install_package 'httpd'
end
```

The `install_package` part is known as a _matcher_. The [ChefSpec documentation](http://www.rubydoc.info/github/sethvargo/chefspec) lists the matchers that are available for your tests. For example, [ServiceMatchers](http://www.rubydoc.info/github/sethvargo/chefspec/ChefSpec/API/ServiceMatchers) describes the `enable_service` and `start_service` matchers.

[COMMENT] A great way to learn how to write good tests is by example. The ChefSpec project contains [example tests](https://github.com/sethvargo/chefspec/tree/master/examples) for many common Chef resource types.

Now let's run your tests. In the previous lesson, you ran your InSpec tests through Test Kitchen. To run ChefSpec tests, you run a program called [rspec](https://relishapp.com/rspec/rspec-core/docs/command-line).

First, make sure you're in the <% fp 'webserver_test' %> directory.

<% command_snippet(page: current_page, path: 'write-chefspec-tests/cd-webserver_test-2', features: :stdin) %>

Now run this command to run your tests. The [chef exec](https://docs.chef.io/ctl_chef.html#chef-exec) part ensures that `rpsec` is run using Chef's domain-specific language. The `--color` part is optional, but can help you visually distinguish passing from failing tests.

<% command_snippet(page: current_page, path: 'write-chefspec-tests/chef-exec-rspec-1') %>

[COMMENT] If you had multiple ChefSpec files, you would use `chef exec rspec --color spec/unit/recipes/*.rb` or `chef exec rspec --color` to run them all.

You see that no failures were reported. You've successfully validated the first requirement, which is to configure Apache on CentOS.

<% unstyled_list do %>
  <% icon_list_item('check-square-o') do %>
    On CentOS, install the <code>httpd</code> package and enable and start the <code>httpd</code> service.
  <% end %>
  <% icon_list_item('square-o') do %>
    On Ubuntu, install the <code>apache2</code> package and enable and start the <code>apache2</code> service.
  <% end %>
<% end %>

[COMMENT] Remember, ChefSpec only simluates the execution of your resources; it doesn't run the code on a real instance. Unlike the InSpec tests, we can't verify things like whether port 80 would be open or whether `curl localhost` would succeed because ChefSpec does not have that information. ChefSpec tests only what's expressed directly in your code.

<% accordion('more-about-expect', 'A closer look at the expect method') do %>

<%= partial 'exception_syntax' %>

<% end %>
&nbsp;

[END_BOX]

[START_BOX]

## 2. Define the CentOS context

The next step is to write tests for the Ubuntu web server configuration. The Ubuntu tests will resemble the CentOS tests, but will use the `apache2` package and service name instead of `httpd`.

To keep the tests organized by platform, you'll use a _context_ block. You define one context for CentOS and one for Ubuntu. The following example illustrates this structure.

<% code_snippet(page: current_page, path: 'define-the-context/default_spec-2-structure') %>

Before we write tests for Ubuntu, let's first add a context for CentOS. Modify your copy of <% fp 'default_spec.rb' %> like this.

<% code_snippet(page: current_page, path: 'define-the-context/default_spec-2') %>

Notice two differences in this example.

* The tests are grouped in a `context` block. A `context` block groups related tests.
* `ServerRunner` is created by specifying the platform and version. ChefSpec uses these values to construct [automatic node attributes](https://docs.chef.io/ohai.html#automatic-attributes), for example `node['platform']` and `node['platform_version']`.

Recall Chef server holds information about your nodes, called _node attributes_, and that your node can access these attributes when `chef-client` runs.

Because ChefSpec simulates your recipes, but does not run them, it needs a way to also simulate access to node attributes. [Ohai](https://docs.chef.io/ohai.html) is the tool that normally detects node attributes and provides them to `chef-client` at the start of every run. To simulate the process, ChefSpec uses [fauxhai](https://github.com/customink/fauxhai). Fauxhai provides _mock_, or test, data for [common platforms](https://github.com/customink/fauxhai/tree/master/lib/fauxhai/platforms).

For CentOS, to know which value to specify for `version`, you can run `kitchen create` to create a test instance. Then, run this [kitchen exec](https://docs.chef.io/ctl_kitchen.html#kitchen-exec) command to execute `cat /etc/centos-release` on your instance over SSH.

<% command_snippet(page: current_page, path: 'define-the-context/kitchen-exec-centos-release') %>

Fauxhai provides node attributes for [CentOS 7.2.1511](https://github.com/customink/fauxhai/blob/master/lib/fauxhai/platforms/centos/7.2.1511.json). Although these values might not exactly match your configuration, think of them as test data that you can use to verify the correctness of your resources.

[COMMENT] You can [override](https://github.com/customink/fauxhai#overriding) node attributes in your test code. You can also use [real server data](https://github.com/customink/fauxhai#fetching) or [provide your own attributes file](https://github.com/customink/fauxhai#fixturing).

Run the tests to verify that they continue to pass.

<% command_snippet(page: current_page, path: 'define-the-context/chef-exec-rspec-2') %>

The tests still pass.

Next, you'll add a second `context` block that holds the tests for Ubuntu.

[END_BOX]

[START_BOX]

## 3. Write ChefSpec tests for the Ubuntu web server configuration

Now let's repeat the pattern we used with CentOS for the Ubuntu ChefSpec tests.

Begin by adding tests to <% fp 'spec/unit/recipes/default_spec.rb' %> that validate that the proper package and service names are used on both CentOS and Ubuntu. The entire file looks like this.

<% code_snippet(page: current_page, path: 'write-chefspec-tests-for-ubuntu/default_spec-3') %>

Now run the ChefSpec tests, like this.

<% command_snippet(page: current_page, path: 'write-chefspec-tests-for-ubuntu/chef-exec-rspec-3') %>

As you might expect, the CentOS tests pass, but the Ubuntu tests fail.

<% command_snippet(page: current_page, path: 'write-chefspec-tests-for-ubuntu/chef-exec-rspec-4', features: :stdout) %>

The Ubuntu tests fail because the default recipe configures `httpd` unconditionally on all platforms. Your ChefSpec tests expect the recipe to configure `apache2` when run on Ubuntu.

As with InSpec tests, having failing ChefSpec tests shows what functionality is missing and gives you clear goals to work towards.

[END_BOX]

[START_BOX]

## 4. Revise the webserver_test cookbook to support Ubuntu

Let's revise the `webserver_test` cookbook to run on both CentOS and Ubuntu. To do so, we'll define variables that hold the name of the package and service to manage. We'll use the built-in `node['platform']` node attribute to set these variables to their appropriate values.

Modify your `webserver_test` cookbook's default recipe like this.

<% code_snippet(page: current_page, path: 'revise-cookbook-for-ubuntu/default-3-rhel') %>

This code uses a [case](http://ruby-doc.org/docs/keywords/1.9/Object.html#method-i-case) statement to match the platform name to the name of the package and the service. The `package_name` and `service_name` variables are later used in the `package` and `service` resources.

[COMMENT] For learning purposes, we're building a basic multi-platform cookbook from scratch. In practice, you might use the [httpd](https://supermarket.chef.io/cookbooks/httpd) cookbook from Chef Supermarket, which already supports multiple platforms.

Now let's verify whether our updated cookbook passes our ChefSpec tests. We want to see whether the tests for Ubuntu now pass and also verify that the tests for CentOS continue to pass.

<% command_snippet(page: current_page, path: 'revise-cookbook-for-ubuntu/chef-exec-rspec-5') %>

Great! All tests pass. In this example, the entire run took about 2 seconds to complete. This process is much faster than applying the configuration on real CentOS and Ubuntu instances, and is a great way to quickly validate that the resources are properly defined.

[COMMENT] Many users start with InSpec first because it's easy to understand. As you gain familiarity with the various kinds of testing, you might actually write your ChefSpec tests first because ChefSpec tests typically run more quickly, and can help identify potential issues earlier in the process.

[END_BOX]

[START_BOX]

## 5. Refactor the tests to reduce repeated code

Notice that the tests for Ubuntu and CentOS are similar. Each set of tests validates the same concerns. The only difference is the names used for the package and the service.

<% code_snippet(page: current_page, path: 'write-chefspec-tests-for-ubuntu/default_spec-3') %>

If you wanted to add a new test or modify an existing one, you would need to repeat that code for each platform you support. As you include additional platforms, the process can become tedious and error-prone.

Although not required, you might refactor some tests to reduce the amount of repeated code. One way you might refactor these tests is to use a [shared example](http://modocache.io/shared-examples-in-rspec).

A shared example enables you to define reusable test code. Think of a shared example as a template that contains placeholders that are filled in by other tests.

To try it, replace the contents of <% fp 'default_spec.rb' %> with this code.

<% code_snippet(page: current_page, path: 'refactor-reduce-repeated-code/default_spec-4') %>

The `shared_examples` block takes as its arguments the platform name and version, as well as the Apache package and service names. These values are filled in when the tests run.

The `describe` block at the end of this example defines the test data. The `include_examples` method calls the `webserver_test` shared examples two times, once for Ubuntu and once for CentOS.

[COMMENT] `*platform_data` is an example of a [splat](http://www.justinweiss.com/articles/fun-with-keyword-arguments/). A splat extracts the values of an array so they can be used as individual arguments to the `webserver_test` shared examples.

Run ChefSpec to verify that the refactored tests continue to pass.

<% command_snippet(page: current_page, path: 'refactor-reduce-repeated-code/chef-exec-rspec-6') %>

[GITHUB] [Get the code for this lesson](https://github.com/learn-chef/webserver_test/tree/lesson2_rhel) on GitHub.

[END_BOX]

<% next_page(current_page) do %>

In this tutorial, you created a basic web server configuration and used ChefSpec to simulate the execution of your resources in memory. Because ChefSpec does not involve the creation of a virtual instance, it's the fastest way to test your resources and is a great way to validate the correctness of your work. After you have passing ChefSpec tests, you can use another framework such as InSpec to verify that your resources together correctly build the functionality you need.

### Next steps

If you're new to Ruby programming or testing with ChefSpec, one of the best ways to improve your skills is to adapt other examples that you see. The [ChefSpec documentation](https://docs.chef.io/chefspec.html#examples) provides additional examples. The [ChefSpec project page](http://www.rubydoc.info/github/sethvargo/chefspec) contains many more. Learn more about writing great tests and see practical examples at [betterspecs.org](http://betterspecs.org).

Although your code may behave as you expect, it's also important to ensure your code is easy to read and maintain, and avoids defects that can be difficult to fix later. Lint testing, or _linting_, is one way to help ensure that your code adheres to standard style guidelines and avoids common problems. In the [Verify code style](/tutorials/verify-style/) tutorial, you'll use the tools RuboCop and Foodcritic to identify potential issues in variations of the web server cookbook you created here.

Learn more about how to test and debug your Chef code in our [Joy of Automating](/skills/) video series, hosted by Franklin Webber.

If you're involved in your company's compliance and audit process, you may be interested in the [Chef compliance scanner](/tutorials/compliance-assess/rhel/), which uses InSpec as its auditing and testing framework.

You may also be interested in [Chef Automate](https://www.chef.io/automate/), which gives your operations and development teams a common platform for developing, building, testing, and deploying cookbooks, applications, and more. Chef Automate reinforces the Chef workflow, where you begin by developing and testing your configuration from your local workstation. Then, you submit your change to Chef Automate's pipeline, where your change goes through sets of automated tests before going out into production. If you have many different teams, each delivering software in its own way, you can use Chef Automate to bring a standard, proven approach to all of your organization's deployments.

[TRAINING] Ready to dig deeper? Join us in-person or online at an upcoming instructor-led training event. [Learn more about our course offerings](https://www.chef.io/training/) or [check out our upcoming classes](https://www.chef.io/blog/events/category/training-events/). Use discount code **LEARN-CHEF** to save 10%. Use what you've learned to [gain official Chef certification](https://training.chef.io/certification).

<% end %>
