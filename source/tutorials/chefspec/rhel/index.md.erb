---
title: 'Use ChefSpec to verify the correctness of your Linux resources'
short_title: 'Red Hat Enterprise Linux'
platform: Red Hat Enterprise Linux
platform_id: rhel
category: local-development
logo: tests.svg
order: 3
layout: lesson
time_to_complete: 60 minutes
snippet_path: test-your-infrastructure-code/rhel/virtualbox/verify-resources-properly-defined
snippet_workstation: ubuntu
machine_config: snippets/test-your-infrastructure-code/rhel/virtualbox/machine_config.md
environment: virtualbox
headings: [
  { label: 'Prerequisites', href: '#prerequisites' },
  { label: '1. Write tests for current configuration', href: '#step1' },
  { label: '2. Define the CentOS context', href: '#step2' },
  { label: '3. Write tests for Ubuntu', href: '#step3' },
  { label: '4. Revise the cookbook to support Ubuntu', href: '#step4' },
  { label: '5. Refactor the tests', href: '#step5' }
]
---
[HEADLINE] ChefSpec simulates the execution of your resources, giving you an even faster feedback loop as you create and refine your recipes.

In the [Verify with InSpec](/tutorials/inspec/) tutorial, you learned how to use InSpec to automatically verify a basic web server configuration on a virtual machine running on your workstation. Although automated testing is faster than manual testing, it can still take some time for the instance to come up, run `chef-client`, and run the tests.

You'll want to verify your work on a virtual instance before you run your cookbook in production, but as you develop your cookbook, you can use [ChefSpec](https://docs.chef.io/chefspec.html) to speed up the feedback cycle even more. ChefSpec _simulates_ the execution of your resources in memory, and does not involve the creation of a virtual instance. It's the fastest way to test your resources and is a great way to validate the correctness of your work, even before you set up a virtual instance to test on.

[COMMENT] If you're new to automated testing, consider reading [Getting started with automated testing](/skills/get-started-with-testing/) before you start this tutorial.

ChefSpec testing is also helpful when you use [continuous delivery](https://en.wikipedia.org/wiki/Continuous_delivery) (CD) systems such as [Chef Automate](https://www.chef.io/automate/) because ChefSpec enables you to verify your code without the need to bring up additional test systems.

ChefSpec provides a kind of _unit_ testing, where you verify that a single component, such as a Chef resource, functions correctly. Unlike integration testing, unit testing does not focus on how multiple components work together.

ChefSpec testing is most useful when a component's behavior varies based on the environment or other variable input. For example, say you define this `package` resource to install the `vim` text editor.

```ruby
# default.rb
package 'vim' do
  action :install
end
```

You don't necessarily need to write a unit test here because this `package` resource can do only one thing &ndash; install the `vim` package if it's not already installed. However, say your `package` resource reads from a node attribute to determine which text editor to install.

```ruby
# default.rb
package node['text_editor'] do
  action :install
end
```

In this case, you might want to validate that when the `node['text_editor']` attribute is set, that the appropriate text editor would be installed.

In this tutorial, you'll modify the `webserver_test` cookbook to work on both CentOS and Ubuntu. The way Apache is installed and managed differs slightly on both platforms.

Recall that your `webserver_test` cookbook's default recipe looks like this.

<% code_snippet(path: 'test-your-infrastructure-code/rhel/virtualbox/verify-desired-state/make-remaining-tests-pass/default-2-rhel') %>

You know that this configuration works on CentOS. But on Ubuntu, both the Apache package and service names are `apache2`, not `httpd`.

For this part, let's revise the requirements for the web server configuration to focus on these two criteria:

<% unstyled_list do %>
  <% icon_list_item('square-o') do %>
    On CentOS, install the <code>httpd</code> package and enable and start the <code>httpd</code> service.
  <% end %>
  <% icon_list_item('square-o') do %>
    On Ubuntu, install the <code>apache2</code> package and enable and start the <code>apache2</code> service.
  <% end %>
<% end %>

<p>
You need to write code to ensure that your cookbook performs the correct steps in both environments. Here you'll write ChefSpec tests that verify that the code is defined correctly for both platforms &ndash; without the need to run it on a local instance.
</p>

<p>
You'll start by writing ChefSpec tests that verify your existing CentOS web server configuration. Then you'll add additional tests for the same configuration on Ubuntu. After seeing the tests fail, you'll go back to your recipe and add just enough code to make the tests pass.
</p>

<p>
Here's a 60-minute webcast that discusses ChefSpec in greater depth and shows working examples. You can watch the video before or after you complete this tutorial.
</p>

<script type="text/javascript" src="https://www.brighttalk.com/clients/js/embed/embed.js"></script> <object class="BrightTALKEmbed" width="705" height="660">     <param name="player" value="channel_player"/>     <param name="domain" value="https://www.brighttalk.com"/>     <param name="channelid" value="11349"/>     <param name="communicationid" value="194483"/>     <param name="autoStart" value="false"/>     <param name="theme" value=""/> </object>

<br /><br />
<% accordion('test-configuration', 'Test configuration') do %>

<% markdown do %>

<% render_machine_config(current_page.data.machine_config) %>

<% end %>

<% end %>


[START_BOX]

## Prerequisites

This tutorial builds on the `webserver_test` cookbook that you create in the [Verify with InSpec](/tutorials/inspec/) tutorial. We recommend you work through that tutorial before you begin this one.

If you want to get started right away with this tutorial, or no longer have the code from the previous ones, run this command from the <% fp '~/learn-chef' %> directory to create the `webserver_test` cookbook.

<% command_snippet(workstation: 'ubuntu', path: 'test-your-infrastructure-code/rhel/virtualbox/verify-desired-state/create-the-web-server-cookbook/chef-generate-cookbook') %>

[END_BOX]

[START_BOX]

## 1. Write ChefSpec tests that verify the current web server configuration

Let's begin by writing ChefSpec tests that verify the CentOS web server configuration.

For ChefSpec, tests go in your cookbook's `spec` directory. The `chef generate cookbook` command creates this directory for you.

<% command_snippet(page: current_page, path: 'write-chefspec-tests/tree-spec-dir') %>

You typically define one test, or spec, file for each recipe. So <code class="file-path">default\_spec.rb</code> maps to the default recipe, <code class="file-path">default.rb</code>. If you had a second recipe, say <code class="file-path">firewall.rb</code>, then you would have a spec named <code class="file-path">firewall\_spec.rb</code>.

The default spec that's generated looks like this.

<% code_snippet(page: current_page, path: 'write-chefspec-tests/default_spec-0') %>

The `describe` blocks tells ChefSpec to run the `webserver_test::default` recipe in memory. The `let` block simulates the `chef-client` run. It also defines the `chef_run` variable, which is used in each test to validate the result.

`ChefSpec::ServerRunner` specifies how to run `chef-client` in memory. It's a common option because it also simulates an in-memory Chef server, allowing you to access [data bags](https://docs.chef.io/data_bags.html) and other features.

ChefSpec code resembles InSpec because both are based on the [RSpec](http://rspec.info) testing framework. RSpec [provides two ways to express tests](http://rspec.info/blog/2012/06/rspecs-new-expectation-syntax/). In the [Verify with InSpec](/tutorials/inspec/) tutorial, you use what's commonly called RSpec's _should_ syntax. In this part, you'll use RSpec's _expectation_ syntax.

Modify your copy of <% fp 'default_spec.rb' %> like this.

<% code_snippet(page: current_page, path: 'write-chefspec-tests/default_spec-1') %>

Like InSpec, ChefSpec tests resemble natural language. For example, this test expects the Chef run to install the `httpd` package.

```ruby
# ~/learn-chef/cookbooks/webserver_test/spec/unit/recipes/default_spec.rb
it 'installs httpd' do
  expect(chef_run).to install_package 'httpd'
end
```

The `install_package` part is known as a _matcher_. The [ChefSpec documentation](http://www.rubydoc.info/github/sethvargo/chefspec) lists the matchers that are available for your tests. For example, [ServiceMatchers](http://www.rubydoc.info/github/sethvargo/chefspec/ChefSpec/API/ServiceMatchers) describes the `enable_service` and `start_service` matchers.

[COMMENT] A great way to learn how to write good tests is by example. The ChefSpec project contains [example tests](https://github.com/sethvargo/chefspec/tree/master/examples) for many common Chef resource types.

Now let's run your tests. In the previous tutorial, you ran your InSpec tests through Test Kitchen. To run ChefSpec tests, you run a program called [rspec](https://relishapp.com/rspec/rspec-core/docs/command-line).

First, make sure you're in the <% fp 'webserver_test' %> directory.

<% command_snippet(page: current_page, path: 'write-chefspec-tests/cd-webserver_test-2', features: :stdin) %>

Now run this command to run your tests. The [chef exec](https://docs.chef.io/ctl_chef.html#chef-exec) part ensures that `rspec` is run using Chef's domain-specific language. The `--color` part is optional, but can help you visually distinguish passing from failing tests.

<% command_snippet(page: current_page, path: 'write-chefspec-tests/chef-exec-rspec-1') %>

[COMMENT] If you had multiple ChefSpec files, you would use `chef exec rspec --color spec/unit/recipes/*.rb` or `chef exec rspec --color` to run them all.

You see that no failures were reported. You've successfully validated the first requirement, which is to configure Apache on CentOS.

<% unstyled_list do %>
  <% icon_list_item('check-square-o') do %>
    On CentOS, install the <code>httpd</code> package and enable and start the <code>httpd</code> service.
  <% end %>
  <% icon_list_item('square-o') do %>
    On Ubuntu, install the <code>apache2</code> package and enable and start the <code>apache2</code> service.
  <% end %>
<% end %>

[COMMENT] Remember, ChefSpec only simulates the execution of your resources; it doesn't run the code on a real instance. Unlike the InSpec tests, we can't verify things like whether port 80 would be open or whether `curl localhost` would succeed because ChefSpec does not have that information. ChefSpec tests only what's expressed directly in your code.

<% accordion('more-about-expect', 'A closer look at the expect method') do %>

<%= partial 'exception_syntax' %>

<% end %>
&nbsp;

[END_BOX]

[START_BOX]

## 2. Define the CentOS context

The next step is to write tests for the Ubuntu web server configuration. The Ubuntu tests will resemble the CentOS tests, but will use the `apache2` package and service name instead of `httpd`.

To keep the tests organized by platform, you'll use a _context_ block. You define one context for CentOS and one for Ubuntu. The following example illustrates this structure.

<% code_snippet(page: current_page, path: 'define-the-context/default_spec-2-structure') %>

Before we write tests for Ubuntu, let's first add a context for CentOS. Modify your copy of <% fp 'default_spec.rb' %> like this.

<% code_snippet(page: current_page, path: 'define-the-context/default_spec-2') %>

Notice two differences in this example.

* The tests are grouped in a `context` block. A `context` block groups related tests.
* `ServerRunner` is created by specifying the platform and version. ChefSpec uses these values to construct [automatic node attributes](https://docs.chef.io/ohai.html#automatic-attributes), for example `node['platform']` and `node['platform_version']`.

Recall Chef server holds information about your nodes, called _node attributes_, and that your node can access these attributes when `chef-client` runs.

Because ChefSpec simulates your recipes, but does not run them, it needs a way to also simulate access to node attributes. [Ohai](https://docs.chef.io/ohai.html) is the tool that normally detects node attributes and provides them to `chef-client` at the start of every run. To simulate the process, ChefSpec uses [fauxhai](https://github.com/customink/fauxhai). Fauxhai provides _mock_, or test, data for [common platforms](https://github.com/customink/fauxhai/tree/master/lib/fauxhai/platforms).

For CentOS, to know which value to specify for `version`, you can run `kitchen create` to create a test instance. Then, run this [kitchen exec](https://docs.chef.io/ctl_kitchen.html#kitchen-exec) command to execute `cat /etc/centos-release` on your instance over SSH.

<% command_snippet(page: current_page, path: 'define-the-context/kitchen-exec-centos-release') %>

Fauxhai provides node attributes for [CentOS 7.2.1511](https://github.com/customink/fauxhai/blob/master/lib/fauxhai/platforms/centos/7.2.1511.json). Although these values might not exactly match your configuration, think of them as test data that you can use to verify the correctness of your resources.

[COMMENT] You can [override](https://github.com/customink/fauxhai#overriding) node attributes in your test code. You can also use [real server data](https://github.com/customink/fauxhai#fetching) or [provide your own attributes file](https://github.com/customink/fauxhai#fixturing).

Run the tests to verify that they continue to pass.

<% command_snippet(page: current_page, path: 'define-the-context/chef-exec-rspec-2') %>

The tests still pass.

Next, you'll add a second `context` block that holds the tests for Ubuntu.

[END_BOX]

[START_BOX]

## 3. Write ChefSpec tests for the Ubuntu web server configuration

Now let's repeat the pattern we used with CentOS for the Ubuntu ChefSpec tests.

Begin by adding tests to <% fp 'spec/unit/recipes/default_spec.rb' %> that validate that the proper package and service names are used on both CentOS and Ubuntu. The entire file looks like this.

<% code_snippet(page: current_page, path: 'write-chefspec-tests-for-ubuntu/default_spec-3') %>

Now run the ChefSpec tests, like this.

<% command_snippet(page: current_page, path: 'write-chefspec-tests-for-ubuntu/chef-exec-rspec-3') %>

As you might expect, the CentOS tests pass, but the Ubuntu tests fail.

<% command_snippet(page: current_page, path: 'write-chefspec-tests-for-ubuntu/chef-exec-rspec-4', features: :stdout) %>

The Ubuntu tests fail because the default recipe configures `httpd` unconditionally on all platforms. Your ChefSpec tests expect the recipe to configure `apache2` when run on Ubuntu.

As with InSpec tests, having failing ChefSpec tests shows what functionality is missing and gives you clear goals to work towards.

[END_BOX]

[START_BOX]

## 4. Revise the webserver_test cookbook to support Ubuntu

Let's revise the `webserver_test` cookbook to run on both CentOS and Ubuntu. To do so, we'll define variables that hold the name of the package and service to manage. We'll use the built-in `node['platform']` node attribute to set these variables to their appropriate values.

Modify your `webserver_test` cookbook's default recipe like this.

<% code_snippet(page: current_page, path: 'revise-cookbook-for-ubuntu/default-3-rhel') %>

This code uses a [case](http://ruby-doc.org/docs/keywords/1.9/Object.html#method-i-case) statement to match the platform name to the name of the package and the service. The `package_name` and `service_name` variables are later used in the `package` and `service` resources.

[COMMENT] For learning purposes, we're building a basic multi-platform cookbook from scratch. In practice, you might use the [httpd](https://supermarket.chef.io/cookbooks/httpd) cookbook from Chef Supermarket, which already supports multiple platforms.

Now let's verify whether our updated cookbook passes our ChefSpec tests. We want to see whether the tests for Ubuntu now pass and also verify that the tests for CentOS continue to pass.

<% command_snippet(page: current_page, path: 'revise-cookbook-for-ubuntu/chef-exec-rspec-5') %>

Great! All tests pass. In this example, the entire run took about 2 seconds to complete. This process is much faster than applying the configuration on real CentOS and Ubuntu instances, and is a great way to quickly validate that the resources are properly defined.

[COMMENT] Many users start with InSpec first because it's easy to understand. As you gain familiarity with the various kinds of testing, you might actually write your ChefSpec tests first because ChefSpec tests typically run more quickly, and can help identify potential issues earlier in the process.

[END_BOX]

[START_BOX]

## 5. Refactor the tests to reduce repeated code

Notice that the tests for Ubuntu and CentOS are similar. Each set of tests validates the same concerns. The only difference is the names used for the package and the service.

<% code_snippet(page: current_page, path: 'write-chefspec-tests-for-ubuntu/default_spec-3') %>

If you wanted to add a new test or modify an existing one, you would need to repeat that code for each platform you support. As you include additional platforms, the process can become tedious and error-prone.

Although not required, you might refactor some tests to reduce the amount of repeated code. One way you might refactor these tests is to use a [shared example](http://modocache.io/shared-examples-in-rspec).

A shared example enables you to define reusable test code. Think of a shared example as a template that contains placeholders that are filled in by other tests.

To try it, replace the contents of <% fp 'default_spec.rb' %> with this code.

<% code_snippet(page: current_page, path: 'refactor-reduce-repeated-code/default_spec-4') %>

The `shared_examples` block takes as its arguments the platform name and version, as well as the Apache package and service names. These values are filled in when the tests run.

The `describe` block at the end of this example defines the test data. The `include_examples` method calls the `webserver_test` shared examples two times, once for Ubuntu and once for CentOS.

[COMMENT] `*platform_data` is an example of a [splat](http://www.justinweiss.com/articles/fun-with-keyword-arguments/). A splat extracts the values of an array so they can be used as individual arguments to the `webserver_test` shared examples.

Run ChefSpec to verify that the refactored tests continue to pass.

<% command_snippet(page: current_page, path: 'refactor-reduce-repeated-code/chef-exec-rspec-6') %>

[GITHUB] [Get the code for this tutorial](https://github.com/learn-chef/webserver_test/tree/lesson2_rhel) on GitHub.

[END_BOX]

<% next_page(current_page) do %>

In this tutorial, you created a basic web server configuration and used ChefSpec to simulate the execution of your resources in memory. Because ChefSpec does not involve the creation of a virtual instance, it's the fastest way to test your resources and is a great way to validate the correctness of your work. After you have passing ChefSpec tests, you can use another framework such as InSpec to verify that your resources together correctly build the functionality you need.

### Next steps

If you're new to Ruby programming or testing with ChefSpec, one of the best ways to improve your skills is to adapt other examples that you see. The [ChefSpec documentation](https://docs.chef.io/chefspec.html#examples) provides additional examples. The [ChefSpec project page](http://www.rubydoc.info/github/sethvargo/chefspec) contains many more. Learn more about writing great tests and see practical examples at [betterspecs.org](http://betterspecs.org).

Although your code may behave as you expect, it's also important to ensure your code is easy to read and maintain, and avoids defects that can be difficult to fix later. Lint testing, or _linting_, is one way to help ensure that your code adheres to standard style guidelines and avoids common problems. In the [Verify code style](/tutorials/verify-style/) tutorial, you'll use the tools RuboCop and Foodcritic to identify potential issues in variations of the web server cookbook you created here.

Learn more about how to test and debug your Chef code in our [Joy of Automating](/skills/) video series, hosted by Franklin Webber.

If you're involved in your company's compliance and audit process, you may be interested in the [Chef compliance scanner](/tutorials/compliance-assess/rhel/), which uses InSpec as its auditing and testing framework.

You may also be interested in [Chef Automate](https://www.chef.io/automate/), which gives your operations and development teams a common platform for developing, building, testing, and deploying cookbooks, applications, and more. Chef Automate reinforces the Chef workflow, where you begin by developing and testing your configuration from your local workstation. Then, you submit your change to Chef Automate's pipeline, where your change goes through sets of automated tests before going out into production. If you have many different teams, each delivering software in its own way, you can use Chef Automate to bring a standard, proven approach to all of your organization's deployments.

[TRAINING] Ready to dig deeper? Join us in-person or online at an upcoming instructor-led training event. [Learn more about our course offerings](https://www.chef.io/training/) or [check out our upcoming classes](https://www.chef.io/blog/events/category/training-events/). Use discount code **LEARN-CHEF** to save 10%. Use what you've learned to [gain official Chef certification](https://training.chef.io/certification).

<% end %>
