---
id: packer-chef
title: 'Create a Windows Server 2016 Vagrant box with Chef and Packer'
description: 'Learn how to use Chef and Packer to create a Windows Server 2016 Vagrant box.'
order: 6
category: 'example-workflows'
icon: devops-diverse-skills.png
---

written by Matt Wrock

This article will show you how to use [Chef](https://www.chef.io/) and [Packer](https://www.packer.io/) to create a Windows Server 2016 [Vagrant](https://www.vagrantup.com/) box. It will also explain how to deal with the "gotchas" that I ran into. The actual template can be found on GitHub, [here](https://github.com/mwrock/packer-templates/blob/master/vbox-2016.json).

This article assumes that you know what Packer is and have a basic understanding of Packer templates and Windows unattended installation. You can [have a look at my blog post](http://www.hurryupandwait.io/blog/creating-windows-base-images-for-virtualbox-and-hyper-v-using-packer-boxstarter-and-vagrant) for more details on those topics.

If you want to skip to the end, I have uploaded both Hyper-V and VirtualBox providers to [Atlas](https://atlas.hashicorp.com/mwrock/boxes/Windows2016) and you can use them with Vagrant via:


```bash
$ vagrant init mwrock/Windows2016
$ vagrant up
```
[START_BOX]

##Initial steps
There are a couple things that need to happen before we can use one of Packer's Chef provisioners and our Chef recipes can run. We need to deal with cookbook dependencies and we need to configure WinRM correctly.

[END_BOX]

[START_BOX]

##Dealing with cookbook dependencies

I've broken down most of the scripts that I use in a Packer run into various Chef recipes that are encapsulated in a single cookbook called packer-templates, which I include in my Packer template repository. Either of Packer's Chef provisioners will copy this cookbook to the image being built but what about other cookbooks that my packer-templates cookbook depends on? My cookbook uses the [windows cookbook](https://github.com/chef-cookbooks/windows), the [wsus-client](https://github.com/criteo-cookbooks/wsus-client) cookbook, the dependencies that they have, and so on, but Packer does not expose any mechanism for discovering those cookbooks and downloading them.

Well, there is a well-known tool that solves these problems: [Berkshelf](http://berkshelf.com/). I ran ``berks vendor`` to discover the correct dependencies and their versions and downloaded them locally to vendor/cookbooks, which we exclude from source control:

```bash
C:\dev\packer-templates [master]> cd .\cookbooks\packer-templates\
C:\dev\packer-templates\cookbooks\packer-templates [master]> berks vendor ../../vendor/cookbooks
Resolving cookbook dependencies...
Fetching 'packer-templates' from source at .
Fetching cookbook index from https://supermarket.chef.io...
Using chef_handler (1.4.0)
Using windows (1.44.1)
Using packer-templates (0.1.0) from source at .
Using wsus-client (1.2.1)
Vendoring chef_handler (1.4.0) to ../../vendor/cookbooks/chef_handler
Vendoring packer-templates (0.1.0) to ../../vendor/cookbooks/packer-templates
Vendoring windows (1.44.1) to ../../vendor/cookbooks/windows
Vendoring wsus-client (1.2.1) to ../../vendor/cookbooks/wsus-client
```


I included both my packer-templates cookbook and the vendored, dependent cookbooks in the chef-solo provisioner (more about this later) definition:

```ruby
# vbox-2016.json
"provisioners": [
{
  "type": "chef-solo",
  "cookbook_paths": ["cookbooks", "vendor/cookbooks"],
  "guest_os_type": "windows",
  "run_list": [
    "wsus-client::configure",
    ...
```

[END_BOX]

[START_BOX]

##Configuring WinRM

As we will find as we make our way to a completed Vagrant .box file, there are a few key places where we need to change some machine state outside of Chef. The first of these is configuring WinRM. Before you can use any provisioner, WinRM must be configured correctly. The Go WinRM library cannot authenticate via NTLM so we must enable Basic Authentication and allow unencrypted traffic. Note that my template removes these settings prior to shutting down the VM, before the image is exported, since my testing scenarios have NTLM authentication available.

Since we cannot configure these settings from a provisioner, we configure them in the VM build step. We add a script to the <FirstLogonCommands> section of our [Windows answer file](https://github.com/mwrock/packer-templates/blob/master/answer_files/2016/Autounattend.xml). This file automates the initial install of Windows so we are not prompted to enter things like admin password, locale, or timezone:

```html
<!-- Autounattend.xml -->
<FirstLogonCommands>
  <SynchronousCommand wcm:action="add">
     <CommandLine>cmd.exe /c C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -File a:\winrm.ps1</CommandLine>
     <Order>1</Order>
  </SynchronousCommand>
</FirstLogonCommands>
```


The [winrm.ps1](https://github.com/mwrock/packer-templates/blob/master/scripts/winrm.ps1) script looks like this:

```ruby
# winrm.ps1
netsh advfirewall firewall add rule name="WinRM-HTTP" dir=in localport=5985 protocol=TCP action=allow
winrm set winrm/config/service/auth '@{Basic="true"}'
winrm set winrm/config/service '@{AllowUnencrypted="true"}'
```


As soon as this runs on our Packer build, Packer will detect that WinRM is accessible and will move on to provisioning.

[END_BOX]

[START_BOX]

##Choosing a Chef provisioner

There are two Chef-flavored provisioners that come with Packer: [chef-solo](https://www.packer.io/docs/provisioners/chef-solo.html) and [chef-client](https://www.packer.io/docs/provisioners/chef-client.html). The chef-client provisioner is ideal if you store your cookbooks on a Chef server. However, since I am storing the cookbook along with the Packer templates that will be copied to the image, I am using the chef-solo provisioner.

The provisioner installs the Chef client on the Windows VM and then converges all recipes included in the run-list specified in the template:

```ruby
# vbox-2016.json
"provisioners": [
  {
    "type": "chef-solo",
    "cookbook_paths": ["cookbooks", "vendor/cookbooks"],
    "guest_os_type": "windows",
    "run_list": [
      "wsus-client::configure",
      "packer-templates::install_ps_modules",
      "packer-templates::vbox_guest_additions",
      "packer-templates::uninstall_powershell_ise",
      "packer-templates::delete_pagefile"
    ]
  },
```

[END_BOX]

[START_BOX]

##Windows updates and other WinRM unfriendly tasks

The Chef provisioner invokes the Chef client via WinRM and all of the [restrictions of WinRM](http://www.hurryupandwait.io/blog/safely-running-windows-automation-operations-that-typically-fail-over-winrm-or-powershell-remoting) apply here. That means no Windows updates, no installing .Net, no installing SQL Server and a few other edge case restrictions.

We can work around these restrictions by isolating these unfriendly commands and running them directly via the Packer PowerShell provisioner, which is set to run as "elevated":

```ruby
# vbox-2016.json
{
  "type": "powershell",
  "script": "scripts/windows-updates.ps1",
  "elevated_user": "vagrant",
  "elevated_password": "vagrant"
},
```

The provisioner's elevated credentials allow the PowerShell script to run via a scheduled task. The result is that the script runs in the context of a local user, free from the fetters of WinRM. We start by converging a Chef run-list with just enough configuration to set things up. This includes turning off automatic updates with the <code class="file-path">wsus-client::configure</code> recipe so that manually running updates will not interfere with automatic updates kicked off by the VM. The initial run-list also installs the [PSWindowsUpdate](https://gallery.technet.microsoft.com/scriptcenter/2d191bcd-3308-4edd-9de2-88dff796b0bc) module, which we will use in the PowerShell provisioner.

Here is the [install-ps-modules.rb](https://github.com/mwrock/packer-templates/blob/master/cookbooks/packer-templates/recipes/install_ps_modules.rb) recipe that installs the Nuget package provider so we can install the PSWindowsUpdate module and the other DSC modules we will need during our packer build:

```ruby
# install-ps-modules.rb
powershell_script 'install Nuget package provider' do
  code 'Install-PackageProvider -Name NuGet -Force'
  not_if '(Get-PackageProvider -Name Nuget -ListAvailable -ErrorAction SilentlyContinue) -ne $null'
end

%w{PSWindowsUpdate xNetworking xRemoteDesktopAdmin xCertificate}.each do |ps_module|
  powershell_script "install #{ps_module} module" do
    code "Install-Module #{ps_module} -Force"
    not_if "(Get-Module #{ps_module} -list) -ne $null"
  end
end
```

The windows-updates.ps1 looks like this:

```ruby
# windows-updates.ps1
Get-WUInstall -WindowsUpdate -AcceptAll -UpdateType Software -IgnoreReboot
```

The Windows updates are another place where we change state outside of Chef.

[END_BOX]

[START_BOX]

##Multiple Chef provisioning blocks

After Windows updates, I move back to Chef to finish off the provisioning:

```ruby
# vbox-2016.json
{
  "type": "chef-solo",
  "remote_cookbook_paths": [
    "c:/windows/temp/packer-chef-client/cookbooks-0",
    "c:/windows/temp/packer-chef-client/cookbooks-1"
  ],
  "guest_os_type": "windows",
  "skip_install": "true",
  "run_list": [
    "packer-templates::enable_file_sharing",
    "packer-templates::remote_desktop",
    "packer-templates::clean_sxs",
    "packer-templates::add_postunattend",
    "packer-templates::add_pagefile",
    "packer-templates::set_local_account_token_filter_policy",
    "packer-templates::remove_dirs",
    "packer-templates::add_setup_complete"
  ]
},
```

A couple important things to include when you run the Chef provisioner more than once is to tell it not to install Chef and to reuse the cookbook directories it used on the first run.

For some reason, the Chef provisioner downloads and installs Chef even when it's already installed. To prevent this, use ``skip_install: true``. Also, on the first Chef run, Packer copied the cookbooks from your local environment to the VM. When it copies these cookbooks on subsequent attempts, it's incredibly slow (several minutes). I'm assuming this is due to file checksum checking logic in the Go WinRM library. You can avoid this sluggish file copy by just referencing the remote cookbook paths set up by the first run with the ``remote_cookbook_paths`` array shown above.

[END_BOX]

[START_BOX]

##Cleaning up

Once the image configuration is what you want, you might (or might not) want to remove the Chef client. I try to optimize my Packer setup for minimal size and the Chef client is rather large (a few hundred MB). Now, you can't remove Chef with Chef. What kind of sick world would that be? So we use the PowerShell provisioner again to remove the client:

```ruby
# cleanup.ps1
Write-Host "Uninstall Chef..."
if(Test-Path "c:\windows\temp\chef.msi") {
  Start-Process MSIEXEC.exe '/uninstall c:\windows\temp\chef.msi /quiet' -Wait
}
```



and then clean up the disk before it's exported and compacted into its final .box file:

```ruby
# provision.ps1
Write-Host "Cleaning Temp Files"
try {
  Takeown /d Y /R /f "C:\Windows\Temp\*"
  Icacls "C:\Windows\Temp\*" /GRANT:r administrators:F /T /c /q  2>&1
  Remove-Item "C:\Windows\Temp\*" -Recurse -Force -ErrorAction SilentlyContinue
} catch { }

Write-Host "Optimizing Drive"
Optimize-Volume -DriveLetter C

Write-Host "Wiping empty space on disk..."
$FilePath="c:\zero.tmp"
$Volume = Get-WmiObject win32_logicaldisk -filter "DeviceID='C:'"
$ArraySize= 64kb
$SpaceToLeave= $Volume.Size * 0.05
$FileSize= $Volume.FreeSpace - $SpacetoLeave
$ZeroArray= new-object byte[]($ArraySize)

$Stream= [io.File]::OpenWrite($FilePath)
try {
   $CurFileSize = 0
    while($CurFileSize -lt $FileSize) {
        $Stream.Write($ZeroArray,0, $ZeroArray.Length)
        $CurFileSize +=$ZeroArray.Length
    }
}
finally {
    if($Stream) {
        $Stream.Close()
    }
}

Del $FilePath
```

[END_BOX]

[START_BOX]

##What just happenned?

All of the Chef recipes, PowerShell scripts and Packer templates can be cloned from my [packer-templates github repo](https://github.com/mwrock/packer-templates), but in summary, this is what they all did:

* Installed Windows
* Installed all Windows updates
* Turned off automatic updates
* Installed VirtualBox guest additions (only in [vbox-2016.json](https://github.com/mwrock/packer-templates/blob/master/vbox-2016.json) template)
* Uninstalled Powershell ISE (I dont use this)
* Removed the page file from the image (it will recreate itself on ``vagrant up``)
* Removed all Windows featured not enabled
* Enabled file sharing firewall rules so you can map drives to the VM
* Enabled Remote Desktop and its firewall rule
* Cleaned up the windows SxS directory of update backup files
* Set the LocalAccountTokenFilterPolicy so that local users can remote to the VM via NTLM
* Removed junk files and folders
* Wiped all unused space on disk (might seem weird but makes the final compressed .box file smaller)

Most of this was done with Chef resources and we were also able to make ample use of DSC. For example, here is our [remote_desktop.rb](https://github.com/mwrock/packer-templates/blob/master/cookbooks/packer-templates/recipes/remote_desktop.rb) recipe:


```ruby
# remote_desktop.rb
dsc_resource "Enable RDP" do
  resource :xRemoteDesktopAdmin
  property :UserAuthentication, "Secure"
  property :ensure, "Present"
end

dsc_resource "Allow RDP firewall rule" do
  resource :xfirewall
  property :name, "Remote Desktop"
  property :ensure, "Present"
  property :enabled, "True"
end
```
[END_BOX]

[START_BOX]

##Testing provisioning recipes with Test-Kitchen

One thing I've found very important is to be able to test Packer provisioning scripts outside of an actual Packer run. Remember that, even if you pare down your provisioning scripts to almost nothing, a Packer run will always have to run through the initial Windows install. That's going to be several minutes. Then after the Packer run, you must wait for the image export and if you are using the Vagrant post-provisioner, it's going to be several more minutes while the .box file is compressed. So being able to test your provisioning scripts in an isolated environment that can be spun up relatively quickly can save quite a bit of time.

I have found that working on a Packer template includes three stages:

1.	Creating a very basic box with next to no configuration
2.	Testing provisioning scripts in a premade VM
3.	A full Packer run with the provisioning scripts

There may be some permutations of this pattern. For example, I might remove Windows Update until the very end.

[Test Kitchen](http://kitchen.ci/) comes in real handy in step 2. You can also use the box produced by step 1 in your Test Kitchen run. Depending on if I'm building a Hyper-V or a VirtualBox provider, I'll go about this differently. Either way, a simple call to ``kitchen converge`` can be much faster than ``packer build``.

##Using kitchen-hyperv to test scripts on Hyper-V

The [.kitchen.yml](https://github.com/mwrock/packer-templates/blob/master/cookbooks/packer-templates/.kitchen.yml) file included in my [packer-templates repo](https://github.com/mwrock/packer-templates) uses the kitchen-hyperv driver to test my Chef recipes that provision the image:

```yaml
# .kitchen.yml
---
driver:
  name: hyperv
  parent_vhd_folder: '../../output-hyperv-iso/virtual hard disks'
  parent_vhd_name: packer-hyperv-iso.vhdx
```


If I'm using a [hyperv builder](https://github.com/test-kitchen/kitchen-hyperv) to first create a minimal image, Packer puts the build .vhdx file in output-hyperv-iso/virtual hard disks. I can use kitchen-hyperv and point it at that image and it will create a new VM using that vhdx file as the parent of a new differencing disk where I can test my recipes. I can then have test-kitchen run these recipes in just a few minutes or less, which is a much tighter feedback loop than Packer provides.

[END_BOX]

[START_BOX]

##Using kitchen-vagrant to test on Virtualbox

If you create a .box file with a minimal Packer template, it will output that .box file in the root of the packer-template repo. You can add that box to your local vagrant repo by running:

```bash
$ vagrant box add 2016 .\windows2016min-virtualbox.box
```

Now you can test against this with a test-kitchen driver config that looks like this:

```yaml
# .kitchen.yml
driver:
  name: vagrant
  box: 2016
```
[END_BOX]
