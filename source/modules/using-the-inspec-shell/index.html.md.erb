---
id: using-the-inspec-shell
description: "Explore the InSpec DSL and how to use the InSpec shell to develop controls iteratively."
title: 'Using the InSpec shell'
short_title: 'Using the InSpec shell'
platform: Ubuntu
platform_id: ubuntu
category: local-development
type: topic
time_to_complete: 60 minutes
quiz_path: quizzes/using-the-inspec-shell.yml
headings: [
  { label: 'Prerequisites', href: '#prerequisites' },
  { label: 'Learn basic commands and syntax', href: '#learnbasiccommandsandsyntax' },
  { label: 'Explore InSpec resources', href: '#exploreinspecresources' },
  { label: 'Examine a remote system', href: '#examinearemotesystem' },
]
---
[START_BOX]

In this module, we will explore the InSpec language and uses of the [InSpec shell](https://www.inspec.io/docs/reference/shell/). InSpec is its own domain specific language (DSL) that is based on the Ruby DSL.  The InSpec language has a strongly controlled vocabulary and syntax, which simplifies test design and increases the ease of writing code through elegant and formulaic expressions.

## Prerequisites

[TIP] This module follows [Using community compliance profiles](/modules/using-community-profiles/). You may wish to continue working with the same system from the previous module, if it is still available. You will also have the material you will need to start a new system.

In this module, you will use Test Kitchen and InSpec with virtual machines using VirtualBox and Vagrant.

1. **VirtualBox** is a [hypervisor](https://en.wikipedia.org/wiki/Hypervisor) used to running virtual machine instances.
1. **Vagrant** help you configure virtual machines using a [Vagrantfile](https://www.vagrantup.com/docs/vagrantfile/), that makes specifying and loading virtual machines consistent and reproducible.
1. **ChefDK** If you do not already have the Chef Development Kit installed, you will need to install it.  You can find directions in the [Get started with Test Kitchen](/modules/local-development) module. You can also jump right in and [download the ChefDK](https://downloads.chef.io/chefdk).

[END_BOX]

[START_BOX]

## Learn basic commands and syntax

Follow these steps to find out more about InSpec resources and how to use them.

1. Enter `inspec help shell` for commands and options about the shell.

    ```bash
    $ inspec help shell

    ```

1. Enter `inspec shell` to launch the shell.

    ```bash
    $ inspec shell

    Welcome to the interactive InSpec Shell
    To find out how to use it, type: help
    ```

1. Enter `help` for help within the shell.

    ```bash
    # InSpec Shell
    $ inspec> help

    ```

1. Enter `help resources` for a list of resources.

    ```bash
    # InSpec Shell
    $ inspec> help resources

    ```

The design of an InSpec control and its tests follow a consistent pattern. In the simplest form, a control may be described as:

  ```ruby
  # InSpec Example Syntax
  describe <RESOURCE> do
      it/its(<SERVICE/SETTING>)
          { should <MATCHER>(<STATE>) }
      end
  end
  ```

Resources, generally speaking, are software, configurations, and sometimes data that are created when software is installed.  InSpec supports auditing of services, settings, and information.

InSpec has a large number of resources available for your use.  For more information about using these resources, see the [InSpec Resources Reference](https://www.inspec.io/docs/reference/resources/) page:


You can also find out more about resources in the InSpec shell with `help RESOURCE`.


### Matchers

InSpec uses the syntax of `should + MATCHER` to define the manner of assessment in a test.  These are:

* **be**
    is used for comparing numerical values:

    ```bash
    # Matcher "be" Examples
    describe file('hello.txt') do
      its('size') { should be = 10 } # The file should be 10.
      its('size') { should be > 10 } # The file should be greater than 10.
      its('size') { should be >= 10 } # The file should be greater than or equal to 10.
      its('size') { should be < 10 } # The file should be less than 10.
      its('size') { should be <= 10 } # The file should be less than 10.
    for negation, use should_not
      its('size') { should be_not be > 10 } # The file should not be greater than 10.
    end
    ```
* **eq**
    is used to test the equality of two values.

    The `eq` compared value must be the desired value, meaning that values passed as strings will only match strings and values passed as numbers will only match numbers.

    ```bash
    # Matcher "eq" examples
    describe ssh_config
       its('Protocol') { should eq 2 } # The protocol should only equal 2.
    end

    describe file('hello.txt') do
       its('name') { should eq 'foo.txt' } # The file name should equal 'foo.txt'.  This test will fail.
    end
    ```

* **cmp**
    is used to compare two values, such as strings to numbers, or a single value to an array.

      `cmp` allows for more flexibility than matchers such as `be` or `eq`.  `cmp` can allow for comparing different values while also ignoring case sensitivity.

    ```bash
    # Matcher "cmp" Example
    describe ssh_config do
       its('Protocol') { should cmp '2' } # This example compares strings to numbers
       its('Protocol') { should cmp 2 }
    end
    ```

* **include**
    is used to verify that a string is included in a list.

    ```bash
    # Matcher "include" Examples
    describe passwd do
      its('users') { should include 'myuser' } # 'myuser' should be in the list of users.
    end

    describe passwd do
      its('users') { should_not include 'useruser' } # 'useruser' should not be in the list of users.
    end
    ```

* **match**
    is used to check if a string matches a regular expression.

    ```bash
    # Matcher "match" examples
    describe file('hello.txt') do
      its('name') { should match /hello/ } # The name should match for the regex /hello/.
    end

    describe sshd_config do
      its('Ciphers') { should_not match /cbc/ } # The cipher should be anything other than the regex /cbc/.
    end
    ```

Look at the inspec github for more information about [matchers](https://github.com/chef/inspec/blob/master/docs/matchers.md).

## Explore InSpec resources

To understand InSpec resources, try using the `file` resource.

1. Use the `help file` command to find out about the resource.

    ```bash
    $ inspec shell
    $ inspec> help file

    Name: file

    Description:

    Use the file InSpec audit resource to test all system file types, including files, directories, symbolic links, named pipes, sockets, character devices, block devices, and doors.

    Example:

    describe file('path') do
      it { should exist }
      it { should be_file }
      it { should be_readable }
      it { should be_writable }
      it { should be_executable.by_user('root') }
      it { should be_owned_by 'root' }
      its('mode') { should cmp '0644' }
    end


    Web Reference:

    https://github.com/chef/inspec/blob/master/docs/resources.rst#file

    ```

1. You can write controls directly in the InSpec shell, which is useful for both troubleshooting and developing tests.

    If you write a control that tests for the existence of a file named 'hello.txt' the shell, InSpec will search the current directory for that file. The output of is similar to the output of a control run with the `inspec exec`` command.

    Try testing for the existence of a file by writing a control directly in the InSpec shell.

    ```bash
    # InSpec Shell
    $ inspec> describe file('hello.txt') do
    $ inspec> it { should exist }
    $ inspec> end

    Profile: inspec-shell
    Version: unknown

     File hello.txt
        ✔  should exist

    Test Summary: 1 successful, 0 failures, 0 skipped
    ```

    This test may also be written as in one line, as:

    ```bash
    # InSpec Shell
    describe file('hello.txt') do it { should exist } end
    ```

1. If the test fails, it is because the file does not exist on your system.

    Use `exit` to leave the InSpec shell, then, from your workstations terminal, type `echo "hello world" > hello.txt`. After creating the file with the echo command, enter `inspec shell` to return to the InSpec command line.

    Finally, enter the control again (you can use the up arrow key), `describe file('hello.txt') do it { should exist } end`, and watch the controls pass the test.

    ```bash
    $ inspec> exit
    $ echo "hello world" > hello.txt
    $ inspec shell

    Welcome to the interactive InSpec Shell
    To find out how to use it, type: help

    $ inspec> describe file('hello.txt') do it { should exist } end

    Profile: inspec-shell
    Version: unknown

      File hello.txt
         ✔  should exist

    Test Summary: 1 successful, 0 failures, 0 skipped
    ```

1. If your control contains more than one test, you can concatenate them using ";". For example:

    ```bash
    # InSpec Shell
    $ inspec> describe file('hello.txt') do it { should exist }; its('content') { should match /hello/ } end

    Profile: inspec-shell
    Version: unknown

      File hello.txt
         ✔  should exist
         ✔  content should match /hello/

    Test Summary: 2 successful, 0 failures, 0 skipped
    ```

## Examine a remote system

1. For this part of the module, you will need to log onto a Ubuntu 14.04 virtual machine.

    If you created one during [Learn the InSpec basics](/modules/learn-the-inspec-basics/), you can use that.

    Otherwise, the instructions in the next two steps can show you how to do that if you have not already completed the earlier module.

    ```bash
    $ cd ~/learn-inspec
    $ vagrant init bento/ubuntu-14.04

    ```

1. Open the Vagrantfile `~/learn-inspec/Vagrantfile` in your editor.

    Delete the contents of the Vagrantfile and replace it with the following code:

    ```ruby
    # ~/learn-inspec/Vagrantfile
    # encoding: utf-8
    # -*- mode: ruby -*-
    # vi: set ft=ruby :

    $script == <<SCRIPT
    sudo apt-get update
    sudo apt-get install -y curl
    curl https://omnitruck.chef.io/install.sh | sudo bash -s -- -P chefdk
    sudo apt-get install tree --yes
    >>SCRIPT

    Vagrant.configure(2) do |config|

      config.vm.define "server" do |cs|
        cs.vm.box = "bento/ubuntu-14.04"
        cs.vm.hostname = "server.test"
        cs.vm.provision "shell", inline: $script
      end
    end
    ```

1. Restart the machine using the new Vagrantfile and connect to the server.

    ```bash
    # ~/learn-inspec
    $ vagrant up --provision
    $ vagrant ssh server

    Welcome to Ubuntu 14.04.5 LTS (GNU/Linux 3.13.0-112-generic x86_64)

     * Documentation:  https://help.ubuntu.com/

      System information as of Wed May 10 23:00:59 UTC 2017

      System load:  0.07              Processes:           89
      Usage of /:   3.0% of 38.02GB   Users logged in:     0
      Memory usage: 7%                IP address for eth0: 10.0.2.15
      Swap usage:   0%

      Graph this data and manage this system at:
        https://landscape.canonical.com/

     ```

1. Once you're connected to your virtual machine, examine the 'passwd' entries using `cat /etc/passwd`.

    This will allow you to view all of the users--which includes services--allowed on the system.
    The `passwd` audit resource tests the contents of `/etc/passwd`. A `passwd` entry looks like:

    ```bash
    # vagrant@server
    vagrant@server: ~$ cat /etc/passwd

    root:x:0:0:root:/root:/bin/bash
    daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
    bin:x:2:2:bin:/bin:/usr/sbin/nologin
    sys:x:3:3:sys:/dev:/usr/sbin/nologin
    sync:x:4:65534:sync:/bin:/bin/sync
    games:x:5:60:games:/usr/games:/usr/sbin/nologin
    man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
    ...
    ```

    A generic example of a `passwd` entry might be:

    ```bash
    root:x:1234:5678:additional_info:/home/dir/:/bin/bash
    ```

    The parts of this `passwd` entry are:

    ```bash
    - A user name (`users`): 'root' (from the above example)
    - The password (`passwords`) for that user 'x'
    - The user identifier (`uid`) assigned to the user  '1234'
    - The group identifier (`gid`) assigned to the user '5678'
    - Additional user information   'additional_info'
    - The user's home directory (`home`)  '/home/dir/'
    - The user's default command shell (`shell`)   '/bin/bash'
    ```

1. Using the InSpec shell, you can retrieve summaries of all the passwd users with `passwd.entries`.

    Another way to view all of the users in passwd is to use `passwd.lines`. You can also search for specific components of an entry with home, gids, passwords, shells, uids, and users, all of which are valid accessors for passwd. Not all of the keys in a passwd.entries are filterable, but `gids`, `homes`, `passwords`, `shells`, `uids`, and `users` may all be used as filtering criteria. To view the output of all of the user elements, try:

    ```bash
    # InSpec Shell
    $ inspec> passwd.entries
    => [#<struct
      user="root",
      password="x",
      uid="0",
      gid="0",
      desc="root",
      home="/root",
      shell="/bin/bash",
      count=nil,
      usernames=nil,
      username=nil,
      content=nil>,
    :q
    ```

    At the `:` enter return to continue examining the output and enter `q` to quit.

1. You can retrieve information from `passwd` by asking for keys, or by searching for specific values.

    Try out some of these:

    ```bash
    # InSpec Shell
    passwd.gids
    passwd.where{ gid == "1" }.entries
    ```

    ```bash
    # InSpec Shell
    passwd.homes
    passwd.where{ user = "sbin" }.entries
    ```

    ```bash
    # InSpec Shell
    passwd.passwords # (if it shows 'x' they are stored in the shadow directory)
    {passwd.where{ password == "x" }.entries
    ```
    ```bash
    # InSpec Shell
    passwd.shells
    passwd.where{ shell = "bash"}.entries
    ```

    ```bash
    # InSpec Shell
    passwd.uids
    passwd.where{ uid == "1"}.entries
    ```

    ```bash
    # InSpec Shell
    passwd.users
    passwd.where{ users == "root"}.entries
    ```

1. You can also use `params` instead of `entries` to view the results of filtering entire records.

    `params` outputs a map of all the key/value pairs from the user information. However, you may sometimes need only one of the keys from a filtered user entry, sometimes you may only need one key from the filtered list. For example, to retrieve all of the user ids of users with bash shells, try:

    ```bash
    # InSpec Shell
    passwd.where{ shell == "/bin/bash" }.uids
    ```

    InSpec has many resources that allow querying. Some of the other resources that allow querying are `crontab`, `groups`, `packages`, `port`, `processes`, `ssl`, `users`, `xinetd`, and `docker`.

    See the [documentation](https://www.inspec.io/docs/reference/resources/) for querying strategies.

1. You can use InSpec Shell to manually enter a single test from the command line:

    ```bash
    # InSpec Shell
    $ inspec> describe passwd do its('users') { should_not include 'forbidden_user' } end
    ```

1. Use ';' to chain multiple tests in a single shell line:

    ```bash
    # InSpec Shell
    $ inspec> describe passwd.uids(0) do its('users') { should cmp 'root' } ;
     its('entries.length') { should eq 1 } end
    ```

[END_BOX]

[START_BOX]

## Conclusion

In this module, you got a brief overview of the InSpec shell. The InSpec shell is powerful and elegant tool for developing, testing and exploring your systems.

[TRAINING] Ready to dig deeper? Join us in-person or online at an upcoming instructor-led training event. [Learn more about our course offerings](https://www.chef.io/training/) or [check out our upcoming classes](https://www.chef.io/blog/events/category/training-events/). Use discount code **LEARN-CHEF** to save 10%. Use what you've learned to [gain official Chef certification](https://training.chef.io/certification).

[END_BOX]
