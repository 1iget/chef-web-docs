---
id: learn-the-inspec-basics
description: "Learn the basics of InSpec including how to write controls, scan remote systems, and more."
name: learn-the-inspec-basics
title: 'Learn the InSpec basics'
short_title: 'Learn the InSpec basics'
type: topic
platform: Ubuntu
platform_id: ubuntu
category: compliance-automation
time_to_complete: 60 minutes
quiz_path: quizzes/learn-the-inspec-basics.yml
headings: [
  { label: 'Prerequisites', href: '#prerequisites' },
  { label: 'Write a basic test', href: '#writeabasicinspectest' },
  { label: 'Add a second test', href: '#addasecondtest' },
  { label: 'Scan a remote system', href: '#scanaremotesystem' },
  { label: 'Create a profile', href: '#createaprofile' },
  { label: 'Scan for compliance', href: '#scanforcompliance' },
  { label: 'Make your profile more reusable', href: '#makeyourprofilemorereusable' },
  { label: 'Conclusion', href: '#conclusion' }
]
---
Compliance is an emerging and exciting area of automation. Compliance means that your systems conform to the standards or regulations that you need to follow in your work. Fortunately, you can use a great Chef product--InSpec--to ensure that your infrastructure operates and follows the rules and regulations of your company and industry. Compliance as code automates auditing processes, saving money, time, and most importantly, your relationships with customers and stakeholders.

InSpec is short for "infrastructure specification", which is exactly what InSpec allows you to do. InSpec allows you to _specify_, or define and automate infrastructure, integration, and compliance testing, ensuring that your systems and processes adhere to government, industry,  and company standards.

## Prerequisites

Before starting this module, you need to have the following installed on your workstation:

* VirtualBox <https://www.virtualbox.org/> is a "hypervisor" program, which means that it manages virtual machine installations. Each running virtual machine is called an "instance".
* Vagrant <https://www.vagrantup.com/downloads.html> makes working with hypervisor programs easier by using a configuration file, called a `Vagrantfile`  that defines a the structure of a virtual machine, such as available memory, host name, and network setting using a sort of template. This template can be re-used for launching as many copies of a vm instance as you need, as many times as you need.
Vagrant also provides access to base virtual machine images, called _boxes_. [HashiCorp's Atlas](https://www.hashicorp.com/atlas.html) is a place where you can access prebuilt boxes or upload new boxes for others to use. [Bento](http://chef.github.io/bento/) is a Chef project that provides ready-to-use Vagrant boxes for many common platforms, including Ubuntu.
* ChefDK (includes InSpec) <https://downloads.chef.io/chefdk> provides tools that enable you to manage your servers remotely from your workstation. But it also provides tools that allow you to configure a machine directly.
* You will need the `tree` utility installed on your workstation. To check if `tree` is installed, enter `which tree` into the command line. If it is not found, then you will need to install it on your workstation using homebrew <https://brew.sh/>. If `which brew` does not return a file location, install homebrew by copying `/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"` into your prompt. After successfully loading homebrew, install the `tree` utility by entering `brew install tree`.

This module is written for a macOS or Linux workstation and an Ubuntu 14.04 virtual machine running on Vagrant and VirtualBox. However, it can be adapted to most systems running the ChefDK and connecting to a second machine that also runs the ChefDK.

### Concepts

These are the concepts that you will learn about in this module:

* Audit - Comprehensive review of an organization's adherence to regulator guidelines. Some of the areas that an audit examines are security policies, user access controls, and risk management procedures.
* Compliance - When a system runs according to a defined set of rules it is in compliance. 'Compliance' can be used to describe technological processes as well as organizations that run in accordance with government, industry, or company policies.
* Policy - A policy is the purpose of a set of compliance tests as well as the outline of the tests themselves.
* Control - The expression of practices for auditing settings and processes in code, which are stored within a control file in and InSpec profile.
* Scanning and remote scanning - Running compliance tests against a local or remote computer.
* Profiles -  A collection of tests stored in one or more control to designed to satisfy a compliance policy. In InSpec, the profile is the structure in which controls are coded.

## Write a basic InSpec test

Now that you have the ChefDK, VirtualBox, and Vagrant installed, it is time to write your first control. First, make a directory named `learn-inspec` and navigate into that directory. Your first task will be to write an InSpec control file that contains a single control, testing the existence of a file. You will follow the behavior-driven-development practice of writing a test that fails, and then writing just enough code to make it pass.

```bash
# ~/
$ mkdir learn-inspec
$ cd learn-inspec
```

### Scenario: our “hello world” example
From the `learn-inspec` directory on your workstation you will write your first inspec control file, which contains a single control that tests for the existence of a file.

1. Use the `touch` command to create the `hello_spec.rb` file. Then save the file.

    ```bash
    # ~/learn-inspec
    $ touch 'hello_spec.rb'
    ```

1. With the editor of your choice, open 'hello_spec.rb' and copy the following code into the file:

    ```ruby
    # ~/learn-inspec/hello_spec.rb
    control "world-1.0" do
    impact 1.0
    title "hello world"

    desc "'hello.txt' should be a file"
      describe file ('hello.txt') do
        it { should exist }
      end
    end
    ```

#### What are the elements of a control file?

The control file contains a remarkable amount of information in a very brief format. Let's break it down:

* control - the declaration that this is a control object and a brief, easily identifiable about what it handles.
* impact - On a scale of 1 to 10, the severity of consequences should the control fail.
* title - A longer title for the control.
* desc - A short description what the test should do.
* describe - The code for the location of file or setting that will be tested, followed by the test.

### Test your machine using the control file.

[TIP] If you are running tests within a control but not running an entire InSpec profile, you will need to run the 'exec' command from the same directory as the test.

1. From the `learn-inspec` directory command line prompt, run your control using the `inspec exec` command.

    ```bash
    # ~/learn-inspec
    $ inspec exec hello_spec.rb

    Target:  local://

      ✖  world-1.0: hello world (expected File hello.txt to exist)
         ✖  File hello.txt should exist
         expected File hello.txt to exist

         Profile Summary: 0 successful, 1 failures, 0 skipped
    ```

    The output shows you the name of the control and what the test expected to see happen, citing the specific control that failed. The 'Profile Summary' shows a tally of all the controls in the profile, based on their status as successful, failures, or skipped tests. A failing test will appear in red letters. This particular failing result shows you both that the test ran as it should have and that the `hello.txt` file does not exist in the directory.

    To make the test pass, you will create a `hello.txt` file in this directory and then use `inspec exec` to run the test. The output should show the test passing.

1. Touch the file in order to create it.

    ```bash
    # ~/learn-inspec
    $ touch hello.txt
    $ inspec exec hello_spec.rb
    ```
1. Run the test using `inspec exec`.

    ```bash
    # ~/learn-inspec
    $ inspec exec hello_spec.rb

    Target:  local://

      ✔  world-1.0: hello world
         ✔  File hello.txt should exist

         Profile Summary: 1 successful, 0 failures, 0 skipped
    ```

## Add a second test

An InSpec control may contain more than one test; however, it is advisable that all of the tests in a single control connect to the subject of the control. Likewise, a profile can have more than one control, but all of these controls should relate directly to the purpose of the profile.

In this excercise, you will edit the control file to include a second test that will look at the contents of a file. You will run the control file tests using `inspec exec` and see the new test fail. Then, you will write just enough code to make the both tests in the control file pass.

1. Open `~/learn-inspec/hello_spec.rb` and add a test to the control that checks if "hello world" is in the file.

    ```ruby
    # ~/learn-inspec/hello_spec.rb
    control "world-1.0" do
      impact 1.0
      title "hello world"

      desc "'hello.txt' should be a file"
      describe file ('hello.txt') do
        it { should exist }
      end

      desc "hello.txt should contain the phrase 'hello world'"
      describe file ('hello.txt') do
        its ('content') { should match /hello world/ }
      end
    end
    ```

1. Run the test using `inspec exec` from the command line.

    You should show the second test failing because the hello.txt file is currently empty.

    ```bash
     # ~/learn-inspec
     $ inspec exec hello_spec.rb

      Target:  local://

      ×  world-1.0: hello world (1 failed)
         ✔  File hello.txt should exist
         ×  File hello.txt content should include "hello world"
         expected "" to include "hello world"

         Profile Summary: 0 successful, 1 failures,      0 skipped
         Test Summary: 1 successful, 1 failures, 0 skipped
      ```

1. Add the expected phrase "hello world" into the file and re-run the tests using `inspec exec`.

    This time, you should see both tests pass.

     ```bash
     # ~/learn-inspec
     $ echo "hello world" > hello.txt && inspec exec hello_spec.rb

     Target:  local://

     ✔  world-1.0: hello world
       ✔  File hello.txt should exist
       ✔  File hello.txt content should include "hello world"

       Profile Summary: 1 successful, 0 failures, 0 skipped
       Test Summary: 2 successful, 0 failures, 0 skipped
    ```

## Scan a remote system

While InSpec can be used to verify that your local system conforms to your specifications, you can also use it to test your remote systems. In this exercise, you will create a virtual machine and scan it with your `hello_spec.rb` control, writing just enough code to make the tests pass on the remote virtual machine.

If you have not already done so, download and install both VirtualBox and Vagrant. Once you have VirtualBox and Vagrant installed, you will move to your `learn-inspec` directory and initialize a virtual machine using Vagrant. The workflow is to initialize a virtual machine and place a configuration file, called a `Vagrantfile`, into the directory. Once the virtual machine is up and running, you will change the Vagrantfile file and restart the virtual machine.

1. Initialize Vagrant by entering `vagrant init bento/ubuntu-14.04` into the command line.

    Initializing Vagrant will take a while. It will creates an environment for your virtual machine and places a configuration file, called a Vagrantfile, into the `learn-inspec` directory.

    ```bash
    # ~/learn-inspec
    $ vagrant init bento/ubuntu-14.04
    ```

1. Open the Vagrantfile, which will be found in `~/learn-inspec/Vagrantfile`, in your editor.

    Delete the contents of the Vagrantfile and replace it with the following code:

    ```ruby
    # learn-inspec/Vagrantfile
    # This is the first Vagrantfile ubuntu server needed in the module.

    # encoding: utf-8
    # -*- mode: ruby -*-
    # vi: set ft=ruby :

    $script = <<SCRIPT
    sudo apt-get update
    sudo apt-get install -y curl
    curl https://omnitruck.chef.io/install.sh |  sudo bash -s -- -P chefdk
    sudo apt-get install tree --yes
    SCRIPT

    Vagrant.configure(2) do |config|

      config.vm.define "server" do |cs|
        cs.vm.box = "bento/ubuntu-14.04"
        cs.vm.hostname = "server.test"
        cs.vm.provision "shell", inline: $script
      end
    end
    ```

1. Restart the machine using the new Vagrantfile.

    ```bash
    #~/learn-inspec
    $ vagrant up --provision
    ```

    Additional commands such as `vagrant halt` command will stop the virtual machine, and `vagrant destroy` will stop and remove a virtual machine from your system.

1. Exploring your new virtual machine.

    By using, `vagrant global-status`, you are able to see all of virtual machines that are running on your system. This command provides the a uniqe id, assigned name, provider(hypervisor), state, and directory for each machine:

    ```bash
    # ~/learn-inspec
    $ vagrant global-status

    id       name   provider   state   directory
    -----------------------------------------------------------------------
    b8548e4  server    VirtualBox running  /Users/yourname/learn-inspec

    ```

    The virtual machine that you just created should be named "server".

1. Look up the forwarded port information and make note of it.

    You will need this number later in this exercise.

    Your port information will look like this, but perhaps with different guest and host numbers. Please make note of the four digit host number:

    ```bash
    # ~/learn-inspec
    $ vagrant port server

    The forwarded ports for the machine are listed below. Please note that these values may differ from values configured in the Vagrantfile if the provider supports automatic port collision detection and resolution.

        22 (guest) => 2222 (host)

    ```

1. Open virtual machine using the `vagrant ssh NAME` command.

    In this case the command will be `vagrant ssh server`. To close the ssh connection, just type `exit`.

    ```bash
    # ~/learn-inspec
    $ vagrant ssh server

    Welcome to Ubuntu 14.04.5 LTS (GNU/Linux 3.13.0-112-generic x86_64)

     * Documentation:  https://help.ubuntu.com/

      System information as of Tue May  9 18:41:10 UTC 2017

      System load:  0.22              Processes:           90
      Usage of /:   4.3% of 38.02GB   Users logged in:     0
      Memory usage: 6%                IP address for eth0: 10.0.2.15
      Swap usage:   0%

      Graph this data and manage this system at:
       https://landscape.canonical.com/

       Last login: Mon May  8 17:21:37 2017 from 10.0.2.2

       ```

1. Now test your virtual machine with the control that you wrote earlier in this module.

    You will run the control using `inspec exec` and passing a `target` option, as shown in the following code example. After running the control, you should see both tests fail. The tests failed because neither the "hello.text" file nor its contents exist on the virtual machine.

    ```bash
    # ~/learn-inspec
    $ inspec exec hello_spec.rb --target=ssh://vagrant:vagrant@localhost:2222

      Target:  ssh://vagrant@localhost:2222

        ×  world-1.0: hello world (2 failed)
           ×  File hello.txt should exist
           expected File hello.txt to exist
           ×  File hello.txt content should  include "hello world"
           expected nil to include "hello world", but it does not respond to `include?`
    ```

1. To remediate the failing tests, open up your virtual machine and create both the file and its contents.

    Once you are finished, `exit` your virtual machine.

    ```bash
    # ~/learn-inspec
    $ vagrant ssh server

    Welcome to Ubuntu 14.04.5 LTS (GNU/Linux 3.13.0-112-generic x86_64)

     * Documentation:  https://help.ubuntu.com/

      System information as of Tue May  9 18:58:53 UTC 2017

      System load:  0.0               Processes:           81
      Usage of /:   4.3% of 38.02GB   Users logged in:     0
      Memory usage: 17%               IP address for eth0: 10.0.2.15
      Swap usage:   0%

      Graph this data and manage this system at:
       https://landscape.canonical.com/

    $ vagrant@server echo "hello world" > hello.txt
    $ vagrant@server exit
    ```

1. In your `learn-inspec` directory, re-run the control targeting your virtual machine.

    Use `inspec exec hello_spec.rb --target=ssh://vagrant:vagrant@localhost:YOUR-PORT-NUM.`

    You should see both of controls succeeding, meaning that the control both found the file specified in the first test and the file contents specified in the second test.


     ```bash
     # ~/learn-inspec
     $ inspec exec hello_spec.rb --target=ssh://vagrant:vagrant@localhost:2222

     Target:  ssh://vagrant@localhost:2222

     ✔  world-1.0: hello world
        ✔  File hello.txt should exist
        ✔  File hello.txt content should include "hello world"

        Profile Summary: 1 successful, 0 failures, 0 skipped
        Test Summary: 2 successful, 0 failures, 0 skipped
     ```

### Testing in Different Environments

InSpec offers you the ability to run your tests in a variety of environments, not only test local machines and remote vagrant machines, but also other sorts of remote machines, such as with SSH or WinRM. Here are a few examples of how to test different remote environments:

**Test Locally:**

```bash
$ inspec exec test.rb
```

**Test a machine remotely via SSH:**

```bash
$ inspec exec test.rb -identity.key -t ssh://root@172.17.0.1
```

**Test a machine remotely via WinRM:**

```bash
$ inspec exec test.rb -t  winrm://Admin@192.168.1.2 --password super
```

**Test a Docker Container:**

```bash
$ inspec exec test.rb -t docker//containerid
```

**Database Testing:**

```ruby
describe myssql_session.query("SELECT user,host FROM mysql.user WHERE host = '%'") do
  its{:stdout" { should be empty }"}8
end
```

**Cloud Provider Testing**

```ruby
security_groups.each do |security_group|
   describe security_group do
     it {should_not_have_inbound_rule().with_source('0.0.0.0/0')}
   end
end
```

## Create a Profile

Up until now, your InSpec file structure has been flat, meaning that you have created controls and files all in the same place. In this exercise, you will convert your stand-alone control into an InSpec profile, which is a useful framework for creating and storing InSpec test and compliance profiles, for the purpose of organizing controls to support dependency management and code reuse.  Each profile is a standalone structure with its own distribution and execution flow.

You will start off by creating an InSpec profile for your hello_spec.rb control.  You will then learn to run your tests both locally and remotely by running your new profile.

1. View help for `inspec help init` to examine its usage.

    ```bash
    # ~/learn-inspec
    $ inspec help init
    Commands:
    inspec init help [COMMAND]  # Describe subcommands or one s...
    inspec init profile NAME    # Create a new profile
    ```

1. Enter `inspec init help profile` to view the use of profiles.

    ```bash
    # ~/learn-inspec
    $ inspec init help profile

    Usage:
     inspec init profile NAME

    Options:
     [--overwrite], [--no-overwrite]  # Overwrites existing directory

    Create a new profile
    ```

1. Enter `inspec init profile profile-1` to create a profile named "profile-1".

    ```bash
    # ~/learn-inspec
    $ inspec init profile profile-1

    Create new profile at /Users/kimberlygarmoe/inspec/profile-1
    * Create directory controls
    * Create file controls/example.rb
    * Create file inspec.yml
    * Create directory libraries
    * Create file README.md
    * Create file libraries/.gitkeep
    ```
1. View your working directory with `pwd`.

    ```bash
    # ~/learn-inspec
    $ pwd
    /Users/yourname/learn-inspec
    ```
1. View the contents of your working directory, using `tree`.

    ```bash
    # ~/learn-inspec
    $ tree
    ├── profile-1
    │   ├── README.md
    │   ├── controls
    │   │   ├── example.rb
    │   │   ├── hello_spec.rb
    │   │   ├── profile.rb
    │   │   └── sshd.rb
    │   ├── hello.txt
    │   ├── inspec.lock
    │   ├── inspec.yml
    │   └── libraries
    ```

    You will see that the profile-1 profile is a directory.

1. Change to the profile-1 directory and view its contents with 'tree'.

    ```bash
    # ~/learn-inspec
    $ cd profile-1
    $ tree

    profile-1 tree
    .
    ├── README.md
    ├── controls
    │   ├── example.rb
    │   ├── hello_spec.rb
    │   ├── profile.rb
    │   └── sshd.rb
    ├── hello.txt
    ├── inspec.lock
    ├── inspec.yml
    └── libraries

    2 directories, 9 files
    ```

    A profile must have both the inspec.yml, which has metadata describing the profile, and the controls directory, which contains all of the tests. The README.md, which explains the profile, its scope and usage, and its libraries directories, which is where all of the InSpec resource extensions would be located, are optional.

1. Examine the README with `cat README.md`.

    ```bash
    # ~/learn-inspec/profile-1
    $ cat README.md

    # Example InSpec Profile

    This example shows the implementation of an InSpec [profile](../../docs/profiles.rst).
    ```

1. Change into the `controls` directory and examine the contents:

    ```bash
    # ~/learn-inspec/profile-1
    $ cd controls
    $ ls

    example.rb

    $ cat example.rb

    inspec
          encoding: utf-8
         # copyright: 2015, The Authors
         # license: All rights reserved

         title 'sample section'

         # you can also use plain tests
         describe file('/tmp') do
           it { should be_directory }
         end

         # you add controls here
         control 'tmp-1.0' do                        # A unique ID for this control
           impact 0.7                                # The criticality, if this control fails.
           title 'Create /tmp directory'             # A human-readable title
           desc 'An optional description...'
           describe file('/tmp') do                  # The actual test
             it { should be_directory }
           end
         end
    ```

1. Return to the "profile-1" directory and examine the inspec.yml.

    ```bash
    # ~/learn-inspec/profile-1/controls
    $ cd ..
    $ cat inspec.yml
      name: PROFILE
      title: InSpec Profile
      maintainer: The Authors
      copyright: The Authors
      copyright_email: you@example.com
      license: All Rights Reserved
      summary: An InSpec Compliance Profile
      version: 0.1.0
    ```

    The inspec.yml contains the metadata for your profile, some of which is required for the profile to run.

    ```bash
    # inspec.yml fields
    - "name": The projects name (REQUIRED).
    - "title": The profile human-readable name.
    - "maintainer": Who is responsible for keeping the profile up-to-date.
    - "copyright": copyright holder.
    - "copyright_email": support contact information for the profile, typically an email address.
    - "license": The kind of license that the profile has.
    - "summary": One line about the profile.
    - "description": Mulitple line description of the profile
    - "version": The profile version.
    - "supports": What platforms the profile will target.
       -  os-name ubuntu
          release: 14.04
    - "depends": The list of other profiles on which this profile depends.
       -  name: inspec
          path: /Users/username/inspec
   ```

1. Move the `hello_spec` control that your wrote earlier in this lesson into the `controls` directory.

    You will use the `mv FILE NEW_LOCATION` command.

    ```bash
    # ~/learn-inspec/profile-1
    $ cd controls
    $ mv ~/learn-inspec/hello_spec.rb ~/learn-inspec/profile-1/controls/
    $ tree

    .
    ├── example.rb
    ├── hello_spec.rb
    ```

    Notice that 'hello.txt' is still in the `~/inspec` directory. InSpec profiles are used to test for the existence of the file outside of the directory in which the controls are situated.

1. Learn about the `inspec.yml` by changing it.

    Return to the `profile-1` directory.

    ```bash
    # ~/learn-inspec/profile-1/controls
    $ cd ..
    $ pwd
    ~/Users/yourname/learn-inspec/profile-1
    ```

    Open `inspec.yml` in the editor of your choice and remove the "version" line, so that it looks like:

    ```ruby
    # ~/learn-inspec/profile-1/inspec.yml
    name: profile-1
    title: InSpec Profile
    maintainer: The Authors
    copyright: The Authors
    copyright_email: you@example.com
    license: All Rights Reserved
    summary: An InSpec Compliance Profile
    ```

1. You will need to run the profile-1 profile and its tests, from a higher-level directory.

    Change directories back into the `learn-inspec` directory and run `inspec check profile-1` to verify this control.

    Notice that it errors out because the version metadata is missing from the `inspec.yml` file.

    ```bash
    # ~/learn-inspec
    $ cd ..
    $ inspec check profile-1

    Location:    profile-1
    Profile:     profile-1
    Controls:    3
    Timestamp:   2017-03-30T23:33:57+00:00
    Valid:       false

    ✖  hello/inspec.yml:0:0: Missing profile version in inspec.yml

    Summary:     1 errors, 0 warnings

    ```
1. Run `inspec check profile-1` to test how the metadata works.

    You should see the profile failing.

    ```bash
    # ~/learn-inspec
    $ inspec check profile-1
    Location:    profile-1
    Profile:     profile-1
    Controls:    3
    Timestamp:   2017-04-12T13:55:45-07:00
    Valid:       false

      ✖  profile-1/inspec.yml:0:0: Missing profile version in inspec.yml

    Summary:     1 errors, 0 warnings
   ```
    The output shows the test failing, but it also provides a lot of important information.

    ```bash
    # InSpec Check Explanation
    The output to the command shows:
       * the location of the tests
       * the name of the profile used
       * the total number of controls in the profile (3)
          * 1 control in profile-1/controls/example.rb
          * 2 controls in profile-1/hello_spec.
       * The time the tests in the controls were examined
       * If the profile is valid.
       * The reason that the profile is invalid
       * A summary of the check
    ```

1. Navigate back to the `profile-1` profile.

    Add the version line back into the `inspec.yml` file.

    ```ruby
    # ~/learn-inspec/profile-1/inspec.yml
    name: profile-1
    title: InSpec Profile
    maintainer: The Authors
    copyright: The Authors
    copyright_email: you@example.com
    license: All Rights Reserved
    summary: An InSpec Compliance Profile
    version: 0.1.0
    ```

1. Return to the `~/learn-inspec` directory and run `inspec check` again.

    This time the profile-1 control should be valid.

    ```bash
    # ~/learn-inspec
    $inspec check profile-1
    Location:    profile-1
    Profile:     profile-1
    Controls:    3
    Timestamp:   2017-04-12T13:55:45-07:00
    Valid:       true

    No errors or warnings
    ```

1. Run the profile-1 profile in the `~/learn-inspec` directory using `inspec exec profile-1/controls/hello_spec.rb`.

    ```bash
    # ~/learn-inspec
    $ inspec exec profile-1/controls/hello_spec.rb

    Target:  local://

    ✔  world-1.0: hello world
      ✔  File hello.txt should exist
      ✔  File hello.txt content should include "hello world"

    Profile Summary: 1 successful, 0 failures, 0 skipped
    Test Summary: 2 successful, 0 failures, 0 skipped

    ```

## Scan for compliance

In this exercise, you will add a new control to your profile that tests for SSH version using the `sshd_config` resource. You will then learn to check the validity of your control and how to run it against a remote system.

The sshd_config inspec audit resource tests the configuration data on a your virtual machine for the OpenSSH daemon located at <code class="file-path">/etc/ssh/sshd\_config</code> on Linux and Unix.

1. Check that your virtual machine is up and running.

    ```bash
    # ~/learn-inspec
    $ vagrant global-status
    ```
    If you virtual machine is not running, please spin it up:

    ```bash
    # ~/learn-inspec
    $ vagrant up --provision
    ```

1. Change directory to `~/learn-inspec/profile-1/controls` and add a control named "sshd.rb".

    ```bash
    # ~/learn-inspec
    $ cd profile-1/controls
    $ touch sshd.rb
    ```

1. Open the file with an editor of your choice.

    Copy this content into the file:

    ```ruby
    # ~/learn-inspec/profile-1/controls/sshd.rb
    # encoding: utf-8
    # copyright: 2015, The Authors
    # license: All rights reserved

    title 'TBD - sample section'

    # you add controls here
    control 'ssh-1.0' do                        # A unique ID for this control
      impact 0.7                                # The criticality, if this control fails.
      title 'sshd protocol version 2'
      desc 'Verify sshd is using protocol version 2'             # A human-readable title
      describe sshd_config do
        its('Protocol') { should cmp 2 }
      end
    end
    ```

1. You can run this control with `inspec check`, which determines if the control is valid.

    However, this method does not run the test on a remote system.

    ```bash
    # ~/learn-inspec/profile-1/controls
    $ cd ~/learn-inspec
    $ inspec check hello
    Location:    hello
    Profile:     hello
    Controls:    4
    Timestamp:   2017-03-31T20:21:12+00:00
    Valid:       true

    No errors or warnings
    ```

1. You can run the test on a remote system by passing `inspec exec` with a `--target` option.

    You should see that your test was successful.

    ```bash
    # ~/learn-inspec
    $ inspec exec ~/learn-inspec/profile-1/controls/sshd.rb --target=ssh://vagrant:vagrant@localhost:2222

    Target:  ssh://vagrant@localhost:2222

     ✔  ssh-1.0: Compliance tests
      ✔  SSH Configuration Protocol should cmp == 2

    Profile Summary: 1 successful, 0 failures, 0 skipped
   ```

## Make your profile more reusable

What happens if you want to to run the same tests on machines with different content?  Or what if you have information that should not be stored in plain-text cookbooks, like user names or passwords?  For these cases, InSpec uses attributes to act in different ways, depending on different conditions.

In this exercise, you will use two virtual machines and put a hello.txt file onto each one--with slightly different content in each file on each machine.  Then you will add an attribute and a test to your InSpec framework, run the test, see it fail, and then modify the content on each machine so that the test will pass in the correct instance, but otherwise it will fail.

1. Create two Ubuntu virtual machines by copying the following code into your Vagrantfile.

    ```ruby
    # ~/learn-inspec/Vagrantfile
    # encoding: utf-8
    # -*- mode: ruby -*-
    # vi: set ft=ruby :

    $script = <<SCRIPT
    sudo apt-get update
    sudo apt-get install -y curl
    curl https://omnitruck.chef.io/install.sh | sudo bash  -s -- -P chefdk
    sudo apt-get install tree --yes
    SCRIPT

    Vagrant.configure(2) do |config|

      config.vm.define "qa" do |cs|
        cs.vm.box = 'bento/ubuntu-14.04'
        cs.vm.hostname = "qa.test"
        cs.vm.provision "shell", inline: $script
      end

      config.vm.define "dev" do |cs|
        cs.vm.box = 'bento/ubuntu-14.04'
        cs.vm.hostname = "cdv.test"
        cs.vm.provision "shell", inline: $script
      end
    end
    ```

1. Find and make note of the forwarded ports for both the **qa** and **dev** virtual machines.

    ```bash
    # ~/learn-inspec
    $ vagrant port qa

    The forwarded ports for the machine are listed below.
    Please note that these values may differ from values configured in the Vagrantfile if the provider supports automatic port collision detection and resolution.

    22 (guest) => 2222 (host)

    $ vagrant port dev

    The forwarded ports for the machine are listed below.
    Please note that these values may differ from values configured in the Vagrantfile if the provider supports automatic port collision detection and resolution.

    22 (guest) => 2200 (host)
    ```

1. Place a file on the virtual machine **qa** containing "hello world" then exit out of the virtual machine.

    ```bash
    # ~/learn-inspec
    $ vagrant ssh qa
    vagrant@qa$ echo "hello world" > hello.txt
    vagrant@qa$ exit
    ```
1. Place a file on the virtual machine **dev** containing "hello universe" then exit out of the virtual machine.

    ```bash
    # ~/learn-inspec
    $ vagrant ssh dev
    vagrant@dev$ echo "hello universe" > hello.txt
    vagrant@dev$ exit
    ```
1. Run `inspec exec` with a `--target` against each virtual machine.

    You will see one test one succeeding and one test failing.

    ```bash
    # ~/learn-inspec
    $ inspec exec profile-1 --target=ssh://vagrant:vagrant@localhost:2222
      ×  world-1.0: hello world (1 failed)
       ✔  File hello.txt should exist
       ×  File hello.txt content should match /hello universe/

       expected "hello world\n" to match /hello universe/

       Diff:
         @@ -1,2 +1,2 @@
         -/hello universe/
         +hello world

    $ inspec exec profile-1 --target=ssh://vagrant:vagrant@localhost:2200
      ✔  world-1.0: hello world
         ✔  File hello.txt should exist
         ✔  File hello.txt content should match /hello universe/

    ```

1. Modify the world-1.0 control in `~/learn-inspec/profile-1/controls/hello_spec.rb` to add a "role" attribute:

    ```ruby
    # ~/learn-inspec/profile-1/controls/hello_spec.rb
    var_role = attribute('role', default: 'qa', description: "the node's role")

    control "world-1.0" do
      impact 1.0
      title "hello world"

      desc "'hello.txt' should be a file"
      describe file ( 'hello.txt' ) do
        it { should exist }
      end

      desc "hello.txt should contain the required phrase"
      describe file ('hello.txt') do
        its ('content') { should match /hello_spec/ }
      end
    end
    ```

1. Add in an `if` conditional block to change the expected message based on the role.

    ```ruby
    var_role = attribute('role', default: 'qa', description: "the node's role")

    control "world-1.0" do
      impact 1.0
      title "hello world"

      desc "'hello.txt' should be a file"
      describe file ( 'hello.txt' ) do
        it { should exist }
      end

      # ADD IN THIS BLOCK:
      if var_role == 'qa'
        msg = 'hello world'
      else
        msg = 'hello universe'
      end

      desc "hello.txt should contain the required phrase"
      describe file ('hello.txt') do
        its ('content') { should match /hello_spec/ }
      end
    end
    ```

1. Modify the control to use `msg` instead of a hard-coded string.

    ```ruby
    var_role = attribute('role', default: 'qa', description: "the node's role")

    control "world-1.0" do
      impact 1.0
      title "hello world"

      desc "'hello.txt' should be a file"
      describe file ( 'hello.txt' ) do
        it { should exist }
      end

      if var_role == 'qa'
        msg = 'hello world'
      else
        msg = 'hello universe'
      end

      desc "hello.txt should contain the required phrase"
      describe file ('hello.txt') do
         # CHANGE THIS LINE:
        its ('content') { should match /#{msg}/ }
      end
    end
    ```

1. Add attributes files to each virtual machine containing the role attribute.

     The `profile-attribute.yml` file will have the same name on each virtual machine, but the content will be slightly different in each case.

    ```bash
    # ~/learn-inspec
    $ vagrant ssh qa
    vagrant@vagrant:qa$ echo "role: qa" > profile-attribute.yml
    vagrant@vagrant:qa$ ls
    hello.txt profile_attribute.yml
    vagrant@vagrant:qa$ exit

    $ vagrant ssh dev
    vagrant@vagrant:dev$ echo "role: dev" > profile-attribute.yml
    vagrant@vagrant:dev$ ls
    hello.txt profile_attribute.yml
    vagrant@vagrant:dev$ exit
    ```

1. Run `inspec exec` passed with `--attrs` and the name of the attribute file, `profile-attribute.yml`.

    Both commands should succeed on both 'qa' and 'dev'

    ```bash
    # ~/learn-inspec
    $ inspec exec profile-1 --target=ssh://vagrant:vagrant@localhost:2222 --attrs profile-attribute.yml

    Target:  ssh://vagrant@localhost:2222

    ✔  world-1.0: hello world
     ✔  File hello.txt should exist
     ✔  File hello.txt content should match /hello world/


    Profile Summary: 1 successful, 0 failures, 0 skipped

    $ inspec exec profile-1 --target=ssh://vagrant:vagrant@localhost:2200 --attrs profile-attribute.yml

    Target:  ssh://vagrant@localhost:2200

    ✔  world-1.0: hello world
     ✔  File hello.txt should exist
     ✔  File hello.txt content should match /hello universe/


    Profile Summary: 1 successful, 0 failures, 0 skipped
    ```

As you can see, InSpec makes testing different environments with a single control pretty simple. The ease of extending controls reduces the inevitable sprawl of controls and profiles that happens when every individual system, such as ones with different operating systems or different node roles, need a suite of similar tests designated for that purpose only.

## Conclusion

In this module, you learned to write a basic InSpec control, integrated your tests into a profile, and used these tools to scan both local and remote systems. You were also introduced to a few of the different environments where you can integrate InSpec into your continuous automation workflow, such as WinRM, Docker, and the cloud. Finally, you learned to use attributes to test a single control in more than one environment, which will make your controls extendable and flexible.

[TRAINING] Ready to dig deeper? Join us in-person or online at an upcoming instructor-led training event. [Learn more about our course offerings](https://www.chef.io/training/) or [check out our upcoming classes](https://www.chef.io/blog/events/category/training-events/). Use discount code **LEARN-CHEF** to save 10%. Use what you've learned to [gain official Chef certification](https://training.chef.io/certification).
