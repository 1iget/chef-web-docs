<%
platform_name = case current_page.data.platform_id
when 'rhel'
  'CentOS'
when 'ubuntu'
  'Ubuntu'
when 'windows'
  'Windows Server'
end
%>
In the [Manage a node with Chef server](/modules/manage-a-node-chef-server/) module, you built a basic web server configuration. As part of the process, you set up a Chef server, brought up a node to manage, and bootstrapped your node.

The bootstrap process installed the Chef tools on your node, pulled the latest cookbooks from the Chef server, and performed an initial `chef-client` run on your node. After the bootstrap process completed, you made small changes to your web server cookbook and applied those changes to your node. The overall process looks like this:

1. Write a small amount of Chef code that expresses some new policy or feature.
1. Upload your code to the Chef server.
1. Run `chef-client` to apply the updated policy on your node.
1. Log in to your node and manually verify that it's configured as you expect.
1. Repeat the process.

<img src="/assets/images/misc/dev_cycle_4.png" style="width:50%; height:auto; box-shadow:none;" alt="The current development cycle" />

In _Manage a node with Chef server_, you applied a change to your web configuration that failed on your node. Imagine your node represented a piece of your production infrastructure. How could you detect the failure _before_ the change reached production?

Although many teams first verify changes on test infrastructure before applying those changes to production, you can quickly experiment with new features and test configuration changes on temporary test instances using [Test Kitchen](https://docs.chef.io/kitchen.html).

Test Kitchen runs your infrastructure code in an isolated environment that resembles your production environment. With Test Kitchen, you continue to write your Chef code from your workstation, but instead of uploading your code to the Chef server and applying it to a node, Test Kitchen applies your code to a temporary environment, such as a virtual machine on your workstation or a cloud or container instance.

We consider using a temporary environment to be _local development_, no matter where that environment is located. With local development, you can iterate faster and correct mistakes earlier in the development process. Once you've written and verified your code locally, you can upload your cookbooks to the Chef server, bootstrap your node, and run `chef-client` on your node.

Local development shifts the development workflow to one that focuses on correcting mistakes earlier in the development process, _before_ you apply your changes to production systems. In this workflow, you:

1. Write a small amount of Chef code that expresses some new policy or feature.
1. Verify your change on local test instances.
1. Upload your code to the Chef server.
1. Run `chef-client` to apply the updated policy on your node.
1. Repeat the process.

<img src="/assets/images/misc/dev_cycle_4_2.png" style="width:50%; height:auto; box-shadow:none;" alt="The improved development cycle" />

Compare this diagram with the previous one. You see that the verification step occurs earlier in the process, before you upload changes to the Chef server and run `chef-client` on your node.

Another benefit to using Test Kitchen is that the operating system of your virtual environment doesn't need to match your workstation's. So even though you're configuring <%= platform_name %>, your workstation can run macOS, Windows, or Linux.

<% if current_page.data.environment == 'hyper-v' %>

[WINDOWS] Generally speaking, your workstation can run macOS, Windows, or Linux. However, when you run Test Kitchen with Hyper-V, you need to run a version of Windows [that supports Hyper-V](https://en.wikipedia.org/wiki/Hyper-V#System_requirements) as your workstation.

<% end %>

In this module, you'll use Test Kitchen to apply the web server configuration you built in the _Manage a node with Chef server_ module on local test instances. You'll also see how Test Kitchen enables you to experiment and correct mistakes earlier in the development process.

<% accordion('test-configuration', 'Test configuration') do %>

<% markdown do %>

<% render_machine_config(current_page.data.machine_config) %>

<% end %>

<% end %>
