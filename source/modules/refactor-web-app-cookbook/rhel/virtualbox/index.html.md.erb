---
title: 'Refactor the web app cookbook'
short_title: 'Refactor the web app cookbook'
platform: Red Hat Enterprise Linux
platform_id: rhel
category: local-development
logo: refactor.svg
order: 4
time_to_complete: 60 minutes
snippet_path: test-your-infrastructure-code/rhel/virtualbox/refactor-the-web-application
snippet_workstation: ubuntu
machine_config: snippets/test-your-infrastructure-code/rhel/virtualbox/machine_config.md
environment: virtualbox
headings: [
  { label: 'Prerequisites', href: '#prerequisites' },
  { label: "1. Define what you'll refactor", href: '#step1' },
  { label: '2. Make the default ChefSpec test pass', href: '#step2' },
  { label: '3. Create pending tests', href: '#step3' },
  { label: '4. Fill in the pending tests', href: '#step4' },
  { label: '5. Refactor the database configuration', href: '#step5' }
]
---
The [Develop a web app cookbook](/manage-a-web-app/rhel/) tutorial walks you through the creation of a cookbook named `awesome_customers_rhel` that manages a basic web application called Customers that reads customer records from a database and displays them as a table.

![the resulting web page](misc/manage_customers_node.png)

To summarize, the web application configuration:

* uses the [httpd](https://supermarket.chef.io/cookbooks/httpd) cookbook from Chef Supermarket to configure Apache web server.
* creates a user named `web_admin` that is given file ownership of the web content.
* uses the [firewall](https://supermarket.chef.io/cookbooks/firewall) cookbook to ensure that the firewall is open on ports 22 (SSH) and 80 (HTTP).
* uses the [mysql](https://supermarket.chef.io/cookbooks/mysql) and [database](https://supermarket.chef.io/cookbooks/database) cookbooks to configure a MySQL database server and a database instance that holds ficticious customer records.
* uses PHP scripting to connect to the database from the web server.

If you examine the cookbook's source code, you'll notice that much of the information is repeated. For example, here's an excerpt from the cookbook's `database` recipe:

```ruby
# ~/learn-chef/cookbooks/awesome_customers_rhel/recipes/database.rb
# Create the database instance.
mysql_database node['awesome_customers_rhel']['database']['dbname'] do
  connection(
    :host => node['awesome_customers_rhel']['database']['host'],
    :username => node['awesome_customers_rhel']['database']['root_username'],
    :password => node['awesome_customers_rhel']['database']['root_password']
  )
  action :create
end

# Add a database user.
mysql_database_user node['awesome_customers_rhel']['database']['admin_username'] do
  connection(
    :host => node['awesome_customers_rhel']['database']['host'],
    :username => node['awesome_customers_rhel']['database']['root_username'],
    :password => node['awesome_customers_rhel']['database']['root_password']
  )
  password node['awesome_customers_rhel']['database']['admin_password']
  database_name node['awesome_customers_rhel']['database']['dbname']
  host node['awesome_customers_rhel']['database']['host']
  action [:create, :grant]
end
```

Here, you see that the same node attributes are repeated. Other information, such as how to connect to the database, is also repeated.

It's common to refactor such code to make it easier to read and maintain. However, with refactoring comes risk. During the refactoring process, you might accidently change the cookbook's behavior. You would need to verify that each change preserves the functionality you expect. As your project expands, manual testing can become tedious and error-prone.

Here you'll apply what you learned in the [Unit test with ChefSpec](/modules/chefspec/) tutorial by writing a few tests to validate the existing configuration before refactoring the database recipe. As you refactor your recipe, you can rerun your tests to verify the changes are good.

Although a complete solution might involve writing InSpec and ChefSpec tests, along with running RuboCop and Foodcritic, let's focus just on writing ChefSpec tests for now. This scenario is a good candidate for ChefSpec testing because the database recipe uses node attributes. Node attributes introduce variations that can change the way a resource behaves.

<% accordion('test-configuration', 'Test configuration') do %>

<% markdown do %>

<% render_machine_config(current_page.data.machine_config) %>

<% end %>

<% end %>


[START_BOX]

## Prerequisites

To successfully complete this tutorial, you'll need the following:

1. Your workstation set up for Chef development. [Follow these steps](/modules/manage-a-node/rhel/hosted/set-up-your-workstation/) to get set up.
1. The `awesome_customers_rhel` cookbook. If you haven't gone through the [Develop a web app cookbook](/manage-a-web-app/rhel/) tutorial, [follow this quickstart](/manage-a-web-app/rhel/bring-up-the-web-app-using-test-kitchen/) to get a copy of the cookbook from GitHub and run it on a local Test Kitchen instance.
1. Familiarity with [ChefSpec](https://docs.chef.io/chefspec.html). The [Unit test with ChefSpec](/modules/chefspec/) tutorial can help get you started.

[END_BOX]

[START_BOX]

## 1. Define what you'll refactor

The goal is to make the `database` recipe easier to read. To do that, you'll:

* replace each occurence of a node attribute with a variable.
* define the database connection information one time.

By outlining clear goals, we'll know when we're done.

[END_BOX]

[START_BOX]

## 2. Make the default ChefSpec test pass

When you run `chef generate` to create a cookbook or recipe, Chef creates a default ChefSpec test for you. Here's what the test looks like for the `database` recipe.

<% code_snippet(page: current_page, path: 'make-the-default-spec-pass/database_spec-0-rhel') %>

See what happens when you run the default ChefSpec tests.

<% command_snippet(page: current_page, path: 'make-the-default-spec-pass/chef-exec-rspec-database-1') %>

In the output, you'll likely see a number of warnings prior to the test output. These warnings come from the `apt` cookbook, and can be safely ignored.

The default test fails &ndash; you see an error like this.

<% command_snippet(page: current_page, path: 'make-the-default-spec-pass/chef-exec-rspec-database-2', features: :stdout) %>

The error refers to the fact that ChefSpec does not run commands. Therefore, it does not know whether your recipe behaves as intended. Here's the corresponding `execute` resource from the `database` recipe.

<% code_snippet(page: current_page, path: 'make-the-default-spec-pass/database_spec-0-execute-rhel') %>

Any resource that includes a `not_if` or `only_if` guard must provide a [command stub](https://github.com/sethvargo/chefspec#stubbing) in the corresponding ChefSpec test. A command stub tells ChefSpec what result to expect.

A command stub is required because a guard causes a resource to run conditionally. Because ChefSpec doesn't actually run the code, it needs a way to determine whether the resource is run.

If you were to run the ChefSpec test a second time, you would see a different database password in the output.

<% command_snippet(page: current_page, path: 'make-the-default-spec-pass/chef-exec-rspec-database-3', features: :stdout) %>

That's because the ChefSpec test uses `ChefSpec::ServerRunner`, which simulates a Chef server in memory. Node attributes are not preserved between ChefSpec runs; therefore, a [new database password](/manage-a-web-app/rhel/create-the-database-passwords#step1) is regenerated each time the test is run.

You need a way to stub the `mysql` command using consistent data.

Recall that ChefSpec [loads data from fauxhai](/modules/chefspec/rhel/#step2) to set the built-in node attributes. To make it easier to stub the `mysql` command, you can specify additional node attributes when the tests are set up. Let's do that now, as well as stub the `mysql` command.

Make your copy of <% fp 'database_spec.rb' %> look like this.

<% code_snippet(page: current_page, path: 'make-the-default-spec-pass/database_spec-1-rhel') %>

This code also specifies the platform name and version.

Because the code isn't actually run, node attributes values can be whatever you want as long as the format matches what's expected (for example, a cookbook might expect a numeric value to define a port number.) What does matter is that the values are used correctly in your recipe. Here, each node attribute is a string. Each node attribute value includes the string "fake" to indicate that these are fictitious values.

Notice that the command stub uses the node attribute values. It's stubbed to return `false` to tell ChefSpec that the `execute` resource should be run. (The `execute` resource uses a `not_if` guard, so returning `false` tells Chef to apply the resource.)

<% code_snippet(page: current_page, path: 'make-the-default-spec-pass/database_spec-1-before-rhel') %>

Now run ChefSpec.

<% command_snippet(page: current_page, path: 'make-the-default-spec-pass/chef-exec-rspec-database-4') %>

The initial test now passes.

[END_BOX]

[START_BOX]

## 3. Create pending tests for resources that uses node attributes

Because our main goal is to refactor the `database` recipe to not repeat node attributes, let's write a test that verifies each resource that uses them.

Recall that <% fp 'database.rb' %> looks like this.

<% code_snippet(page: current_page, path: 'create-pending-tests/database-0-rhel') %>

These resources each include one or more node attributes:

| Resource              | Line |
|-----------------------|------|
| `mysql_service`       | 12   |
| `mysql_database`      | 23   |
| `mysql_database_user` | 33   |
| `execute`             | 57   |

Another way to think about these resources is by what they accomplish and what tests you might want to write:

| Resource              | Line | Test                                               |
|-----------------------|------|----------------------------------------------------|
| `mysql_service`       | 12   | it 'sets the MySQL service root password'          |
| `mysql_database`      | 23   | it 'creates the database instance'                 |
| `mysql_database_user` | 33   | it 'creates the database user'                     |
| `execute`             | 57   | it 'seeds the database with a table and test data' |

This gives you a checklist to work from.

<% unstyled_list do %>
  <% icon_list_item('square-o') do %>
    it 'sets the MySQL service root password'
  <% end %>
  <% icon_list_item('square-o') do %>
    it 'creates the database instance'
  <% end %>
  <% icon_list_item('square-o') do %>
    it 'creates the database user'
  <% end %>
  <% icon_list_item('square-o') do %>
    it 'seeds the database with a table and test data'
  <% end %>
<% end %>

You can define the tests you want to write up-front and then implement them one at a time. One way to do that is to use [pending examples](https://relishapp.com/rspec/rspec-core/v/3-4/docs/pending-and-skipped-examples/pending-examples#`pending`-for-an-example-that-is-currently-passing). Pending examples have several uses; here you'll use them to indicate tests you want to write later.

Modify <% fp 'database_spec.rb' %> like this.

<% code_snippet(page: current_page, path: 'create-pending-tests/database_spec-2-rhel') %>

Now run the tests.

<% command_snippet(page: current_page, path: 'create-pending-tests/chef-exec-rspec-database-5') %>

Each pending test is marked as a failure. But with failing tests in place, you have clear goals to work towards.

[END_BOX]

[START_BOX]

## 4. Fill in the pending tests

Here are the pending tests you need to implement.

<% unstyled_list do %>
  <% icon_list_item('square-o') do %>
    it 'sets the MySQL service root password'
  <% end %>
  <% icon_list_item('square-o') do %>
    it 'creates the database instance'
  <% end %>
  <% icon_list_item('square-o') do %>
    it 'creates the database user'
  <% end %>
  <% icon_list_item('square-o') do %>
    it 'seeds the database with a table and test data'
  <% end %>
<% end %>

You'll write each test and verify that it passes.

### it 'sets the MySQL service root password'

Replace the first pending test:

<% code_snippet(page: current_page, path: 'write-pending-tests/database_spec-3-before-rhel') %>

with this test:

<% code_snippet(page: current_page, path: 'write-pending-tests/database_spec-3-after-rhel') %>

The `with` method validates the resource's properties. In this example, we're validating this resource:

<% code_snippet(page: current_page, path: 'write-pending-tests/database-mysql-service-excerpt') %>

We don't need to verify the `action` property because that property does not involve a node attribute, so it does not meet our current test concerns. Also, the [create\_mysql_service matcher](https://github.com/chef-cookbooks/mysql/blob/master/libraries/matchers.rb#L25) already validates the `:create` action. If you wanted to validate the `:start` action, you would use the [start\_mysql_service matcher](https://github.com/chef-cookbooks/mysql/blob/master/libraries/matchers.rb#L33).

Run the tests.

<% command_snippet(page: current_page, path: 'write-pending-tests/chef-exec-rspec-database-6') %>

The first pending test now passes, leaving us with 3 remaining tests to write.

<% unstyled_list do %>
  <% icon_list_item('check-square-o') do %>
    it 'sets the MySQL service root password'
  <% end %>
  <% icon_list_item('square-o') do %>
    it 'creates the database instance'
  <% end %>
  <% icon_list_item('square-o') do %>
    it 'creates the database user'
  <% end %>
  <% icon_list_item('square-o') do %>
    it 'seeds the database with a table and test data'
  <% end %>
<% end %>

### it 'creates the database instance' and it 'creates the database user'

The next two resources to test look like this. These resources create the database instance and the user.

<% code_snippet(page: current_page, path: 'write-pending-tests/database-database-instance-user-excerpt') %>

Both resources share the same `connection` property. To make the test code less redundant, you can define a `let` block at the top of your test that defines the connection info.

To define the connection info and implement the second and third tests, make <% fp 'database_spec.rb' %> look like this.

<% code_snippet(page: current_page, path: 'write-pending-tests/database_spec-4-rhel') %>

Notice that the `let` block defines the `connection_info` property that your new tests pass to the `with` method.

Like the first pending test, the second and third tests use the `with` method to validate resource properties.

Now run the tests.

<% command_snippet(page: current_page, path: 'write-pending-tests/chef-exec-rspec-database-7') %>

The second and third pending tests now pass. One final pending test remains.

<% unstyled_list do %>
  <% icon_list_item('check-square-o') do %>
    it 'sets the MySQL service root password'
  <% end %>
  <% icon_list_item('check-square-o') do %>
    it 'creates the database instance'
  <% end %>
  <% icon_list_item('check-square-o') do %>
    it 'creates the database user'
  <% end %>
  <% icon_list_item('square-o') do %>
    it 'seeds the database with a table and test data'
  <% end %>
<% end %>

### it 'seeds the database with a table and test data'

The final pending test verifies this `execute` resource:

<% code_snippet(page: current_page, path: 'make-the-default-spec-pass/database_spec-0-execute-rhel') %>

The value of `#{create_tables_script_path}` comes from here:

<% code_snippet(page: current_page, path: 'write-pending-tests/database-create_tables-excerpt') %>

`Chef::Config[:file_cache_path]` reads the location of the Chef cache from the [chef-client configuration file](https://docs.chef.io/config_rb_client.html). Although the location of the Chef cache can vary, it's typically located at <code class="file-path">/var/chef/cache</code> on Linux.

ChefSpec sets `Chef::Config[:file_cache_path]` by [creating a temporary directory](https://github.com/sethvargo/chefspec/blob/master/lib/chefspec/file_cache_path_proxy.rb). To access the value of `create_tables_script_path`, you'll add a `let` block to your test file.

Modify <% fp 'database_spec.rb' %> to include a `let` block that defines `create_tables_script_path` and to implement the final pending test. The entire file looks like this.

<% code_snippet(page: current_page, path: 'write-pending-tests/database_spec-5-rhel') %>

Now run the tests.

<% command_snippet(page: current_page, path: 'write-pending-tests/chef-exec-rspec-database-8') %>

Success! All tests now pass.

<% unstyled_list do %>
  <% icon_list_item('check-square-o') do %>
    it 'sets the MySQL service root password'
  <% end %>
  <% icon_list_item('check-square-o') do %>
    it 'creates the database instance'
  <% end %>
  <% icon_list_item('check-square-o') do %>
    it 'creates the database user'
  <% end %>
  <% icon_list_item('check-square-o') do %>
    it 'seeds the database with a table and test data'
  <% end %>
<% end %>

Now that you have working tests in place, you can now refactor your `database` recipe. Having the tests continue to pass after you refactor your recipe will give you increased confidence in your work.

[END_BOX]

[START_BOX]

## 5. Refactor the database configuration

Earlier, we outlined these goals:

* Replace each occurence of a node attribute with a variable.
* Define the database connection information one time.

One benefit to writing tests is that it can help show what can be refactored. For instance:

* You know which node attributes are involved because you set them at the start of the test run.
* You know where the database connection info is specified because you defined the `connection_info` variable and used it to verify the `mysql_database` and `mysql_database_user` resources.

Rewrite your `database` recipe like this. This revison replaces each node attribute with a variable and defines the connection information as a variable that can be reused.

<% code_snippet(page: current_page, path: 'refactor-the-database-configuration/database-1-rhel') %>

Now rerun your ChefSpec tests to ensure that your resources are still correctly defined against your refacoring work.

<% command_snippet(page: current_page, path: 'refactor-the-database-configuration/chef-exec-rspec-database-9') %>

Great! All tests continue to pass. If any test failed, you would examine the error and correct your refactored `database` recipe.

If your project had integration tests, such as InSpec tests, you might run `kitchen test` to verify the configuration on a Test Kitchen instance before checking in your change or uploading your cookbook to your Chef server.

Although it's completely acceptable to write test code after you've written your cookbook, in practice you might take the test-driven approach of writing your tests first. Writing your tests first gives you clear goals to work towards. Clearly understanding your requirements  up front may even lead to better quality code, reducing the need to refactor it later.

[GITHUB] [Get the code for this tutorial](https://github.com/learn-chef/awesome_customers_rhel/tree/refactor) on GitHub.

[END_BOX]

<% next_page(current_page) do %>

This tutorial presented a basic refactoring exercise. You started by writing [ChefSpec](https://docs.chef.io/chefspec.html) tests to verify an existing database configuration. Then you refactored the database configuration and reran your tests to verify the configuration still does what you expect.

By having passing tests in place, you're free to experiment and try new things. If your tests continue to pass, you have increased confidence that your configuration remains good.

### Next steps

If you haven't gone through the [Verify with InSpec](/modules/inspec/), [Unit test with ChefSpec](/modules/chefspec/), or [Verify code style](/modules/verify-style/) tutorials, now's a great time. You'll learn how to use InSpec to verify your configuration on virtual test instances, how to use ChefSpec to simulate the execution of your resources in memory, and how to use the lint tools RuboCop and Foodcritic to verify your code adheres to common style guidelines.

Learn more about how to test and debug your Chef code in our [Joy of Automating](/modules/) video series, hosted by Franklin Webber.

If you're involved in your company's compliance and audit process, you may be interested in the [Chef compliance scanner](/modules/compliance-assess/rhel/), which uses InSpec as its auditing and testing framework.

You may also be interested in [Chef Automate](https://www.chef.io/automate/), which gives your operations and development teams a common platform for developing, building, testing, and deploying cookbooks, applications, and more. Chef Automate reinforces the Chef workflow, where you begin by developing and testing your configuration from your local workstation. Then, you submit your change to Chef Automate's pipeline, where your change goes through sets of automated tests before going out into production. If you have many different teams, each delivering software in its own way, you can use Chef Automate to bring a standard, proven approach to all of your organization's deployments.

[TRAINING] Ready to dig deeper? Join us in-person or online at an upcoming instructor-led training event. [Learn more about our course offerings](https://www.chef.io/training/) or [check out our upcoming classes](https://www.chef.io/blog/events/category/training-events/). Use discount code **LEARN-CHEF** to save 10%. Use what you've learned to [gain official Chef certification](https://training.chef.io/certification).

<% end %>
